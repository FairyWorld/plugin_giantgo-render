var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
import { resolveComponent, TransitionGroup, defineComponent, h as h$1, nextTick, openBlock, createElementBlock, createElementVNode, createVNode, withCtx, toDisplayString, getCurrentInstance, computed, isRef, onUnmounted, watch, Comment, Fragment, inject, ref, unref, getCurrentScope, onScopeDispose, shallowRef, onMounted, onUpdated, normalizeClass, normalizeStyle, createCommentVNode, renderSlot, mergeProps, withModifiers, onBeforeUnmount, provide, createBlock, Transition, withDirectives, vShow, resolveDynamicComponent, onActivated, onDeactivated, cloneVNode, Teleport, reactive, toRef, resolveDirective, renderList, createTextVNode, toRefs, vModelCheckbox, withKeys, vModelRadio, onBeforeUpdate, vModelText, watchEffect, toRaw, triggerRef, createSlots, normalizeProps, guardReactiveProps, onBeforeMount, isVNode, render as render$t, defineAsyncComponent } from "vue";
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
var version = "1.14.0";
function userAgent(pattern4) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern4);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on$1(el, event, fn2) {
  el.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off$1(el, event, fn2) {
  el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height2, width2;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height2 = elRect.height;
    width2 = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height2 = window.innerHeight;
    width2 = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width2 /= scaleX;
      height2 /= scaleY;
      bottom2 = top2 + height2;
      right2 = left2 + width2;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width: width2,
    height: height2
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options2, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options2.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index$5(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i))
      continue;
    for (var key2 in obj) {
      if (obj.hasOwnProperty(key2) && obj[key2] === arr[i][key2])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend$1(dst, src) {
  if (dst && src) {
    for (var key2 in src) {
      if (src.hasOwnProperty(key2)) {
        dst[key2] = src[key2];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle$2(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y) {
  el.scrollLeft += x2;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options2) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options2.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options2) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends$1(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends$1(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options2 = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options2[onName]) {
    options2[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options2) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options2), child2 = getChild(el, 1, options2), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options2) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options2.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options2.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options2) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options2 = _extends$1({}, options2);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options2) && (options2[name] = defaults2[name]);
  }
  _prepareGroup(options2);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options2.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options2.supportPointer) {
    on$1(el, "pointerdown", this._onTapStart);
  } else {
    on$1(el, "mousedown", this._onTapStart);
    on$1(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on$1(el, "dragover", this);
    on$1(el, "dragenter", this);
  }
  sortables.push(this.el);
  options2.store && options2.store.get && this.sort(options2.store.get(this) || []);
  _extends$1(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options2 = this.options, preventOnFilter = options2.preventOnFilter, type4 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options2.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type4) && evt.button !== 0 || options2.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options2.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$5(target);
    oldDraggableIndex = index$5(target, options2.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options2.handle && !closest(originalTarget, options2.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options2 = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options2.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options2.chosenClass, true);
      };
      options2.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mouseup", _this._onDrop);
      on$1(ownerDocument, "touchend", _this._onDrop);
      on$1(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options2.delay && (!options2.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options2.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options2.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off$1(ownerDocument, "mouseup", this._disableDelayedDrag);
    off$1(ownerDocument, "touchend", this._disableDelayedDrag);
    off$1(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off$1(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off$1(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off$1(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on$1(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on$1(document, "touchmove", this._onTouchMove);
      } else {
        on$1(document, "mousemove", this._onTouchMove);
      }
    } else {
      on$1(dragEl, "dragend", this);
      on$1(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on$1(document, "dragover", _checkOutsideTargetEl);
      }
      var options2 = this.options;
      !fallback && toggleClass(dragEl, options2.dragClass, false);
      toggleClass(dragEl, options2.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options2 = this.options, fallbackTolerance = options2.fallbackTolerance, fallbackOffset = options2.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options2 = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options2.ghostClass, false);
      toggleClass(ghostEl, options2.fallbackClass, true);
      toggleClass(ghostEl, options2.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options2 = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options2.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off$1(document, "mouseup", _this._onDrop);
      off$1(document, "touchend", _this._onDrop);
      off$1(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options2.setData && options2.setData.call(_this, dataTransfer, dragEl);
      }
      on$1(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on$1(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options2 = this.options, group = options2.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options2.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options2.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options2.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options2.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$5(dragEl);
      newDraggableIndex = index$5(dragEl, options2.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options2.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options2.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options2.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options2, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options2.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options2.swapThreshold, options2.invertedSwapThreshold == null ? options2.swapThreshold : options2.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$5(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off$1(document, "mousemove", this._onTouchMove);
    off$1(document, "touchmove", this._onTouchMove);
    off$1(document, "pointermove", this._onTouchMove);
    off$1(document, "dragover", nearestEmptyInsertDetectEvent);
    off$1(document, "mousemove", nearestEmptyInsertDetectEvent);
    off$1(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off$1(ownerDocument, "mouseup", this._onDrop);
    off$1(ownerDocument, "touchend", this._onDrop);
    off$1(ownerDocument, "pointerup", this._onDrop);
    off$1(ownerDocument, "touchcancel", this._onDrop);
    off$1(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options2 = this.options;
    newIndex = index$5(dragEl);
    newDraggableIndex = index$5(dragEl, options2.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$5(dragEl);
    newDraggableIndex = index$5(dragEl, options2.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off$1(document, "drop", this);
      off$1(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options2.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off$1(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order2 = [], el, children = this.el.children, i = 0, n = children.length, options2 = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options2.draggable, this.el, false)) {
        order2.push(el.getAttribute(options2.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id2] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options2 = this.options;
    if (value === void 0) {
      return options2[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options2[name] = modifiedValue;
      } else {
        options2[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options2);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off$1(el, "mousedown", this._onTapStart);
    off$1(el, "touchstart", this._onTapStart);
    off$1(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off$1(el, "dragover", this);
      off$1(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$5(dragEl) < index$5(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs2 = root2.getElementsByTagName("input");
  var idx = inputs2.length;
  while (idx--) {
    var el = inputs2[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on$1(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on$1,
  off: off$1,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend$1,
  throttle: throttle$2,
  closest,
  toggleClass,
  clone,
  index: index$5,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options2) {
  return new Sortable(el, options2);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on$1(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on$1(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on$1(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on$1(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off$1(document, "dragover", this._handleAutoScroll);
      } else {
        off$1(document, "pointermove", this._handleFallbackAutoScroll);
        off$1(document, "touchmove", this._handleFallbackAutoScroll);
        off$1(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends$1(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle$2(function(evt, options2, rootEl2, isFallback) {
  if (!options2.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options2.scrollSensitivity, speed = options2.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options2.scroll;
    scrollCustomFn = options2.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width2 = rect.width, height2 = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width2 < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height2 < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width2 < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height2 < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width2 < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y) <= sens && scrollPosY + height2 < scrollHeight) - (Math.abs(top2 - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options2.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends$1(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends$1(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}
function insertNodeAt(fatherNode, node, position) {
  const refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}
function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }
  return global.console;
}
const console$1 = getConsole();
function cached(fn2) {
  const cache = Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
}
const regex = /-(\w)/g;
const camelize$1 = cached((str) => str.replace(regex, (_2, c2) => c2.toUpperCase()));
const manageAndEmit$1 = ["Start", "Add", "Remove", "Update", "End"];
const emit$1 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
const manage$1 = ["Move"];
const eventHandlerNames = [manage$1, manageAndEmit$1, emit$1].flatMap((events2) => events2).map((evt) => `on${evt}`);
const events = {
  manage: manage$1,
  manageAndEmit: manageAndEmit$1,
  emit: emit$1
};
function isReadOnly(eventName) {
  return eventHandlerNames.indexOf(eventName) !== -1;
}
const tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function isHtmlTag(name) {
  return tags.includes(name);
}
function isTransition(name) {
  return ["transition-group", "TransitionGroup"].includes(name);
}
function isHtmlAttribute(value) {
  return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
}
function project(entries) {
  return entries.reduce((res, [key2, value]) => {
    res[key2] = value;
    return res;
  }, {});
}
function getComponentAttributes({ $attrs, componentData = {} }) {
  const attributes = project(Object.entries($attrs).filter(([key2, _2]) => isHtmlAttribute(key2)));
  return __spreadValues(__spreadValues({}, attributes), componentData);
}
function createSortableOption({ $attrs, callBackBuilder }) {
  const options2 = project(getValidSortableEntries($attrs));
  Object.entries(callBackBuilder).forEach(([eventType, eventBuilder]) => {
    events[eventType].forEach((event) => {
      options2[`on${event}`] = eventBuilder(event);
    });
  });
  const draggable2 = `[data-draggable]${options2.draggable || ""}`;
  return __spreadProps(__spreadValues({}, options2), {
    draggable: draggable2
  });
}
function getValidSortableEntries(value) {
  return Object.entries(value).filter(([key2, _2]) => !isHtmlAttribute(key2)).map(([key2, value2]) => [camelize$1(key2), value2]).filter(([key2, _2]) => !isReadOnly(key2));
}
const getHtmlElementFromNode = ({ el }) => el;
const addContext = (domElement, context) => domElement.__draggable_context = context;
const getContext = (domElement) => domElement.__draggable_context;
class ComponentStructure {
  constructor({
    nodes: { header, default: defaultNodes, footer },
    root: root2,
    realList
  }) {
    this.defaultNodes = defaultNodes;
    this.children = [...header, ...defaultNodes, ...footer];
    this.externalComponent = root2.externalComponent;
    this.rootTransition = root2.transition;
    this.tag = root2.tag;
    this.realList = realList;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(h2, attributes) {
    const { tag, children, _isRootComponent } = this;
    const option2 = !_isRootComponent ? children : { default: () => children };
    return h2(tag, attributes, option2);
  }
  updated() {
    const { defaultNodes, realList } = this;
    defaultNodes.forEach((node, index2) => {
      addContext(getHtmlElementFromNode(node), {
        element: realList[index2],
        index: index2
      });
    });
  }
  getUnderlyingVm(domElement) {
    return getContext(domElement);
  }
  getVmIndexFromDomIndex(domIndex, element) {
    const { defaultNodes } = this;
    const { length } = defaultNodes;
    const domChildren = element.children;
    const domElement = domChildren.item(domIndex);
    if (domElement === null) {
      return length;
    }
    const context = getContext(domElement);
    if (context) {
      return context.index;
    }
    if (length === 0) {
      return 0;
    }
    const firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
    const indexFirstDomListElement = [...domChildren].findIndex((element2) => element2 === firstDomListElement);
    return domIndex < indexFirstDomListElement ? 0 : length;
  }
}
function getSlot(slots, key2) {
  const slotValue = slots[key2];
  return slotValue ? slotValue() : [];
}
function computeNodes({ $slots, realList, getKey }) {
  const normalizedList = realList || [];
  const [header, footer] = ["header", "footer"].map((name) => getSlot($slots, name));
  const { item } = $slots;
  if (!item) {
    throw new Error("draggable element must have an item slot");
  }
  const defaultNodes = normalizedList.flatMap((element, index2) => item({ element, index: index2 }).map((node) => {
    node.key = getKey(element);
    node.props = __spreadProps(__spreadValues({}, node.props || {}), { "data-draggable": true });
    return node;
  }));
  if (defaultNodes.length !== normalizedList.length) {
    throw new Error("Item slot must have only one child");
  }
  return {
    header,
    footer,
    default: defaultNodes
  };
}
function getRootInformation(tag) {
  const transition = isTransition(tag);
  const externalComponent = !isHtmlTag(tag) && !transition;
  return {
    transition,
    externalComponent,
    tag: externalComponent ? resolveComponent(tag) : transition ? TransitionGroup : tag
  };
}
function computeComponentStructure({ $slots, tag, realList, getKey }) {
  const nodes = computeNodes({ $slots, realList, getKey });
  const root2 = getRootInformation(tag);
  return new ComponentStructure({ nodes, root: root2, realList });
}
function emit(evtName, evtData) {
  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function manage(evtName) {
  return (evtData, originalElement) => {
    if (this.realList !== null) {
      return this[`onDrag${evtName}`](evtData, originalElement);
    }
  };
}
function manageAndEmit(evtName) {
  const delegateCallBack = manage.call(this, evtName);
  return (evtData, originalElement) => {
    delegateCallBack.call(this, evtData, originalElement);
    emit.call(this, evtName, evtData);
  };
}
let draggingElement = null;
const props = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (original) => {
      return original;
    }
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
const emits = [
  "update:modelValue",
  "change",
  ...[...events.manageAndEmit, ...events.emit].map((evt) => evt.toLowerCase())
];
const draggableComponent = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props,
  emits,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots, $attrs, tag, componentData, realList, getKey } = this;
      const componentStructure = computeComponentStructure({
        $slots,
        tag,
        realList,
        getKey
      });
      this.componentStructure = componentStructure;
      const attributes = getComponentAttributes({ $attrs, componentData });
      return componentStructure.render(h$1, attributes);
    } catch (err) {
      this.error = true;
      return h$1("pre", { style: { color: "red" } }, err.stack);
    }
  },
  created() {
    if (this.list !== null && this.modelValue !== null) {
      console$1.error("modelValue and list props are mutually exclusive! Please set one or another.");
    }
  },
  mounted() {
    if (this.error) {
      return;
    }
    const { $attrs, $el, componentStructure } = this;
    componentStructure.updated();
    const sortableOptions = createSortableOption({
      $attrs,
      callBackBuilder: {
        manageAndEmit: (event) => manageAndEmit.call(this, event),
        emit: (event) => emit.bind(this, event),
        manage: (event) => manage.call(this, event)
      }
    });
    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
    this._sortable = new Sortable(targetDomElement, sortableOptions);
    this.targetDomElement = targetDomElement;
    targetDomElement.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    if (this._sortable !== void 0)
      this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list } = this;
      return list ? list : this.modelValue;
    },
    getKey() {
      const { itemKey } = this;
      if (typeof itemKey === "function") {
        return itemKey;
      }
      return (element) => element[itemKey];
    }
  },
  watch: {
    $attrs: {
      handler(newOptionValue) {
        const { _sortable } = this;
        if (!_sortable)
          return;
        getValidSortableEntries(newOptionValue).forEach(([key2, value]) => {
          _sortable.option(key2, value);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(domElement) {
      return this.componentStructure.getUnderlyingVm(domElement) || null;
    },
    getUnderlyingPotencialDraggableComponent(htmElement) {
      return htmElement.__draggable_component__;
    },
    emitChanges(evt) {
      nextTick(() => this.$emit("change", evt));
    },
    alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }
      const newList = [...this.modelValue];
      onList(newList);
      this.$emit("update:modelValue", newList);
    },
    spliceList() {
      const spliceList = (list) => list.splice(...arguments);
      this.alterList(spliceList);
    },
    updatePosition(oldIndex2, newIndex2) {
      const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent({ to, related }) {
      const component = this.getUnderlyingPotencialDraggableComponent(to);
      if (!component) {
        return { component };
      }
      const list = component.realList;
      const context = { list, component };
      if (to !== related && list) {
        const destination = component.getUnderlyingVm(related) || {};
        return __spreadValues(__spreadValues({}, destination), context);
      }
      return context;
    },
    getVmIndexFromDomIndex(domIndex) {
      return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
    },
    onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd(evt) {
      const element = evt.item._underlying_vm_;
      if (element === void 0) {
        return;
      }
      removeNode(evt.item);
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.spliceList(newIndex2, 0, element);
      const added = { element, newIndex: newIndex2 };
      this.emitChanges({ added });
    },
    onDragRemove(evt) {
      insertNodeAt(this.$el, evt.item, evt.oldIndex);
      if (evt.pullMode === "clone") {
        removeNode(evt.clone);
        return;
      }
      const { index: oldIndex2, element } = this.context;
      this.spliceList(oldIndex2, 1);
      const removed = { element, oldIndex: oldIndex2 };
      this.emitChanges({ removed });
    },
    onDragUpdate(evt) {
      removeNode(evt.item);
      insertNodeAt(evt.from, evt.item, evt.oldIndex);
      const oldIndex2 = this.context.index;
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.updatePosition(oldIndex2, newIndex2);
      const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
      this.emitChanges({ moved: moved2 });
    },
    computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }
      const domChildren = [...evt.to.children].filter((el) => el.style["display"] !== "none");
      const currentDomIndex = domChildren.indexOf(evt.related);
      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
      const draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove(evt, originalEvent) {
      const { move, realList } = this;
      if (!move || !realList) {
        return true;
      }
      const relatedContext = this.getRelatedContextFromMoveEvent(evt);
      const futureIndex = this.computeFutureIndex(relatedContext, evt);
      const draggedContext = __spreadProps(__spreadValues({}, this.context), {
        futureIndex
      });
      const sendEvent = __spreadProps(__spreadValues({}, evt), {
        relatedContext,
        draggedContext
      });
      return move(sendEvent, originalEvent);
    },
    onDragEnd() {
      draggingElement = null;
    }
  }
});
function debounce$3(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    }, wait);
    if (callNow)
      func.apply(context, args);
  };
}
function deepClone(item) {
  if (!item) {
    return item;
  }
  var types2 = [Number, String, Boolean], result;
  types2.forEach(function(type4) {
    if (item instanceof type4) {
      result = type4(item);
    }
  });
  if (typeof result == "undefined") {
    if (Object.prototype.toString.call(item) === "[object Array]") {
      result = [];
      item.forEach(function(child, index2, array4) {
        result[index2] = deepClone(child);
      });
    } else if (typeof item == "object") {
      if (item.nodeType && typeof item.cloneNode == "function") {
        result = item.cloneNode(true);
      } else if (!item.prototype) {
        if (item instanceof Date) {
          result = new Date(item);
        } else {
          result = {};
          for (var i in item) {
            result[i] = deepClone(item[i]);
          }
        }
      } else {
        {
          result = item;
        }
      }
    } else {
      result = item;
    }
  }
  return result;
}
function validateInterpolation(str) {
  const re = /\{\{((?:.|\n)+?)\}\}/g;
  return re.test(str);
}
function getInterpolation(str) {
  const interpolationReg = /\{\{((?:.|\n)+?)\}\}/g;
  if (interpolationReg.test(str)) {
    interpolationReg.lastIndex = 0;
    return interpolationReg.exec(str)[1];
  } else {
    return str;
  }
}
function isEmptyObject(obj) {
  var name;
  for (name in obj) {
    return false;
  }
  return true;
}
function isPrimitive(val) {
  return !["object", "function"].includes(typeof val) || val === null;
}
function hasOwn$1(obj, key2) {
  return Object.hasOwnProperty.call(obj, key2);
}
function uuid(len, radix) {
  var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
  var uuid2 = [];
  var i;
  radix = radix || chars.length;
  if (len) {
    for (i = 0; i < len; i++)
      uuid2[i] = chars[0 | Math.random() * radix];
  } else {
    var r;
    uuid2[8] = uuid2[13] = uuid2[18] = uuid2[23] = "-";
    uuid2[14] = "4";
    for (i = 0; i < 36; i++) {
      if (!uuid2[i]) {
        r = 0 | Math.random() * 16;
        uuid2[i] = chars[i == 19 ? r & 3 | 8 : r];
      }
    }
  }
  return uuid2.join("");
}
const rules$2 = [{ required: false, message: "\u5FC5\u586B\u9879", trigger: "blur" }];
const inputs = [
  {
    name: "\u8F93\u5165\u6846",
    component: "input",
    uuid: "",
    options: {
      label: "\u8F93\u5165\u6846",
      key: "",
      defaultValue: "",
      rules: rules$2,
      width: "100%",
      placeholder: "\u8BF7\u8F93\u5165",
      prefixIcon: "",
      suffixIcon: "",
      hidden: false,
      clearable: false,
      disabled: false,
      showPassword: false,
      maxlength: 50,
      showWordLimit: true
    }
  },
  {
    name: "\u6587\u672C\u6846",
    component: "textarea",
    uuid: "",
    options: {
      label: "\u6587\u672C\u6846",
      key: "",
      defaultValue: "",
      rules: rules$2,
      width: "100%",
      placeholder: "\u8BF7\u8F93\u5165\u5185\u5BB9",
      rows: 4,
      hidden: false,
      disabled: false,
      maxlength: 50,
      showWordLimit: true
    }
  },
  {
    name: "\u6570\u5B57\u8F93\u5165\u6846",
    component: "number",
    uuid: "",
    options: {
      label: "\u6570\u5B57\u8F93\u5165\u6846",
      key: "",
      defaultValue: 10,
      rules: rules$2,
      width: "100%",
      min: 0,
      max: 100,
      hidden: false,
      disabled: false
    }
  }
];
const pickers = [
  {
    name: "\u4E0B\u62C9\u5355\u9009",
    component: "select",
    uuid: "",
    options: {
      label: "\u4E0B\u62C9\u5355\u9009",
      key: "",
      options: {
        remote: false,
        items: []
      },
      defaultValue: "",
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      noDataText: "\u6682\u65E0\u6570\u636E",
      noMatchText: "\u65E0\u5339\u914D\u6570\u636E",
      width: "100%",
      hidden: false,
      clearable: false,
      disabled: false,
      filterable: false
    }
  },
  {
    name: "\u4E0B\u62C9\u591A\u9009",
    component: "multi-select",
    uuid: "",
    options: {
      label: "\u4E0B\u62C9\u591A\u9009",
      key: "",
      options: {
        remote: false,
        items: []
      },
      defaultValue: [],
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      noDataText: "\u6682\u65E0\u6570\u636E",
      noMatchText: "\u65E0\u5339\u914D\u6570\u636E",
      width: "100%",
      hidden: false,
      clearable: false,
      disabled: false,
      filterable: false,
      collapseTags: false,
      multipleLimit: 0
    }
  },
  {
    name: "\u7EA7\u8054\u9009\u62E9\u5668",
    component: "cascader",
    uuid: "",
    options: {
      label: "\u7EA7\u8054\u9009\u62E9\u5668",
      key: "",
      options: {
        remote: false,
        items: []
      },
      defaultValue: [],
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      width: "100%",
      expandTrigger: "click",
      hidden: false,
      clearable: false,
      disabled: false,
      filterable: false,
      collapseTags: false,
      multipleLimit: 0,
      rules: rules$2
    }
  },
  {
    name: "\u591A\u9009\u6846",
    component: "checkbox",
    uuid: "",
    options: {
      label: "\u591A\u9009\u6846",
      key: "",
      options: {
        remote: false,
        items: []
      },
      defaultValue: [],
      rules: rules$2,
      width: "100%",
      hidden: false,
      disabled: false
    }
  },
  {
    name: "\u5355\u9009\u6846",
    component: "radio",
    uuid: "",
    options: {
      label: "\u5355\u9009\u6846",
      key: "",
      options: {
        remote: false,
        items: []
      },
      defaultValue: "",
      rules: rules$2,
      width: "100%",
      hidden: false,
      disabled: false
    }
  },
  {
    name: "\u65F6\u95F4\u9009\u62E9\u5668",
    component: "time-picker",
    uuid: "",
    options: {
      label: "\u65F6\u95F4\u9009\u62E9\u5668",
      key: "",
      defaultValue: void 0,
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      width: "100%",
      prefixIcon: "el-icon-time",
      format: "HH:mm:ss",
      hidden: false,
      clearable: false,
      disabled: false
    }
  },
  {
    name: "\u65F6\u95F4\u8303\u56F4",
    component: "time-range-picker",
    uuid: "",
    options: {
      label: "\u65F6\u95F4\u8303\u56F4",
      key: "",
      defaultValue: [],
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      width: "100%",
      prefixIcon: "el-icon-time",
      format: "HH:mm:ss",
      hidden: false,
      clearable: false,
      disabled: false
    }
  },
  {
    name: "\u65E5\u671F\u9009\u62E9\u5668",
    component: "date-picker",
    uuid: "",
    options: {
      label: "\u65E5\u671F\u9009\u62E9\u5668",
      key: "",
      defaultValue: void 0,
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      width: "100%",
      prefixIcon: "el-icon-time",
      format: "YYYY-MM-DD",
      hidden: false,
      clearable: false,
      disabled: false
    }
  },
  {
    name: "\u65E5\u671F\u8303\u56F4",
    component: "date-range-picker",
    uuid: "",
    options: {
      label: "\u65E5\u671F\u8303\u56F4",
      key: "",
      defaultValue: [],
      rules: rules$2,
      placeholder: "\u8BF7\u9009\u62E9",
      width: "100%",
      prefixIcon: "el-icon-time",
      format: "YYYY-MM-DD",
      hidden: false,
      clearable: false,
      disabled: false
    }
  },
  {
    name: "\u8BC4\u5206",
    component: "rate",
    uuid: "",
    options: {
      label: "\u8BC4\u5206",
      key: "",
      defaultValue: 3,
      rules: rules$2,
      width: "100%",
      max: 5,
      hidden: false,
      disabled: false,
      allowHalf: false
    }
  },
  {
    name: "\u6ED1\u5757",
    component: "slider",
    uuid: "",
    options: {
      label: "\u6ED1\u5757",
      key: "",
      defaultValue: 10,
      rules: rules$2,
      width: "100%",
      min: 0,
      max: 100,
      step: 1,
      hidden: false,
      disabled: false,
      showStops: false,
      showToolTip: true,
      showInput: false
    }
  },
  {
    name: "\u5F00\u5173",
    component: "switch",
    uuid: "",
    options: {
      label: "\u5F00\u5173",
      key: "",
      defaultValue: false,
      rules: rules$2,
      width: "100%",
      hidden: false,
      disabled: false,
      activeText: "",
      inactiveText: "",
      activeColor: "#409EFF",
      inactiveColor: "#C0CCDA"
    }
  },
  {
    name: "\u989C\u8272\u9009\u62E9\u5668",
    component: "color-picker",
    uuid: "",
    options: {
      label: "\u989C\u8272\u9009\u62E9\u5668",
      key: "",
      defaultValue: "",
      rules: rules$2,
      width: "100%",
      hidden: false,
      disabled: false,
      showAlpha: false
    }
  },
  {
    name: "\u6587\u4EF6\u4E0A\u4F20",
    component: "upload",
    uuid: "",
    options: {
      label: "\u6587\u4EF6\u4E0A\u4F20",
      key: "",
      defaultValue: [],
      rules: rules$2,
      width: "100%",
      uploadUrl: "https://jsonplaceholder.typicode.com/posts/",
      uploadName: "file",
      buttonText: "\u4E0A\u4F20\u6587\u4EF6",
      uploadSize: "500KB",
      tip: "",
      uploadData: {},
      uploadHeaders: {},
      limit: 3,
      hidden: false,
      disabled: false,
      showToolTip: false,
      showFileList: false,
      multiple: false
    }
  }
];
const complexs = [
  {
    name: "\u5BCC\u6587\u672C\u7F16\u8F91\u5668",
    component: "editor",
    uuid: "",
    options: {
      label: "\u5BCC\u6587\u672C\u7F16\u8F91\u5668",
      key: "",
      defaultValue: "",
      rules: rules$2,
      width: "100%",
      height: "100px",
      placeholder: "\u8BF7\u8F93\u5165",
      hidden: false,
      disabled: false
    }
  }
];
const objectLayout = {
  name: "\u5BF9\u8C61\u5E03\u5C40",
  component: "object",
  uuid: "",
  options: {
    label: "\u5BF9\u8C61\u5E03\u5C40",
    key: "",
    defaultValue: {},
    width: "100%",
    gutter: 0
  },
  items: []
};
const layouts = [
  objectLayout,
  {
    name: "\u5361\u7247\u5E03\u5C40",
    component: "card",
    uuid: "",
    options: {
      label: "\u5361\u7247\u5E03\u5C40",
      key: "",
      defaultValue: {},
      width: "100%",
      gutter: 0,
      shadow: "always",
      padding: "20px 20px 20px 20px"
    },
    items: []
  },
  {
    name: "\u6807\u7B7E\u5E03\u5C40",
    component: "tabs",
    uuid: "",
    options: {
      label: "\u6807\u7B7E\u5E03\u5C40",
      key: "",
      defaultValue: {},
      width: "100%",
      tabType: "border-card",
      tabPosition: "top"
    },
    items: []
  },
  {
    name: "\u5217\u8868",
    component: "table",
    uuid: "",
    options: {
      label: "\u5217\u8868",
      key: "",
      defaultValue: [],
      width: "100%"
    },
    items: []
  }
];
const form = {
  name: "\u8868\u5355",
  component: "object",
  uuid: "root",
  options: {
    labelWidth: "120px",
    labelPosition: "right",
    size: "medium",
    gutter: 0,
    hideRequiredAsterisk: false,
    statusIcon: false
  },
  items: []
};
const components$3 = [form, ...inputs, ...pickers, ...complexs, ...layouts];
const optionKeyLabels = {
  activeColor: "\u6253\u5F00\u65F6\u80CC\u666F\u8272",
  activeText: "\u6253\u5F00\u65F6\u6587\u5B57\u63CF\u8FF0",
  allowHalf: "\u5141\u8BB8\u534A\u9009",
  buttonText: "\u6309\u94AE\u6587\u5B57",
  clearable: "\u53EF\u6E05\u9664",
  collapseTags: "\u591A\u9009\u5408\u5E76\u663E\u793A",
  defaultValue: "\u9ED8\u8BA4\u503C",
  disabled: "\u7981\u7528",
  expandTrigger: "\u89E6\u53D1\u5B50\u83DC\u5355\u65B9\u5F0F",
  filterable: "\u53EF\u641C\u7D22",
  format: "\u663E\u793A\u683C\u5F0F",
  gutter: "\u884C\u5185\u95F4\u8DDD",
  hidden: "\u9690\u85CF",
  hideRequiredAsterisk: "\u9690\u85CF\u5FC5\u9009\u6807\u8BB0",
  inactiveColor: "\u5173\u95ED\u65F6\u80CC\u666F\u8272",
  inactiveText: "\u5173\u95ED\u65F6\u6587\u5B57\u63CF\u8FF0",
  inline: "\u662F\u5426\u884C\u5185\u8868\u5355",
  key: "\u5B57\u6BB5\u540D\u79F0(\u82F1\u6587)",
  labelPosition: "\u5BF9\u9F50\u65B9\u5F0F",
  labelWidth: "\u6807\u7B7E\u5BBD\u5EA6",
  label: "\u6807\u7B7E",
  limit: "\u4E2A\u6570\u9650\u5236",
  max: "\u6700\u5927\u503C",
  maxlength: "\u6700\u5927\u957F\u5EA6",
  min: "\u6700\u5C0F\u503C",
  multipleLimit: "\u591A\u9009\u4E2A\u6570\u9650\u5236",
  multiple: "\u5141\u8BB8\u591A\u9009",
  noDataText: "\u65E0\u9009\u9879\u63D0\u793A",
  noMatchText: "\u641C\u7D22\u65E0\u5339\u914D\u63D0\u793A",
  options: "\u9009\u9879",
  padding: "\u5185\u8FB9\u8DDD",
  placeholder: "\u5360\u4F4D\u6587\u672C",
  prefixIcon: "\u524D\u7F00\u56FE\u6807",
  rows: "\u6587\u672C\u57DF\u9AD8\u5EA6",
  rules: "\u9A8C\u8BC1",
  shadow: "\u9634\u5F71\u663E\u793A",
  showAlpha: "\u900F\u660E\u5EA6\u9009\u62E9",
  showFileList: "\u663E\u793A\u4E0A\u4F20\u5217\u8868",
  showInput: "\u663E\u793A\u8F93\u5165\u6846",
  showPassword: "\u5BC6\u7801\u6846",
  showStops: "\u663E\u793A\u95F4\u65AD\u70B9",
  showToolTip: "\u663E\u793A\u63D0\u793A",
  showWordLimit: "\u663E\u793A\u5B57\u6570\u7EDF\u8BA1",
  size: "\u7EC4\u4EF6\u5C3A\u5BF8",
  statusIcon: "\u663E\u793A\u6821\u9A8C\u53CD\u9988\u56FE\u6807",
  suffixIcon: "\u540E\u7F00\u56FE\u6807",
  tabPosition: "\u9009\u9879\u5361\u4F4D\u7F6E",
  tabType: "\u9009\u9879\u5361\u6837\u5F0F",
  tip: "\u63D0\u793A\u8BF4\u660E\u6587\u5B57",
  uploadData: "\u4E0A\u4F20\u989D\u5916\u53C2\u6570",
  uploadHeaders: "\u4E0A\u4F20\u8BF7\u6C42\u5934\u90E8",
  uploadName: "\u6587\u4EF6\u5B57\u6BB5\u540D",
  uploadSize: "\u4E0A\u4F20\u5927\u5C0F\u9650\u5236",
  uploadUrl: "\u4E0A\u4F20\u5730\u5740",
  width: "\u7EC4\u4EF6\u5BBD\u5EA6",
  height: "\u7EC4\u4EF6\u9AD8\u5EA6"
};
var _export_sfc = (sfc, props2) => {
  for (const [key2, val] of props2) {
    sfc[key2] = val;
  }
  return sfc;
};
const _sfc_main$1L = {
  components: { draggable: draggableComponent },
  setup() {
    return {
      clone: (original) => {
        const item = deepClone(original);
        item.uuid = item.options.key = item.component.replaceAll("-", "_") + "_" + uuid(8);
        return item;
      },
      inputs,
      pickers,
      complexs,
      layouts
    };
  }
};
const _hoisted_1$Q = { class: "form-picker" };
const _hoisted_2$F = { class: "form-item-section" };
const _hoisted_3$A = /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u8F93\u5165\u7EC4\u4EF6", -1);
const _hoisted_4$q = { class: "form-item-drop" };
const _hoisted_5$m = { class: "form-item-section" };
const _hoisted_6$i = /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u9009\u62E9\u7EC4\u4EF6", -1);
const _hoisted_7$d = { class: "form-item-drop" };
const _hoisted_8$9 = { class: "form-item-section" };
const _hoisted_9$7 = /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u590D\u6742\u7EC4\u4EF6", -1);
const _hoisted_10$6 = { class: "form-item-drop" };
const _hoisted_11$4 = { class: "form-item-section" };
const _hoisted_12$4 = /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u5E03\u5C40\u7EC4\u4EF6", -1);
const _hoisted_13$3 = { class: "form-item-drop" };
function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createElementBlock("div", _hoisted_1$Q, [
    createElementVNode("div", _hoisted_2$F, [
      _hoisted_3$A,
      createVNode(_component_draggable, {
        class: "form-item-group",
        modelValue: $setup.inputs,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputs = $event),
        "item-key": "name",
        group: { name: "form-draggable", pull: "clone", put: false },
        "ghost-class": "ghost",
        sort: false,
        clone: $setup.clone
      }, {
        item: withCtx(({ element }) => [
          createElementVNode("div", _hoisted_4$q, toDisplayString(element.name), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "clone"])
    ]),
    createElementVNode("div", _hoisted_5$m, [
      _hoisted_6$i,
      createVNode(_component_draggable, {
        class: "form-item-group",
        modelValue: $setup.pickers,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.pickers = $event),
        "item-key": "name",
        group: { name: "form-draggable", pull: "clone", put: false },
        "ghost-class": "ghost",
        sort: false,
        clone: $setup.clone
      }, {
        item: withCtx(({ element }) => [
          createElementVNode("div", _hoisted_7$d, toDisplayString(element.name), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "clone"])
    ]),
    createElementVNode("div", _hoisted_8$9, [
      _hoisted_9$7,
      createVNode(_component_draggable, {
        class: "form-item-group",
        modelValue: $setup.complexs,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.complexs = $event),
        "item-key": "name",
        group: { name: "form-draggable", pull: "clone", put: false },
        "ghost-class": "ghost",
        sort: false,
        clone: $setup.clone
      }, {
        item: withCtx(({ element }) => [
          createElementVNode("div", _hoisted_10$6, toDisplayString(element.name), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "clone"])
    ]),
    createElementVNode("div", _hoisted_11$4, [
      _hoisted_12$4,
      createVNode(_component_draggable, {
        class: "form-item-group",
        modelValue: $setup.layouts,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.layouts = $event),
        "item-key": "name",
        group: { name: "form-draggable", pull: "clone", put: false },
        "ghost-class": "ghost",
        sort: false,
        clone: $setup.clone
      }, {
        item: withCtx(({ element }) => [
          createElementVNode("div", _hoisted_13$3, toDisplayString(element.name), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "clone"])
    ])
  ]);
}
var __unplugin_components_0$6 = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["render", _sfc_render$1L]]);
let $ELEMENT = {};
const getConfig = (key2) => {
  return $ELEMENT[key2];
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
var fromPairs_1 = fromPairs;
var fromPairs$1 = fromPairs_1;
class ElementPlusError extends Error {
  constructor(m2) {
    super(m2);
    this.name = "ElementPlusError";
  }
}
function throwError(scope, m2) {
  throw new ElementPlusError(`[${scope}] ${m2}`);
}
function debugWarn(scope, message2) {
}
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
var useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys = [] } = params;
  const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
  const instance = getCurrentInstance();
  if (!instance) {
    return computed(() => ({}));
  }
  return computed(() => {
    var _a;
    return fromPairs$1(Object.entries((_a = instance.proxy) === null || _a === void 0 ? void 0 : _a.$attrs).filter(([key2]) => !allExcludeKeys.includes(key2) && !(excludeListeners && LISTENER_PREFIX.test(key2))));
  });
};
var isServer = typeof window === "undefined";
const NOOP = () => {
};
const extend = Object.assign;
const hasOwnProperty$c = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty$c.call(val, key2);
const isArray$6 = Array.isArray;
const isFunction$3 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isObject$a = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$a(val) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const cacheStringFunction = (fn2) => {
  const cache = Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array4, key2) {
  var length = array4.length;
  while (length--) {
    if (eq$2(array4[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$7 = root$8.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$9(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$9;
var baseGetTag$4 = _baseGetTag, isObject$8 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$8(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$7 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$7(object4, key2) {
  var value = getValue$1(object4, key2);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$6 = _root;
var Map$4 = getNative$6(root$6, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet$1(key2) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key2) ? data[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas$1(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$8.call(data, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key2) {
  var data = map.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result = getMapData$3(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$2(cache, key2) {
  return cache.has(key2);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache$1() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$2 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$4 = _Symbol, Uint8Array$1 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag$1(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$4:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$3:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$3:
    case numberTag$3:
      return eq$1(+object4, +other);
    case errorTag$2:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$3:
    case stringTag$3:
      return object4 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray$2);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other);
      var result = equalArrays$1(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object4) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array4, values) {
  var index2 = -1, length = values.length, offset2 = array4.length;
  while (++index2 < length) {
    array4[offset2 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$3;
var isArray$5 = Array.isArray;
var isArray_1 = isArray$5;
var arrayPush$2 = _arrayPush, isArray$4 = isArray_1;
function baseGetAllKeys$2(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$4(object4) ? result : arrayPush$2(result, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$3;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$8(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$3 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$7(value) && baseGetTag$3(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$6(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$2 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$5 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$5(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$3 = isArray_1, isBuffer$2 = isBuffer$3.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$3(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$6.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$6 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype$2(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$5.call(object4, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$3(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$3;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$2 = isArrayLike_1;
function keys$3(object4) {
  return isArrayLike$2(object4) ? arrayLikeKeys$1(object4) : baseKeys(object4);
}
var keys_1 = keys$3;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object4) {
  return baseGetAllKeys$1(object4, keys$2, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object4), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$4.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack) : customizer(objValue, othValue, key2, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$4 = _root;
var DataView$1 = getNative$4(root$4, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$3 = getNative$2(root$2, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag$1;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$2 && getTag$4(new Set$2()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag$1(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$2 = isArray_1, isBuffer$1 = isBuffer$3.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object4), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object4), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object4)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
function toObject(arr) {
  const res = {};
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
const getValueByPath = (obj, paths = "") => {
  let ret = obj;
  paths.split(".").map((path) => {
    ret = ret === null || ret === void 0 ? void 0 : ret[path];
  });
  return ret;
};
function getPropByPath(obj, path, strict) {
  let tempObj = obj;
  let key2, value;
  if (obj && hasOwn(obj, path)) {
    key2 = path;
    value = tempObj === null || tempObj === void 0 ? void 0 : tempObj[path];
  } else {
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    const keyArr = path.split(".");
    let i = 0;
    for (i; i < keyArr.length - 1; i++) {
      if (!tempObj && !strict)
        break;
      const key3 = keyArr[i];
      if (key3 in tempObj) {
        tempObj = tempObj[key3];
      } else {
        if (strict) {
          throw new Error("please transfer a valid prop path to form item!");
        }
        break;
      }
    }
    key2 = keyArr[i];
    value = tempObj === null || tempObj === void 0 ? void 0 : tempObj[keyArr[i]];
  }
  return {
    o: tempObj,
    k: key2,
    v: value
  };
}
const generateId = () => Math.floor(Math.random() * 1e4);
const escapeRegexpString = (value = "") => String(value).replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
const coerceTruthyValueToArray = (arr) => {
  if (!arr && arr !== 0) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
};
const isBool = (val) => typeof val === "boolean";
const isNumber = (val) => typeof val === "number";
const isHTMLElement$1 = (val) => toRawType(val).startsWith("HTML");
function isUndefined(val) {
  return val === void 0;
}
function useGlobalConfig() {
  const vm = getCurrentInstance();
  if ("$ELEMENT" in vm.proxy) {
    return vm.proxy.$ELEMENT;
  }
  return {};
}
function isEmpty(val) {
  if (!val && val !== 0 || isArray$6(val) && !val.length || isObject$a(val) && !Object.keys(val).length)
    return true;
  return false;
}
function arrayFlat(arr) {
  return arr.reduce((acm, item) => {
    const val = Array.isArray(item) ? arrayFlat(item) : item;
    return acm.concat(val);
  }, []);
}
function deduplicate(arr) {
  return Array.from(new Set(arr));
}
function $(ref2) {
  return ref2.value;
}
function addUnit(value) {
  if (isString$1(value)) {
    return value;
  } else if (isNumber(value)) {
    return `${value}px`;
  }
  return "";
}
const trim = function(s2) {
  return (s2 || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
};
const on = function(element, event, handler, useCapture = false) {
  if (element && event && handler) {
    element === null || element === void 0 ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};
const off = function(element, event, handler, useCapture = false) {
  if (element && event && handler) {
    element === null || element === void 0 ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};
const once = function(el, event, fn2) {
  const listener = function(...args) {
    if (fn2) {
      fn2.apply(this, args);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};
function hasClass(el, cls) {
  if (!el || !cls)
    return false;
  if (cls.indexOf(" ") !== -1)
    throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return ` ${el.className} `.indexOf(` ${cls} `) > -1;
  }
}
function addClass(el, cls) {
  if (!el)
    return;
  let curClass = el.className;
  const classes = (cls || "").split(" ");
  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ` ${clsName}`;
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}
function removeClass(el, cls) {
  if (!el || !cls)
    return;
  const classes = cls.split(" ");
  let curClass = ` ${el.className} `;
  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(` ${clsName} `, " ");
    }
  }
  if (!el.classList) {
    el.className = trim(curClass);
  }
}
const getStyle = function(element, styleName) {
  if (isServer)
    return;
  if (!element || !styleName)
    return null;
  styleName = camelize(styleName);
  if (styleName === "float") {
    styleName = "cssFloat";
  }
  try {
    const style = element.style[styleName];
    if (style)
      return style;
    const computed2 = document.defaultView.getComputedStyle(element, "");
    return computed2 ? computed2[styleName] : "";
  } catch (e) {
    return element.style[styleName];
  }
};
const stop = (e) => e.stopPropagation();
let scrollBarWidth;
function scrollbarWidth() {
  var _a;
  if (isServer)
    return 0;
  if (scrollBarWidth !== void 0)
    return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = "el-scrollbar__wrap";
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  (_a = outer.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
}
var useLockScreen = (trigger) => {
  if (!isRef(trigger)) {
    throwError("[useLockScreen]", "You need to pass a ref param to this function");
  }
  let scrollBarWidth2 = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;
  onUnmounted(() => {
    cleanup();
  });
  const cleanup = () => {
    removeClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };
  watch(trigger, (val) => {
    if (val) {
      withoutHiddenClass = !hasClass(document.body, "el-popup-parent--hidden");
      if (withoutHiddenClass) {
        bodyPaddingRight = document.body.style.paddingRight;
        computedBodyPaddingRight = parseInt(getStyle(document.body, "paddingRight"), 10);
      }
      scrollBarWidth2 = scrollbarWidth();
      const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
      const bodyOverflowY = getStyle(document.body, "overflowY");
      if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
        document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth2}px`;
      }
      addClass(document.body, "el-popup-parent--hidden");
    } else {
      cleanup();
    }
  });
};
var useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  watch(() => toggle.value, (val) => {
    var _a, _b;
    if (val) {
      previousActive = document.activeElement;
      if (isRef(initialFocus)) {
        (_b = (_a = initialFocus.value).focus) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    } else {
      {
        previousActive.focus();
      }
    }
  });
};
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace"
};
const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
const isVisible = (element) => {
  const computed2 = getComputedStyle(element);
  return computed2.position === "fixed" ? false : element.offsetParent !== null;
};
const obtainAllFocusableElements = (element) => {
  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
};
const isFocusable = (element) => {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A": {
      return !!element.href && element.rel !== "ignore";
    }
    case "INPUT": {
      return !(element.type === "hidden" || element.type === "file");
    }
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA": {
      return true;
    }
    default: {
      return false;
    }
  }
};
const modalStack = [];
const closeModal = (e) => {
  if (modalStack.length === 0)
    return;
  if (e.code === EVENT_CODE.esc) {
    e.stopPropagation();
    const topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};
var useModal = (instance, visibleRef) => {
  watch(() => visibleRef.value, (val) => {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.findIndex((modal) => modal === instance), 1);
    }
  });
};
if (!isServer) {
  on(document, "keydown", closeModal);
}
var useFocus = (el) => {
  return {
    focus: () => {
      var _a, _b;
      (_b = (_a = el.value) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  };
};
var usePreventGlobal = (indicator, evt, cb) => {
  const prevent = (e) => {
    if (cb(e)) {
      e.stopImmediatePropagation();
    }
  };
  watch(() => indicator.value, (val) => {
    if (val) {
      on(document, evt, prevent, true);
    } else {
      off(document, evt, prevent, true);
    }
  }, { immediate: true });
};
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";
const VALIDATE_STATE_MAP = {
  validating: "el-icon-loading",
  success: "el-icon-circle-check",
  error: "el-icon-circle-close"
};
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var round$1 = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = rect.width / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = rect.height / offsetHeight || 1;
    }
  }
  return {
    width: round$1(rect.width / scaleX),
    height: round$1(rect.height / scaleY),
    top: round$1(rect.top / scaleY),
    right: round$1(rect.right / scaleX),
    bottom: round$1(rect.bottom / scaleY),
    left: round$1(rect.left / scaleX),
    x: round$1(rect.left / scaleX),
    y: round$1(rect.top / scaleY)
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
var max$1 = Math.max;
var min$1 = Math.min;
var round = Math.round;
function within(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x2 * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      x2 -= offsetParent[widthProp] - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options2 = _ref4.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x2 = 0;
  var y = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2 + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding2 = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding2 = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
    var max2 = popperOffsets2[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    if (checkMainAxis) {
      var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var _preventedOffset = within(tether ? min$1(_min, tetherMin) : _min, _offset, tether ? max$1(_max, tetherMax) : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = rect.width / element.offsetWidth || 1;
  var scaleY = rect.height / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options3);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const nodeList = new Map();
let startClick;
if (!isServer) {
  on(document, "mousedown", (e) => startClick = e);
  on(document, "mouseup", (e) => {
    for (const handlers of nodeList.values()) {
      for (const { documentHandler } of handlers) {
        documentHandler(e, startClick);
      }
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (binding.arg instanceof HTMLElement) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown === null || mousedown === void 0 ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item === null || item === void 0 ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    const handlers = nodeList.get(el);
    const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};
var ClickOutside$1 = ClickOutside;
var RepeatClick = {
  beforeMount(el, binding) {
    let interval = null;
    let startTime;
    const handler = () => binding.value && binding.value();
    const clear = () => {
      if (Date.now() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };
    on(el, "mousedown", (e) => {
      if (e.button !== 0)
        return;
      startTime = Date.now();
      once(document, "mouseup", clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};
const FOCUSABLE_CHILDREN = "_trap-focus-children";
const FOCUS_STACK = [];
const FOCUS_HANDLER = (e) => {
  if (FOCUS_STACK.length === 0)
    return;
  const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
  if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
    if (focusableElement.length === 1) {
      e.preventDefault();
      if (document.activeElement !== focusableElement[0]) {
        focusableElement[0].focus();
      }
      return;
    }
    const goingBackward = e.shiftKey;
    const isFirst = e.target === focusableElement[0];
    const isLast = e.target === focusableElement[focusableElement.length - 1];
    if (isFirst && goingBackward) {
      e.preventDefault();
      focusableElement[focusableElement.length - 1].focus();
    }
    if (isLast && !goingBackward) {
      e.preventDefault();
      focusableElement[0].focus();
    }
  }
};
const TrapFocus = {
  beforeMount(el) {
    el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    FOCUS_STACK.push(el);
    if (FOCUS_STACK.length <= 1) {
      on(document, "keydown", FOCUS_HANDLER);
    }
  },
  updated(el) {
    nextTick(() => {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    });
  },
  unmounted() {
    FOCUS_STACK.shift();
    if (FOCUS_STACK.length === 0) {
      off(document, "keydown", FOCUS_HANDLER);
    }
  }
};
var TrapFocus$1 = TrapFocus;
var h = false, o, s, f, u, d, D, l, p, m, w, N, E, x, A, M;
function a() {
  if (!h) {
    h = true;
    var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (E = /\b(iPhone|iP[ao]d)/.exec(e), x = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), A = /FBAN\/\w+;/i.exec(e), M = /Mobile/i.exec(e), N = !!/Win64/.exec(e), n) {
      o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e);
      D = r ? parseFloat(r[1]) + 4 : o, s = n[2] ? parseFloat(n[2]) : NaN, f = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
    } else {
      o = s = f = d = u = NaN;
    }
    if (i) {
      if (i[1]) {
        var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        l = t ? parseFloat(t[1].replace("_", ".")) : true;
      } else {
        l = false;
      }
      p = !!i[2], m = !!i[3];
    } else {
      l = p = m = false;
    }
  }
}
var _ = { ie: function() {
  return a() || o;
}, ieCompatibilityMode: function() {
  return a() || D > o;
}, ie64: function() {
  return _.ie() && N;
}, firefox: function() {
  return a() || s;
}, opera: function() {
  return a() || f;
}, webkit: function() {
  return a() || u;
}, safari: function() {
  return _.webkit();
}, chrome: function() {
  return a() || d;
}, windows: function() {
  return a() || p;
}, osx: function() {
  return a() || l;
}, linux: function() {
  return a() || m;
}, iphone: function() {
  return a() || E;
}, mobile: function() {
  return a() || E || x || w || M;
}, nativeApp: function() {
  return a() || A;
}, android: function() {
  return a() || w;
}, ipad: function() {
  return a() || x;
} }, F = _;
var c = !!(typeof window != "undefined" && window.document && window.document.createElement), I = { canUseDOM: c, canUseWorkers: typeof Worker != "undefined", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, v = I;
var X;
v.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
function S(e, n) {
  if (!v.canUseDOM || n && !("addEventListener" in document)) {
    return false;
  }
  var i = "on" + e, r = i in document;
  if (!r) {
    var t = document.createElement("div");
    t.setAttribute(i, "return;"), r = typeof t[i] == "function";
  }
  return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var b = S;
var O = 10, P = 40, T = 800;
function U(e) {
  var n = 0, i = 0, r = 0, t = 0;
  return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= P, t *= P) : (r *= T, t *= T)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
}
U.getEventType = function() {
  return F.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
};
var W = U;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const isFirefox = typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const mousewheel = function(element, callback) {
  if (element && element.addEventListener) {
    const fn2 = function(event) {
      const normalized = W(event);
      callback && callback.apply(this, [event, normalized]);
    };
    if (isFirefox) {
      element.addEventListener("DOMMouseScroll", fn2);
    } else {
      element.onmousewheel = fn2;
    }
  }
};
const Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }
};
var Mousewheel$1 = Mousewheel;
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key2, value]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props2) {
  for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
    var key2 = _a[_i];
    Object.defineProperty(target, key2, {
      value: props2[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size2, position) {
    var value = styles["border-" + position + "-width"];
    return size2 + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width2 = toFloat(styles.width), height2 = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width2 + horizPad) !== clientWidth) {
      width2 -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height2 + vertPad) !== clientHeight) {
      height2 -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width2 + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height2 + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width2 -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height2 -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width2, height2);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y = _a.y, width2 = _a.width, height2 = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y,
    width: width2,
    height: height2,
    top: y,
    right: x2 + width2,
    bottom: height2 + y,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y, width2, height2) {
  return { x: x2, y, width: width2, height: height2 };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? new WeakMap() : new MapShim();
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver.prototype[method4] = function() {
    var _a;
    return (_a = observers.get(this))[method4].apply(_a, arguments);
  };
});
var index$4 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
const resizeHandler = function(entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach((fn2) => {
        fn2();
      });
    }
  }
};
const addResizeListener = function(element, fn2) {
  if (isServer || !element)
    return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new index$4(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn2);
};
const removeResizeListener = function(element, fn2) {
  var _a;
  if (!element || !element.__resizeListeners__)
    return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn2), 1);
  if (!element.__resizeListeners__.length) {
    (_a = element.__ro__) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
};
const Resize = {
  beforeMount(el, binding) {
    el._handleResize = () => {
      var _a;
      el && ((_a = binding.value) === null || _a === void 0 ? void 0 : _a.call(binding, el));
    };
    addResizeListener(el, el._handleResize);
  },
  beforeUnmount(el) {
    removeResizeListener(el, el._handleResize);
  }
};
var Resize$1 = Resize;
const TEMPLATE = "template";
var PatchFlags;
(function(PatchFlags2) {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
})(PatchFlags || (PatchFlags = {}));
const isFragment = (node) => node.type === Fragment;
const isComment = (node) => node.type === Comment;
const isTemplate = (node) => node.type === TEMPLATE;
function getChildren(node, depth) {
  if (isComment(node))
    return;
  if (isFragment(node) || isTemplate(node)) {
    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;
  }
  return node;
}
const getFirstValidNode = (nodes, maxDepth = 3) => {
  if (Array.isArray(nodes)) {
    return getChildren(nodes[0], maxDepth);
  } else {
    return getChildren(nodes, maxDepth);
  }
};
const onTouchMove = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
const onModalClick = () => {
  PopupManager === null || PopupManager === void 0 ? void 0 : PopupManager.doOnModalClick();
};
let hasModal = false;
let zIndex;
const getModal = function() {
  if (isServer)
    return;
  let modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement("div");
    PopupManager.modalDom = modalDom;
    on(modalDom, "touchmove", onTouchMove);
    on(modalDom, "click", onModalClick);
  }
  return modalDom;
};
const instances$1 = {};
const PopupManager = {
  modalFade: true,
  modalDom: void 0,
  zIndex,
  getInstance(id2) {
    return instances$1[id2];
  },
  register(id2, instance) {
    if (id2 && instance) {
      instances$1[id2] = instance;
    }
  },
  deregister(id2) {
    if (id2) {
      instances$1[id2] = null;
      delete instances$1[id2];
    }
  },
  nextZIndex() {
    return ++PopupManager.zIndex;
  },
  modalStack: [],
  doOnModalClick() {
    const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem)
      return;
    const instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal.value) {
      instance.close();
    }
  },
  openModal(id2, zIndex2, dom, modalClass, modalFade) {
    if (isServer)
      return;
    if (!id2 || zIndex2 === void 0)
      return;
    this.modalFade = modalFade;
    const modalStack2 = this.modalStack;
    for (let i = 0, j = modalStack2.length; i < j; i++) {
      const item = modalStack2[i];
      if (item.id === id2) {
        return;
      }
    }
    const modalDom = getModal();
    addClass(modalDom, "v-modal");
    if (this.modalFade && !hasModal) {
      addClass(modalDom, "v-modal-enter");
    }
    if (modalClass) {
      const classArr = modalClass.trim().split(/\s+/);
      classArr.forEach((item) => addClass(modalDom, item));
    }
    setTimeout(() => {
      removeClass(modalDom, "v-modal-enter");
    }, 200);
    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }
    if (zIndex2) {
      modalDom.style.zIndex = String(zIndex2);
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = "";
    this.modalStack.push({ id: id2, zIndex: zIndex2, modalClass });
  },
  closeModal(id2) {
    const modalStack2 = this.modalStack;
    const modalDom = getModal();
    if (modalStack2.length > 0) {
      const topItem = modalStack2[modalStack2.length - 1];
      if (topItem.id === id2) {
        if (topItem.modalClass) {
          const classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach((item) => removeClass(modalDom, item));
        }
        modalStack2.pop();
        if (modalStack2.length > 0) {
          modalDom.style.zIndex = modalStack2[modalStack2.length - 1].zIndex;
        }
      } else {
        for (let i = modalStack2.length - 1; i >= 0; i--) {
          if (modalStack2[i].id === id2) {
            modalStack2.splice(i, 1);
            break;
          }
        }
      }
    }
    if (modalStack2.length === 0) {
      if (this.modalFade) {
        addClass(modalDom, "v-modal-leave");
      }
      setTimeout(() => {
        if (modalStack2.length === 0) {
          if (modalDom.parentNode)
            modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = "none";
          PopupManager.modalDom = void 0;
        }
        removeClass(modalDom, "v-modal-leave");
      }, 200);
    }
  }
};
Object.defineProperty(PopupManager, "zIndex", {
  configurable: true,
  get() {
    if (zIndex === void 0) {
      zIndex = getConfig("zIndex") || 2e3;
    }
    return zIndex;
  },
  set(value) {
    zIndex = value;
  }
});
const getTopPopup = function() {
  if (isServer)
    return;
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup)
      return;
    const instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
};
if (!isServer) {
  on(window, "keydown", function(event) {
    if (event.code === EVENT_CODE.esc) {
      const topPopup = getTopPopup();
      if (topPopup && topPopup.closeOnPressEscape.value) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction("cancel") : topPopup.close();
      }
    }
  });
}
var PopupManager$1 = PopupManager;
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const LocaleInjectionKey = "ElLocaleInjection";
function translate(path, option2, current) {
  const paths = path.split(".");
  let value;
  for (let i = 0, j = paths.length; i < j; i++) {
    const property = paths[i];
    value = current[property];
    if (i === j - 1)
      return template(value, option2);
    if (!value)
      return "";
    current = value;
  }
}
function template(str, option2) {
  if (!str || !option2)
    return str;
  return str.replace(/\{(\w+)\}/g, (_2, key2) => {
    return option2[key2];
  });
}
const useLocaleInject = () => {
  return inject(LocaleInjectionKey, {
    lang: ref(English.name),
    locale: ref(English),
    t: (...args) => {
      const [path, option2] = args;
      return translate(path, option2, English);
    }
  });
};
const elFormKey = Symbol("elForm");
const elFormItemKey = Symbol("elFormItem");
const elButtonGroupKey = Symbol();
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$2(object4, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key2] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseGetTag = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
memoizeCapped(function(string3) {
  var result = [];
  if (string3.charCodeAt(0) === 46) {
    result.push("");
  }
  string3.replace(rePropName, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result;
});
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
symbolProto$1 ? symbolProto$1.toString : void 0;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
const wrapperKey = Symbol();
function buildProp(option2 = {}) {
  var _a;
  const { values, required: required4, default: defaultValue2, type: type4, validator } = option2;
  const _validator = values || validator ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = [...values, defaultValue2];
      valid || (valid = allowedValues.includes(val));
    }
    if (validator)
      valid || (valid = validator(val));
    if (!valid && allowedValues.length > 0) {
      debugWarn(`Vue warn`, `Invalid prop: Expected one of (${allowedValues.join(", ")}), got value ${val}`);
    }
    return valid;
  } : void 0;
  return {
    type: ((_a = type4) === null || _a === void 0 ? void 0 : _a[wrapperKey]) || type4,
    required: !!required4,
    default: defaultValue2,
    validator: _validator
  };
}
const definePropType = (val) => ({ [wrapperKey]: val });
const sizes = ["", "large", "medium", "small", "mini"];
const useFormItemProps = {
  size: buildProp({
    type: String,
    values: sizes,
    default: ""
  }),
  disabled: Boolean
};
const useFormItem = ({ size: size2, disabled: disabled2 }) => {
  const vm = getCurrentInstance();
  const $ELEMENT2 = useGlobalConfig();
  const props2 = vm.proxy.$props;
  const form2 = inject(elFormKey, void 0);
  const formItem = inject(elFormItemKey, void 0);
  return {
    size: computed(() => {
      return props2.size || unref(size2) || (formItem === null || formItem === void 0 ? void 0 : formItem.size) || (form2 === null || form2 === void 0 ? void 0 : form2.size) || $ELEMENT2.size || "";
    }),
    disabled: computed(() => {
      return props2.disabled === true || unref(disabled2) || (form2 === null || form2 === void 0 ? void 0 : form2.disabled) || false;
    })
  };
};
const useSameTarget = (handleClick) => {
  if (!handleClick) {
    return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
  }
  let mousedownTarget = false;
  let mouseupTarget = false;
  const onClick = (e) => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e);
    }
    mousedownTarget = mouseupTarget = false;
  };
  const onMousedown = (e) => {
    mousedownTarget = e.target === e.currentTarget;
  };
  const onMouseup = (e) => {
    mouseupTarget = e.target === e.currentTarget;
  };
  return { onClick, onMousedown, onMouseup };
};
const withInstall = (main2, extra) => {
  main2.install = (app) => {
    for (const comp of [main2, ...Object.values(extra !== null && extra !== void 0 ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key2, comp] of Object.entries(extra)) {
      main2[key2] = comp;
    }
  }
  return main2;
};
const withInstallFunction = (fn2, name) => {
  fn2.install = (app) => {
    app.config.globalProperties[name] = fn2;
  };
  return fn2;
};
const withNoopInstall = (component) => {
  component.install = NOOP;
  return component;
};
const isClient = typeof window !== "undefined";
const isString = (val) => typeof val === "string";
const noop$2 = () => {
};
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
function useTimeoutFn(cb, interval, options2 = {}) {
  const { immediate = true } = options2;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear();
  }
  function start2(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start: start2,
    stop: stop2
  };
}
const defaultWindow = isClient ? window : void 0;
isClient ? window.document : void 0;
isClient ? window.navigator : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options2;
  if (isString(args[0])) {
    [event, listener, options2] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options2] = args;
  }
  if (!target)
    return noop$2;
  let cleanup = noop$2;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options2);
    cleanup = () => {
      el.removeEventListener(event, listener, options2);
      cleanup = noop$2;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$6 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$5 = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$5(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax$1(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
function isKorean(text) {
  const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}
const isValidWidthUnit = (val) => {
  if (isNumber(val)) {
    return true;
  } else {
    return ["px", "rem", "em", "vw", "%", "vmin", "vmax"].some((unit) => val.endsWith(unit)) || val.startsWith("calc");
  }
};
const isValidComponentSize = (val) => ["", "large", "medium", "small", "mini"].includes(val);
const isValidDatePickType = (val) => [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
].includes(val);
let hiddenTextarea;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows = null) {
  var _a;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height2 = hiddenTextarea.scrollHeight;
  const result = {};
  if (boxSizing === "border-box") {
    height2 = height2 + borderSize;
  } else if (boxSizing === "content-box") {
    height2 = height2 - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height2 = Math.max(minHeight, height2);
    result.minHeight = `${minHeight}px`;
  }
  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height2 = Math.min(maxHeight, height2);
  }
  result.height = `${height2}px`;
  (_a = hiddenTextarea.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
}
var __defProp$k = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key2, value) => key2 in obj ? __defProp$k(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$k = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$k.call(b2, prop))
      __defNormalProp$k(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b2)) {
      if (__propIsEnum$k.call(b2, prop))
        __defNormalProp$k(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$f = (a2, b2) => __defProps$f(a2, __getOwnPropDescs$f(b2));
const PENDANT_MAP = {
  suffix: "append",
  prefix: "prepend"
};
var script$t = defineComponent({
  name: "ElInput",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    type: {
      type: String,
      default: "text"
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    resize: {
      type: String,
      validator: (val) => ["none", "both", "horizontal", "vertical"].includes(val)
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    placeholder: {
      type: String
    },
    form: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    suffixIcon: {
      type: String,
      default: ""
    },
    prefixIcon: {
      type: String,
      default: ""
    },
    label: {
      type: String
    },
    tabindex: {
      type: [Number, String]
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    inputStyle: {
      type: Object,
      default: () => ({})
    },
    maxlength: {
      type: [Number, String]
    }
  },
  emits: [
    UPDATE_MODEL_EVENT,
    "input",
    "change",
    "focus",
    "blur",
    "clear",
    "mouseleave",
    "mouseenter",
    "keydown",
    "compositionstart",
    "compositionupdate",
    "compositionend"
  ],
  setup(props2, ctx) {
    const instance = getCurrentInstance();
    const attrs = useAttrs();
    const $ELEMENT2 = useGlobalConfig();
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const input = ref(null);
    const textarea = ref(null);
    const focused = ref(false);
    const hovering = ref(false);
    const isComposing = ref(false);
    const passwordVisible = ref(false);
    const _textareaCalcStyle = shallowRef(props2.inputStyle);
    const inputOrTextarea = computed(() => input.value || textarea.value);
    const inputSize = computed(() => props2.size || elFormItem2.size || $ELEMENT2.size);
    const needStatusIcon = computed(() => elForm2.statusIcon);
    const validateState = computed(() => elFormItem2.validateState || "");
    const validateIcon = computed(() => VALIDATE_STATE_MAP[validateState.value]);
    const computedTextareaStyle = computed(() => __spreadProps$f(__spreadValues$k(__spreadValues$k({}, props2.inputStyle), _textareaCalcStyle.value), {
      resize: props2.resize
    }));
    const inputDisabled = computed(() => props2.disabled || elForm2.disabled);
    const nativeInputValue = computed(() => props2.modelValue === null || props2.modelValue === void 0 ? "" : String(props2.modelValue));
    const showClear = computed(() => {
      return props2.clearable && !inputDisabled.value && !props2.readonly && nativeInputValue.value && (focused.value || hovering.value);
    });
    const showPwdVisible = computed(() => {
      return props2.showPassword && !inputDisabled.value && !props2.readonly && (!!nativeInputValue.value || focused.value);
    });
    const isWordLimitVisible = computed(() => {
      return props2.showWordLimit && props2.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword;
    });
    const textLength = computed(() => {
      return Array.from(nativeInputValue.value).length;
    });
    const inputExceed = computed(() => {
      return isWordLimitVisible.value && textLength.value > Number(props2.maxlength);
    });
    const resizeTextarea = () => {
      const { type: type4, autosize } = props2;
      if (isServer || type4 !== "textarea")
        return;
      if (autosize) {
        const minRows = isObject$a(autosize) ? autosize.minRows : void 0;
        const maxRows = isObject$a(autosize) ? autosize.maxRows : void 0;
        _textareaCalcStyle.value = __spreadValues$k({}, calcTextareaHeight(textarea.value, minRows, maxRows));
      } else {
        _textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input2 = inputOrTextarea.value;
      if (!input2 || input2.value === nativeInputValue.value)
        return;
      input2.value = nativeInputValue.value;
    };
    const calcIconOffset = (place) => {
      const { el } = instance.vnode;
      const elList = Array.from(el.querySelectorAll(`.el-input__${place}`));
      const target = elList.find((item) => item.parentNode === el);
      if (!target)
        return;
      const pendant = PENDANT_MAP[place];
      if (ctx.slots[pendant]) {
        target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };
    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };
    const handleInput = (event) => {
      let { value } = event.target;
      if (isComposing.value)
        return;
      if (value === nativeInputValue.value)
        return;
      if (props2.maxlength) {
        const sliceIndex = inputExceed.value ? textLength.value : props2.maxlength;
        value = Array.from(value).slice(0, Number(sliceIndex)).join("");
      }
      ctx.emit(UPDATE_MODEL_EVENT, value);
      ctx.emit("input", value);
      nextTick(setNativeInputValue);
    };
    const handleChange = (event) => {
      ctx.emit("change", event.target.value);
    };
    const focus = () => {
      nextTick(() => {
        inputOrTextarea.value.focus();
      });
    };
    const blur = () => {
      inputOrTextarea.value.blur();
    };
    const handleFocus = (event) => {
      focused.value = true;
      ctx.emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a;
      focused.value = false;
      ctx.emit("blur", event);
      if (props2.validateEvent) {
        (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "blur");
      }
    };
    const select = () => {
      inputOrTextarea.value.select();
    };
    const handleCompositionStart = (event) => {
      ctx.emit("compositionstart", event);
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event) => {
      var _a;
      ctx.emit("compositionupdate", event);
      const text = (_a = event.target) == null ? void 0 : _a.value;
      const lastCharacter = text[text.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event) => {
      ctx.emit("compositionend", event);
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };
    const clear = () => {
      ctx.emit(UPDATE_MODEL_EVENT, "");
      ctx.emit("change", "");
      ctx.emit("clear");
      ctx.emit("input", "");
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };
    const getSuffixVisible = () => {
      return ctx.slots.suffix || props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || validateState.value && needStatusIcon.value;
    };
    watch(() => props2.modelValue, () => {
      var _a;
      nextTick(resizeTextarea);
      if (props2.validateEvent) {
        (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
      }
    });
    watch(nativeInputValue, () => {
      setNativeInputValue();
    });
    watch(() => props2.type, () => {
      nextTick(() => {
        setNativeInputValue();
        resizeTextarea();
        updateIconOffset();
      });
    });
    onMounted(() => {
      setNativeInputValue();
      updateIconOffset();
      nextTick(resizeTextarea);
    });
    onUpdated(() => {
      nextTick(updateIconOffset);
    });
    const onMouseLeave = (e) => {
      hovering.value = false;
      ctx.emit("mouseleave", e);
    };
    const onMouseEnter = (e) => {
      hovering.value = true;
      ctx.emit("mouseenter", e);
    };
    const handleKeydown = (e) => {
      ctx.emit("keydown", e);
    };
    return {
      input,
      textarea,
      attrs,
      inputSize,
      validateState,
      validateIcon,
      computedTextareaStyle,
      resizeTextarea,
      inputDisabled,
      showClear,
      showPwdVisible,
      isWordLimitVisible,
      textLength,
      hovering,
      inputExceed,
      passwordVisible,
      inputOrTextarea,
      handleInput,
      handleChange,
      handleFocus,
      handleBlur,
      handleCompositionStart,
      handleCompositionUpdate,
      handleCompositionEnd,
      handlePasswordVisible,
      clear,
      select,
      focus,
      blur,
      getSuffixVisible,
      onMouseLeave,
      onMouseEnter,
      handleKeydown
    };
  }
});
const _hoisted_1$P = {
  key: 0,
  class: "el-input-group__prepend"
};
const _hoisted_2$E = ["type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_3$z = {
  key: 2,
  class: "el-input__prefix"
};
const _hoisted_4$p = {
  key: 3,
  class: "el-input__suffix"
};
const _hoisted_5$l = { class: "el-input__suffix-inner" };
const _hoisted_6$h = {
  key: 3,
  class: "el-input__count"
};
const _hoisted_7$c = { class: "el-input__count-inner" };
const _hoisted_8$8 = {
  key: 4,
  class: "el-input-group__append"
};
const _hoisted_9$6 = ["tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const _hoisted_10$5 = {
  key: 2,
  class: "el-input__count"
};
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      _ctx.type === "textarea" ? "el-textarea" : "el-input",
      _ctx.inputSize ? "el-input--" + _ctx.inputSize : "",
      {
        "is-disabled": _ctx.inputDisabled,
        "is-exceed": _ctx.inputExceed,
        "el-input-group": _ctx.$slots.prepend || _ctx.$slots.append,
        "el-input-group--append": _ctx.$slots.append,
        "el-input-group--prepend": _ctx.$slots.prepend,
        "el-input--prefix": _ctx.$slots.prefix || _ctx.prefixIcon,
        "el-input--suffix": _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
        "el-input--suffix--password-clear": _ctx.clearable && _ctx.showPassword
      },
      _ctx.$attrs.class
    ]),
    style: normalizeStyle(_ctx.$attrs.style),
    onMouseenter: _cache[19] || (_cache[19] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[20] || (_cache[20] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createCommentVNode(" \u524D\u7F6E\u5143\u7D20 "),
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", _hoisted_1$P, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("v-if", true),
      _ctx.type !== "textarea" ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "el-input__inner"
      }, _ctx.attrs, {
        type: _ctx.showPassword ? _ctx.passwordVisible ? "text" : "password" : _ctx.type,
        disabled: _ctx.inputDisabled,
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        tabindex: _ctx.tabindex,
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        style: _ctx.inputStyle,
        onCompositionstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
        onCompositionupdate: _cache[1] || (_cache[1] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
        onCompositionend: _cache[2] || (_cache[2] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
        onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
        onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
        onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onKeydown: _cache[7] || (_cache[7] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), null, 16, _hoisted_2$E)) : createCommentVNode("v-if", true),
      createCommentVNode(" \u524D\u7F6E\u5185\u5BB9 "),
      _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", _hoisted_3$z, [
        renderSlot(_ctx.$slots, "prefix"),
        _ctx.prefixIcon ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-input__icon", _ctx.prefixIcon])
        }, null, 2)) : createCommentVNode("v-if", true)
      ])) : createCommentVNode("v-if", true),
      createCommentVNode(" \u540E\u7F6E\u5185\u5BB9 "),
      _ctx.getSuffixVisible() ? (openBlock(), createElementBlock("span", _hoisted_4$p, [
        createElementVNode("span", _hoisted_5$l, [
          !_ctx.showClear || !_ctx.showPwdVisible || !_ctx.isWordLimitVisible ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            renderSlot(_ctx.$slots, "suffix"),
            _ctx.suffixIcon ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass(["el-input__icon", _ctx.suffixIcon])
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 64)) : createCommentVNode("v-if", true),
          _ctx.showClear ? (openBlock(), createElementBlock("i", {
            key: 1,
            class: "el-input__icon el-icon-circle-close el-input__clear",
            onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {
            }, ["prevent"])),
            onClick: _cache[9] || (_cache[9] = (...args) => _ctx.clear && _ctx.clear(...args))
          }, null, 32)) : createCommentVNode("v-if", true),
          _ctx.showPwdVisible ? (openBlock(), createElementBlock("i", {
            key: 2,
            class: "el-input__icon el-icon-view el-input__clear",
            onClick: _cache[10] || (_cache[10] = (...args) => _ctx.handlePasswordVisible && _ctx.handlePasswordVisible(...args))
          })) : createCommentVNode("v-if", true),
          _ctx.isWordLimitVisible ? (openBlock(), createElementBlock("span", _hoisted_6$h, [
            createElementVNode("span", _hoisted_7$c, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 1)
          ])) : createCommentVNode("v-if", true)
        ]),
        _ctx.validateState ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-input__icon", "el-input__validateIcon", _ctx.validateIcon])
        }, null, 2)) : createCommentVNode("v-if", true)
      ])) : createCommentVNode("v-if", true),
      createCommentVNode(" \u540E\u7F6E\u5143\u7D20 "),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", _hoisted_8$8, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("v-if", true)
    ], 64)) : (openBlock(), createElementBlock("textarea", mergeProps({
      key: 1,
      ref: "textarea",
      class: "el-textarea__inner"
    }, _ctx.attrs, {
      tabindex: _ctx.tabindex,
      disabled: _ctx.inputDisabled,
      readonly: _ctx.readonly,
      autocomplete: _ctx.autocomplete,
      style: _ctx.computedTextareaStyle,
      "aria-label": _ctx.label,
      placeholder: _ctx.placeholder,
      onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
      onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
      onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
      onInput: _cache[14] || (_cache[14] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[16] || (_cache[16] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onChange: _cache[17] || (_cache[17] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[18] || (_cache[18] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
    }), "\n    ", 16, _hoisted_9$6)),
    _ctx.isWordLimitVisible && _ctx.type === "textarea" ? (openBlock(), createElementBlock("span", _hoisted_10$5, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 1)) : createCommentVNode("v-if", true)
  ], 38);
}
script$t.render = render$s;
script$t.__file = "packages/components/input/src/index.vue";
script$t.install = (app) => {
  app.component(script$t.name, script$t);
};
const _Input = script$t;
const ElInput = _Input;
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
function renderThumbStyle({ move, size: size2, bar }) {
  const style = {};
  const translate2 = `translate${bar.axis}(${move}%)`;
  style[bar.size] = size2;
  style.transform = translate2;
  style.msTransform = translate2;
  style.webkitTransform = translate2;
  return style;
}
var __pow$1 = Math.pow;
var script$1$f = defineComponent({
  name: "Bar",
  props: {
    vertical: Boolean,
    size: String,
    move: Number,
    ratio: Number,
    always: Boolean
  },
  setup(props2) {
    const instance = ref(null);
    const thumb = ref(null);
    const scrollbar = inject("scrollbar", {});
    const wrap = inject("scrollbar-wrap", {});
    const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
    const barStore = ref({});
    const cursorDown = ref(null);
    const cursorLeave = ref(null);
    const visible = ref(false);
    let onselectstartStore = null;
    const offsetRatio = computed(() => {
      return __pow$1(instance.value[bar.value.offset], 2) / wrap.value[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset];
    });
    const clickThumbHandler = (e) => {
      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button)) {
        return;
      }
      window.getSelection().removeAllRanges();
      startDrag(e);
      barStore.value[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e) => {
      const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };
    const startDrag = (e) => {
      e.stopImmediatePropagation();
      cursorDown.value = true;
      on(document, "mousemove", mouseMoveDocumentHandler);
      on(document, "mouseup", mouseUpDocumentHandler);
      onselectstartStore = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e) => {
      if (cursorDown.value === false)
        return;
      const prevPage = barStore.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown.value = false;
      barStore.value[bar.value.axis] = 0;
      off(document, "mousemove", mouseMoveDocumentHandler);
      off(document, "mouseup", mouseUpDocumentHandler);
      document.onselectstart = onselectstartStore;
      if (cursorLeave.value) {
        visible.value = false;
      }
    };
    const thumbStyle = computed(() => renderThumbStyle({
      size: props2.size,
      move: props2.move,
      bar: bar.value
    }));
    const mouseMoveScrollbarHandler = () => {
      cursorLeave.value = false;
      visible.value = !!props2.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave.value = true;
      visible.value = cursorDown.value;
    };
    onMounted(() => {
      on(scrollbar.value, "mousemove", mouseMoveScrollbarHandler);
      on(scrollbar.value, "mouseleave", mouseLeaveScrollbarHandler);
    });
    onBeforeUnmount(() => {
      off(document, "mouseup", mouseUpDocumentHandler);
      off(scrollbar.value, "mousemove", mouseMoveScrollbarHandler);
      off(scrollbar.value, "mouseleave", mouseLeaveScrollbarHandler);
    });
    return {
      instance,
      thumb,
      bar,
      clickTrackHandler,
      clickThumbHandler,
      thumbStyle,
      visible
    };
  }
});
function render$1$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "el-scrollbar-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "instance",
        class: normalizeClass(["el-scrollbar__bar", "is-" + _ctx.bar.key]),
        onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.clickTrackHandler && _ctx.clickTrackHandler(...args))
      }, [
        createElementVNode("div", {
          ref: "thumb",
          class: "el-scrollbar__thumb",
          style: normalizeStyle(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.clickThumbHandler && _ctx.clickThumbHandler(...args))
        }, null, 36)
      ], 34), [
        [vShow, _ctx.always || _ctx.visible]
      ])
    ]),
    _: 1
  });
}
script$1$f.render = render$1$f;
script$1$f.__file = "packages/components/scrollbar/src/bar.vue";
var __pow = Math.pow;
var script$s = defineComponent({
  name: "ElScrollbar",
  components: { Bar: script$1$f },
  props: {
    height: {
      type: [String, Number],
      default: ""
    },
    maxHeight: {
      type: [String, Number],
      default: ""
    },
    native: {
      type: Boolean,
      default: false
    },
    wrapStyle: {
      type: [String, Array],
      default: ""
    },
    wrapClass: {
      type: [String, Array],
      default: ""
    },
    viewClass: {
      type: [String, Array],
      default: ""
    },
    viewStyle: {
      type: [String, Array],
      default: ""
    },
    noresize: Boolean,
    tag: {
      type: String,
      default: "div"
    },
    always: {
      type: Boolean,
      default: false
    },
    minSize: {
      type: Number,
      default: 20
    }
  },
  emits: ["scroll"],
  setup(props2, { emit: emit2 }) {
    const sizeWidth = ref("0");
    const sizeHeight = ref("0");
    const moveX = ref(0);
    const moveY = ref(0);
    const scrollbar = ref(null);
    const wrap = ref(null);
    const resize = ref(null);
    const ratioY = ref(1);
    const ratioX = ref(1);
    const GAP = 4;
    provide("scrollbar", scrollbar);
    provide("scrollbar-wrap", wrap);
    const handleScroll = () => {
      if (wrap.value) {
        const offsetHeight = wrap.value.offsetHeight - GAP;
        const offsetWidth = wrap.value.offsetWidth - GAP;
        moveY.value = wrap.value.scrollTop * 100 / offsetHeight * ratioY.value;
        moveX.value = wrap.value.scrollLeft * 100 / offsetWidth * ratioX.value;
        emit2("scroll", {
          scrollTop: wrap.value.scrollTop,
          scrollLeft: wrap.value.scrollLeft
        });
      }
    };
    const setScrollTop = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap.value.scrollTop = value;
    };
    const setScrollLeft = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap.value.scrollLeft = value;
    };
    const update = () => {
      if (!wrap.value)
        return;
      const offsetHeight = wrap.value.offsetHeight - GAP;
      const offsetWidth = wrap.value.offsetWidth - GAP;
      const originalHeight = __pow(offsetHeight, 2) / wrap.value.scrollHeight;
      const originalWidth = __pow(offsetWidth, 2) / wrap.value.scrollWidth;
      const height2 = Math.max(originalHeight, props2.minSize);
      const width2 = Math.max(originalWidth, props2.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height2 / (offsetHeight - height2));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width2 / (offsetWidth - width2));
      sizeHeight.value = height2 + GAP < offsetHeight ? `${height2}px` : "";
      sizeWidth.value = width2 + GAP < offsetWidth ? `${width2}px` : "";
    };
    const style = computed(() => {
      let style2 = props2.wrapStyle;
      if (isArray$6(style2)) {
        style2 = toObject(style2);
        style2.height = addUnit(props2.height);
        style2.maxHeight = addUnit(props2.maxHeight);
      } else if (isString$1(style2)) {
        style2 += addUnit(props2.height) ? `height: ${addUnit(props2.height)};` : "";
        style2 += addUnit(props2.maxHeight) ? `max-height: ${addUnit(props2.maxHeight)};` : "";
      }
      return style2;
    });
    onMounted(() => {
      if (!props2.native) {
        nextTick(update);
      }
      if (!props2.noresize) {
        addResizeListener(resize.value, update);
        addEventListener("resize", update);
      }
    });
    onBeforeUnmount(() => {
      if (!props2.noresize) {
        removeResizeListener(resize.value, update);
        removeEventListener("resize", update);
      }
    });
    return {
      moveX,
      moveY,
      ratioX,
      ratioY,
      sizeWidth,
      sizeHeight,
      style,
      scrollbar,
      wrap,
      resize,
      update,
      handleScroll,
      setScrollTop,
      setScrollLeft
    };
  }
});
const _hoisted_1$O = {
  ref: "scrollbar",
  class: "el-scrollbar"
};
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = resolveComponent("bar");
  return openBlock(), createElementBlock("div", _hoisted_1$O, [
    createElementVNode("div", {
      ref: "wrap",
      class: normalizeClass([
        _ctx.wrapClass,
        "el-scrollbar__wrap",
        _ctx.native ? "" : "el-scrollbar__wrap--hidden-default"
      ]),
      style: normalizeStyle(_ctx.style),
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        ref: "resize",
        class: normalizeClass(["el-scrollbar__view", _ctx.viewClass]),
        style: normalizeStyle(_ctx.viewStyle)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]))
    ], 38),
    !_ctx.native ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_bar, {
        move: _ctx.moveX,
        ratio: _ctx.ratioX,
        size: _ctx.sizeWidth,
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      createVNode(_component_bar, {
        move: _ctx.moveY,
        ratio: _ctx.ratioY,
        size: _ctx.sizeHeight,
        vertical: "",
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64)) : createCommentVNode("v-if", true)
  ], 512);
}
script$s.render = render$r;
script$s.__file = "packages/components/scrollbar/src/index.vue";
script$s.install = (app) => {
  app.component(script$s.name, script$s);
};
const _Scrollbar = script$s;
function buildModifier(props2, externalModifiers = []) {
  const { arrow: arrow2, arrowOffset, offset: offset2, gpuAcceleration, fallbackPlacements } = props2;
  const modifiers = [
    {
      name: "offset",
      options: {
        offset: [0, offset2 != null ? offset2 : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
  if (arrow2) {
    modifiers.push({
      name: "arrow",
      options: {
        element: arrow2,
        padding: arrowOffset != null ? arrowOffset : 5
      }
    });
  }
  modifiers.push(...externalModifiers);
  return modifiers;
}
var __defProp$1$4 = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$4 = (obj, key2, value) => key2 in obj ? __defProp$1$4(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1$4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1$4.call(b2, prop))
      __defNormalProp$1$4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1$4)
    for (var prop of __getOwnPropSymbols$1$4(b2)) {
      if (__propIsEnum$1$4.call(b2, prop))
        __defNormalProp$1$4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$e = (a2, b2) => __defProps$e(a2, __getOwnPropDescs$e(b2));
function usePopperOptions(props2, state) {
  return computed(() => {
    var _a;
    return __spreadProps$e(__spreadValues$1$4({
      placement: props2.placement
    }, props2.popperOptions), {
      modifiers: buildModifier({
        arrow: state.arrow.value,
        arrowOffset: props2.arrowOffset,
        offset: props2.offset,
        gpuAcceleration: props2.gpuAcceleration,
        fallbackPlacements: props2.fallbackPlacements
      }, (_a = props2.popperOptions) == null ? void 0 : _a.modifiers)
    });
  });
}
var Effect;
(function(Effect2) {
  Effect2["DARK"] = "dark";
  Effect2["LIGHT"] = "light";
})(Effect || (Effect = {}));
const DEFAULT_FALLBACK_PLACEMENTS = [];
var defaultProps$4 = {
  arrowOffset: {
    type: Number,
    default: 5
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  autoClose: {
    type: Number,
    default: 0
  },
  boundariesPadding: {
    type: Number,
    default: 0
  },
  content: {
    type: String,
    default: ""
  },
  class: {
    type: String,
    default: ""
  },
  style: Object,
  hideAfter: {
    type: Number,
    default: 200
  },
  cutoff: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  effect: {
    type: String,
    default: Effect.DARK
  },
  enterable: {
    type: Boolean,
    default: true
  },
  manualMode: {
    type: Boolean,
    default: false
  },
  showAfter: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    default: "bottom"
  },
  popperClass: {
    type: String,
    default: ""
  },
  pure: {
    type: Boolean,
    default: false
  },
  popperOptions: {
    type: Object,
    default: () => null
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  strategy: {
    type: String,
    default: "fixed"
  },
  transition: {
    type: String,
    default: "el-fade-in-linear"
  },
  trigger: {
    type: [String, Array],
    default: "hover"
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  fallbackPlacements: {
    type: Array,
    default: DEFAULT_FALLBACK_PLACEMENTS
  }
};
const UPDATE_VISIBLE_EVENT$1 = "update:visible";
function usePopper(props2, { emit: emit2 }) {
  const arrowRef = ref(null);
  const triggerRef2 = ref(null);
  const popperRef = ref(null);
  const popperId = `el-popper-${generateId()}`;
  let popperInstance = null;
  let showTimer = null;
  let hideTimer = null;
  let triggerFocused = false;
  const isManualMode = () => props2.manualMode || props2.trigger === "manual";
  const popperStyle = ref({ zIndex: PopupManager$1.nextZIndex() });
  const popperOptions2 = usePopperOptions(props2, {
    arrow: arrowRef
  });
  const state = reactive({
    visible: !!props2.visible
  });
  const visibility = computed({
    get() {
      if (props2.disabled) {
        return false;
      } else {
        return isBool(props2.visible) ? props2.visible : state.visible;
      }
    },
    set(val) {
      if (isManualMode())
        return;
      isBool(props2.visible) ? emit2(UPDATE_VISIBLE_EVENT$1, val) : state.visible = val;
    }
  });
  function _show() {
    if (props2.autoClose > 0) {
      hideTimer = window.setTimeout(() => {
        _hide();
      }, props2.autoClose);
    }
    visibility.value = true;
  }
  function _hide() {
    visibility.value = false;
  }
  function clearTimers() {
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
  }
  const show = () => {
    if (isManualMode() || props2.disabled)
      return;
    clearTimers();
    if (props2.showAfter === 0) {
      _show();
    } else {
      showTimer = window.setTimeout(() => {
        _show();
      }, props2.showAfter);
    }
  };
  const hide2 = () => {
    if (isManualMode())
      return;
    clearTimers();
    if (props2.hideAfter > 0) {
      hideTimer = window.setTimeout(() => {
        close2();
      }, props2.hideAfter);
    } else {
      close2();
    }
  };
  const close2 = () => {
    _hide();
    if (props2.disabled) {
      doDestroy(true);
    }
  };
  function onPopperMouseEnter() {
    if (props2.enterable && props2.trigger !== "click") {
      clearTimeout(hideTimer);
    }
  }
  function onPopperMouseLeave() {
    const { trigger } = props2;
    const shouldPrevent = isString$1(trigger) && (trigger === "click" || trigger === "focus") || trigger.length === 1 && (trigger[0] === "click" || trigger[0] === "focus");
    if (shouldPrevent)
      return;
    hide2();
  }
  function initializePopper() {
    if (!$(visibility)) {
      return;
    }
    const unwrappedTrigger = $(triggerRef2);
    const _trigger = isHTMLElement$1(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;
    popperInstance = createPopper(_trigger, $(popperRef), $(popperOptions2));
    popperInstance.update();
  }
  function doDestroy(forceDestroy) {
    if (!popperInstance || $(visibility) && !forceDestroy)
      return;
    detachPopper();
  }
  function detachPopper() {
    var _a;
    (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);
    popperInstance = null;
  }
  const events2 = {};
  function update() {
    if (!$(visibility)) {
      return;
    }
    if (popperInstance) {
      popperInstance.update();
    } else {
      initializePopper();
    }
  }
  function onVisibilityChange(toState) {
    if (toState) {
      popperStyle.value.zIndex = PopupManager$1.nextZIndex();
      initializePopper();
    }
  }
  if (!isManualMode()) {
    const toggleState = () => {
      if ($(visibility)) {
        hide2();
      } else {
        show();
      }
    };
    const popperEventsHandler = (e) => {
      e.stopPropagation();
      switch (e.type) {
        case "click": {
          if (triggerFocused) {
            triggerFocused = false;
          } else {
            toggleState();
          }
          break;
        }
        case "mouseenter": {
          show();
          break;
        }
        case "mouseleave": {
          hide2();
          break;
        }
        case "focus": {
          triggerFocused = true;
          show();
          break;
        }
        case "blur": {
          triggerFocused = false;
          hide2();
          break;
        }
      }
    };
    const triggerEventsMap = {
      click: ["onClick"],
      hover: ["onMouseenter", "onMouseleave"],
      focus: ["onFocus", "onBlur"]
    };
    const mapEvents = (t) => {
      triggerEventsMap[t].forEach((event) => {
        events2[event] = popperEventsHandler;
      });
    };
    if (isArray$6(props2.trigger)) {
      Object.values(props2.trigger).forEach(mapEvents);
    } else {
      mapEvents(props2.trigger);
    }
  }
  watch(popperOptions2, (val) => {
    if (!popperInstance)
      return;
    popperInstance.setOptions(val);
    popperInstance.update();
  });
  watch(visibility, onVisibilityChange);
  return {
    update,
    doDestroy,
    show,
    hide: hide2,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onAfterEnter: () => {
      emit2("after-enter");
    },
    onAfterLeave: () => {
      detachPopper();
      emit2("after-leave");
    },
    onBeforeEnter: () => {
      emit2("before-enter");
    },
    onBeforeLeave: () => {
      emit2("before-leave");
    },
    initializePopper,
    isManualMode,
    arrowRef,
    events: events2,
    popperId,
    popperInstance,
    popperRef,
    popperStyle,
    triggerRef: triggerRef2,
    visibility
  };
}
function renderPopper(props2, children) {
  const {
    effect: effect2,
    name,
    stopPopperMouseEvent,
    popperClass,
    popperStyle,
    popperRef,
    pure,
    popperId,
    visibility,
    onMouseenter,
    onMouseleave,
    onAfterEnter,
    onAfterLeave,
    onBeforeEnter,
    onBeforeLeave
  } = props2;
  const kls = [popperClass, "el-popper", `is-${effect2}`, pure ? "is-pure" : ""];
  const mouseUpAndDown = stopPopperMouseEvent ? stop : NOOP;
  return h$1(Transition, {
    name,
    onAfterEnter,
    onAfterLeave,
    onBeforeEnter,
    onBeforeLeave
  }, {
    default: withCtx(() => [
      withDirectives(h$1("div", {
        "aria-hidden": String(!visibility),
        class: kls,
        style: popperStyle != null ? popperStyle : {},
        id: popperId,
        ref: popperRef != null ? popperRef : "popperRef",
        role: "tooltip",
        onMouseenter,
        onMouseleave,
        onClick: stop,
        onMousedown: mouseUpAndDown,
        onMouseup: mouseUpAndDown
      }, children), [[vShow, visibility]])
    ])
  });
}
function renderTrigger(trigger, extraProps) {
  const firstElement = getFirstValidNode(trigger, 1);
  if (!firstElement)
    throwError("renderTrigger", "trigger expects single rooted node");
  return cloneVNode(firstElement, extraProps, true);
}
function renderArrow(showArrow) {
  return showArrow ? h$1("div", {
    ref: "arrowRef",
    class: "el-popper__arrow",
    "data-popper-arrow": ""
  }, null) : h$1(Comment, null, "");
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key2, value) => key2 in obj ? __defProp$j(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$j = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$j.call(b2, prop))
      __defNormalProp$j(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b2)) {
      if (__propIsEnum$j.call(b2, prop))
        __defNormalProp$j(a2, prop, b2[prop]);
    }
  return a2;
};
const compName = "ElPopper";
const UPDATE_VISIBLE_EVENT = "update:visible";
var script$r = defineComponent({
  name: compName,
  props: defaultProps$4,
  emits: [
    UPDATE_VISIBLE_EVENT,
    "after-enter",
    "after-leave",
    "before-enter",
    "before-leave"
  ],
  setup(props2, ctx) {
    if (!ctx.slots.trigger) {
      throwError(compName, "Trigger must be provided");
    }
    const popperStates = usePopper(props2, ctx);
    const forceDestroy = () => popperStates.doDestroy(true);
    onMounted(popperStates.initializePopper);
    onBeforeUnmount(forceDestroy);
    onActivated(popperStates.initializePopper);
    onDeactivated(forceDestroy);
    return popperStates;
  },
  render() {
    var _a;
    const {
      $slots,
      appendToBody,
      class: kls,
      style,
      effect: effect2,
      hide: hide2,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      popperClass,
      popperId,
      popperStyle,
      pure,
      showArrow,
      transition,
      visibility,
      stopPopperMouseEvent
    } = this;
    const isManual = this.isManualMode();
    const arrow2 = renderArrow(showArrow);
    const popper2 = renderPopper({
      effect: effect2,
      name: transition,
      popperClass,
      popperId,
      popperStyle,
      pure,
      stopPopperMouseEvent,
      onMouseenter: onPopperMouseEnter,
      onMouseleave: onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      visibility
    }, [
      renderSlot($slots, "default", {}, () => {
        return [toDisplayString(this.content)];
      }),
      arrow2
    ]);
    const _t = (_a = $slots.trigger) == null ? void 0 : _a.call($slots);
    const triggerProps = __spreadValues$j({
      "aria-describedby": popperId,
      class: kls,
      style,
      ref: "triggerRef"
    }, this.events);
    const trigger = isManual ? renderTrigger(_t, triggerProps) : withDirectives(renderTrigger(_t, triggerProps), [[ClickOutside$1, hide2]]);
    return h$1(Fragment, null, [
      trigger,
      h$1(Teleport, {
        to: "body",
        disabled: !appendToBody
      }, [popper2])
    ]);
  }
});
script$r.__file = "packages/components/popper/src/index.vue";
script$r.install = (app) => {
  app.component(script$r.name, script$r);
};
const _Popper = script$r;
var __defProp$i = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key2, value) => key2 in obj ? __defProp$i(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$i = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$i.call(b2, prop))
      __defNormalProp$i(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b2)) {
      if (__propIsEnum$i.call(b2, prop))
        __defNormalProp$i(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$d = (a2, b2) => __defProps$d(a2, __getOwnPropDescs$d(b2));
const buttonType = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
const buttonNativeType = ["button", "submit", "reset"];
const buttonProps = __spreadProps$d(__spreadValues$i({}, useFormItemProps), {
  type: buildProp({
    type: String,
    values: buttonType,
    default: ""
  }),
  icon: {
    type: String,
    default: ""
  },
  nativeType: buildProp({
    type: String,
    values: buttonNativeType,
    default: "button"
  }),
  loading: Boolean,
  plain: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean
});
const buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};
var script$1$e = defineComponent({
  name: "ElButton",
  props: buttonProps,
  emits: buttonEmits,
  setup(props2, { emit: emit2 }) {
    const elBtnGroup = inject(elButtonGroupKey, void 0);
    const { size: buttonSize, disabled: buttonDisabled } = useFormItem({
      size: computed(() => elBtnGroup == null ? void 0 : elBtnGroup.size)
    });
    const buttonType2 = computed(() => props2.type || (elBtnGroup == null ? void 0 : elBtnGroup.type) || "default");
    const elForm2 = inject(elFormKey, void 0);
    const handleClick = (evt) => {
      if (props2.nativeType === "reset") {
        elForm2 == null ? void 0 : elForm2.resetFields();
      }
      emit2("click", evt);
    };
    return {
      buttonSize,
      buttonType: buttonType2,
      buttonDisabled,
      handleClick
    };
  }
});
const _hoisted_1$1$b = ["disabled", "autofocus", "type"];
const _hoisted_2$D = {
  key: 0,
  class: "el-icon-loading"
};
const _hoisted_3$y = { key: 2 };
function render$1$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: normalizeClass([
      "el-button",
      _ctx.buttonType ? "el-button--" + _ctx.buttonType : "",
      _ctx.buttonSize ? "el-button--" + _ctx.buttonSize : "",
      {
        "is-disabled": _ctx.buttonDisabled,
        "is-loading": _ctx.loading,
        "is-plain": _ctx.plain,
        "is-round": _ctx.round,
        "is-circle": _ctx.circle
      }
    ]),
    disabled: _ctx.buttonDisabled || _ctx.loading,
    autofocus: _ctx.autofocus,
    type: _ctx.nativeType,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_2$D)) : createCommentVNode("v-if", true),
    _ctx.icon && !_ctx.loading ? (openBlock(), createElementBlock("i", {
      key: 1,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.default ? (openBlock(), createElementBlock("span", _hoisted_3$y, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$1$b);
}
script$1$e.render = render$1$e;
script$1$e.__file = "packages/components/button/src/button.vue";
const buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};
var script$q = defineComponent({
  name: "ElButtonGroup",
  props: buttonGroupProps,
  setup(props2) {
    provide(elButtonGroupKey, reactive({
      size: toRef(props2, "size"),
      type: toRef(props2, "type")
    }));
  }
});
const _hoisted_1$N = { class: "el-button-group" };
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$N, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$q.render = render$q;
script$q.__file = "packages/components/button/src/button-group.vue";
const ElButton = withInstall(script$1$e, {
  ButtonGroup: script$q
});
withNoopInstall(script$q);
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $2 = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m2, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), f2);
      return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, D2 = "en", v2 = {};
    v2[D2] = M2;
    var p2 = function(t2) {
      return t2 instanceof _2;
    }, S2 = function(t2, e2, n2) {
      var r2;
      if (!t2)
        return D2;
      if (typeof t2 == "string")
        v2[t2] && (r2 = t2), e2 && (v2[t2] = e2, r2 = t2);
      else {
        var i2 = t2.name;
        v2[i2] = t2, r2 = i2;
      }
      return !n2 && r2 && (D2 = r2), r2 || !n2 && D2;
    }, w2 = function(t2, e2) {
      if (p2(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _2(n2);
    }, O2 = g;
    O2.l = S2, O2.i = p2, O2.w = function(t2, e2) {
      return w2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _2 = function() {
      function M3(t2) {
        this.$L = S2(t2.locale, null, true), this.parse(t2);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O2.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m3.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === $2);
      }, m3.isSame = function(t2, e2) {
        var n2 = w2(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m3.isAfter = function(t2, e2) {
        return w2(t2) < this.startOf(e2);
      }, m3.isBefore = function(t2, e2) {
        return this.endOf(e2) < w2(t2);
      }, m3.$g = function(t2, e2, n2) {
        return O2.u(t2) ? this[e2] : this.set(n2, t2);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O2.u(e2) || e2, h3 = O2.p(t2), $3 = function(t3, e3) {
          var i2 = O2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a2);
        }, l3 = function(t3, e3) {
          return O2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M4 = this.$M, m4 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r2 ? $3(1, 0) : $3(31, 11);
          case f2:
            return r2 ? $3(1, M4) : $3(0, M4 + 1);
          case o2:
            var D3 = this.$locale().weekStart || 0, v3 = (y2 < D3 ? y2 + 7 : y2) - D3;
            return $3(r2 ? m4 - v3 : m4 + (6 - v3), M4);
          case a2:
          case d2:
            return l3(g2 + "Hours", 0);
          case u2:
            return l3(g2 + "Minutes", 1);
          case s2:
            return l3(g2 + "Seconds", 2);
          case i:
            return l3(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m3.$set = function(t2, e2) {
        var n2, o3 = O2.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $3 = (n2 = {}, n2[a2] = h3 + "Date", n2[d2] = h3 + "Date", n2[f2] = h3 + "Month", n2[c2] = h3 + "FullYear", n2[u2] = h3 + "Hours", n2[s2] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
        if (o3 === f2 || o3 === c2) {
          var y2 = this.clone().set(d2, 1);
          y2.$d[$3](l3), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $3 && this.$d[$3](l3);
        return this.init(), this;
      }, m3.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m3.get = function(t2) {
        return this[O2.p(t2)]();
      }, m3.add = function(r2, h3) {
        var d3, $3 = this;
        r2 = Number(r2);
        var l3 = O2.p(h3), y2 = function(t2) {
          var e2 = w2($3);
          return O2.w(e2.date(e2.date() + Math.round(t2 * r2)), $3);
        };
        if (l3 === f2)
          return this.set(f2, this.$M + r2);
        if (l3 === c2)
          return this.set(c2, this.$y + r2);
        if (l3 === a2)
          return y2(1);
        if (l3 === o2)
          return y2(7);
        var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[l3] || 1, m4 = this.$d.getTime() + r2 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m3.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $2;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n2.weekdays, f3 = n2.months, h3 = function(t3, n3, i3, s4) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].substr(0, s4);
        }, c3 = function(t3) {
          return O2.s(s3 % 12 || 12, t3, "0");
        }, d3 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n2.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o3, 2), ddd: h3(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || l3[t3] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, $3) {
        var l3, y2 = O2.p(d3), M4 = w2(r2), m4 = (M4.utcOffset() - this.utcOffset()) * e, g2 = this - M4, D3 = O2.m(this, M4);
        return D3 = (l3 = {}, l3[c2] = D3 / 12, l3[f2] = D3, l3[h2] = D3 / 3, l3[o2] = (g2 - m4) / 6048e5, l3[a2] = (g2 - m4) / 864e5, l3[u2] = g2 / n, l3[s2] = g2 / e, l3[i] = g2 / t, l3)[y2] || g2, $3 ? D3 : O2.a(D3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return v2[this.$L];
      }, m3.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S2(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), b2 = _2.prototype;
    return w2.prototype = b2, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
      b2[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w2.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _2, w2), t2.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
      return w2(1e3 * t2);
    }, w2.en = v2[D2], w2.Ls = v2, w2.p = {}, w2;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
var localeData$1 = { exports: {} };
(function(module, exports) {
  !function(n, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(n, e, t) {
      var r = e.prototype, o2 = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u2 = function(n2, e2, t2, r2, u3) {
        var i2 = n2.name ? n2 : n2.$locale(), a3 = o2(i2[e2]), s3 = o2(i2[t2]), f2 = a3 || s3.map(function(n3) {
          return n3.substr(0, r2);
        });
        if (!u3)
          return f2;
        var d2 = i2.weekStart;
        return f2.map(function(n3, e3) {
          return f2[(e3 + (d2 || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a2 = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s2 = function() {
        var n2 = this;
        return { months: function(e2) {
          return e2 ? e2.format("MMMM") : u2(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u2(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u2(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a2(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s2.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a2(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u2(i(), "months");
      }, t.monthsShort = function() {
        return u2(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u2(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u2(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u2(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData$1);
var localeData = localeData$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^\s\d-_:/()]+/, o2 = {}, s2 = function(t2) {
      return (t2 = +t2) + (t2 > 68 ? 1900 : 2e3);
    };
    var a2 = function(t2) {
      return function(e2) {
        this[t2] = +e2;
      };
    }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(t2) {
      (this.zone || (this.zone = {})).offset = function(t3) {
        if (!t3)
          return 0;
        if (t3 === "Z")
          return 0;
        var e2 = t3.match(/([+-]|\d\d)/g), n2 = 60 * e2[1] + (+e2[2] || 0);
        return n2 === 0 ? 0 : e2[0] === "+" ? -n2 : n2;
      }(t2);
    }], u2 = function(t2) {
      var e2 = o2[t2];
      return e2 && (e2.indexOf ? e2 : e2.s.concat(e2.f));
    }, h2 = function(t2, e2) {
      var n2, r2 = o2.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (t2.indexOf(r2(i2, 0, e2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = t2 === (e2 ? "pm" : "PM");
      return n2;
    }, d2 = { A: [i, function(t2) {
      this.afternoon = h2(t2, false);
    }], a: [i, function(t2) {
      this.afternoon = h2(t2, true);
    }], S: [/\d/, function(t2) {
      this.milliseconds = 100 * +t2;
    }], SS: [n, function(t2) {
      this.milliseconds = 10 * +t2;
    }], SSS: [/\d{3}/, function(t2) {
      this.milliseconds = +t2;
    }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n, a2("day")], Do: [i, function(t2) {
      var e2 = o2.ordinal, n2 = t2.match(/\d+/);
      if (this.day = n2[0], e2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          e2(r2).replace(/\[|\]/g, "") === t2 && (this.day = r2);
    }], M: [r, a2("month")], MM: [n, a2("month")], MMM: [i, function(t2) {
      var e2 = u2("months"), n2 = (u2("monthsShort") || e2.map(function(t3) {
        return t3.substr(0, 3);
      })).indexOf(t2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(t2) {
      var e2 = u2("months").indexOf(t2) + 1;
      if (e2 < 1)
        throw new Error();
      this.month = e2 % 12 || e2;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n, function(t2) {
      this.year = s2(t2);
    }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
    function c2(n2) {
      var r2, i2;
      r2 = n2, i2 = o2 && o2.formats;
      for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e2, n3, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || t[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t2, e3, n4) {
          return e3 || n4.slice(1);
        });
      })).match(e), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
        var u3 = s3[f3], h3 = d2[u3], c3 = h3 && h3[0], l2 = h3 && h3[1];
        s3[f3] = l2 ? { regex: c3, parser: l2 } : u3.replace(/^\[|\]$/g, "");
      }
      return function(t2) {
        for (var e2 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
          var i3 = s3[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var o3 = i3.regex, f4 = i3.parser, u4 = t2.substr(r3), h4 = o3.exec(u4)[0];
            f4.call(e2, h4), t2 = t2.replace(h4, "");
          }
        }
        return function(t3) {
          var e3 = t3.afternoon;
          if (e3 !== void 0) {
            var n4 = t3.hours;
            e3 ? n4 < 12 && (t3.hours += 12) : n4 === 12 && (t3.hours = 0), delete t3.afternoon;
          }
        }(e2), e2;
      };
    }
    return function(t2, e2, n2) {
      n2.p.customParseFormat = true, t2 && t2.parseTwoDigitYear && (s2 = t2.parseTwoDigitYear);
      var r2 = e2.prototype, i2 = r2.parse;
      r2.parse = function(t3) {
        var e3 = t3.date, r3 = t3.utc, s3 = t3.args;
        this.$u = r3;
        var a3 = s3[1];
        if (typeof a3 == "string") {
          var f3 = s3[2] === true, u3 = s3[3] === true, h3 = f3 || u3, d3 = s3[2];
          u3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n2.Ls[d3]), this.$d = function(t4, e4, n3) {
            try {
              if (["x", "X"].indexOf(e4) > -1)
                return new Date((e4 === "X" ? 1e3 : 1) * t4);
              var r4 = c2(e4)(t4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f4 = r4.minutes, u4 = r4.seconds, h4 = r4.milliseconds, d4 = r4.zone, l3 = new Date(), m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y = 0;
              i3 && !o3 || (Y = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f4 || 0, D2 = u4 || 0, g = h4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y, m3, p2, v2, D2, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y, m3, p2, v2, D2, g)) : new Date(M3, Y, m3, p2, v2, D2, g);
            } catch (t5) {
              return new Date("");
            }
          }(e3, a3, r3), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), h3 && e3 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n2.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i2.call(this, t3);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
var Symbol$2 = _Symbol, isArguments = isArguments_1, isArray$1 = isArray_1;
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array4);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string3) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string3),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
function baseFindIndex$1(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf(array4, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array4, value, comparator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$1() {
}
var noop_1 = noop$1;
var Set$1 = _Set, noop = noop_1, setToArray$1 = _setToArray;
var INFINITY = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values) {
  return new Set$1(values);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array4, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array4.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array4);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result.push(value);
      } else if (!includes(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var isArrayLike$1 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseFlatten = _baseFlatten, baseRest = _baseRest, baseUniq = _baseUniq, isArrayLikeObject = isArrayLikeObject_1;
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
var union_1 = union;
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};
const timePickerDefaultProps = {
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: {
    type: String
  },
  valueFormat: {
    type: String
  },
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: String,
    default: "el-icon-circle-close"
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  modelValue: {
    type: [Date, Array, String],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};
const dateEquals = function(a2, b2) {
  const aIsDate = a2 instanceof Date;
  const bIsDate = b2 instanceof Date;
  if (aIsDate && bIsDate) {
    return a2.getTime() === b2.getTime();
  }
  if (!aIsDate && !bIsDate) {
    return a2 === b2;
  }
  return false;
};
const valueEquals = function(a2, b2) {
  const aIsArray = a2 instanceof Array;
  const bIsArray = b2 instanceof Array;
  if (aIsArray && bIsArray) {
    if (a2.length !== b2.length) {
      return false;
    }
    return a2.every((item, index2) => dateEquals(item, b2[index2]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a2, b2);
  }
  return false;
};
const parser = function(date4, format2, lang) {
  const day = isEmpty(format2) ? dayjs(date4).locale(lang) : dayjs(date4, format2).locale(lang);
  return day.isValid() ? day : void 0;
};
const formatter = function(date4, format2, lang) {
  return isEmpty(format2) ? date4 : dayjs(date4).locale(lang).format(format2);
};
var script$3$4 = defineComponent({
  name: "Picker",
  components: {
    ElInput: _Input,
    ElPopper: _Popper
  },
  directives: { clickoutside: ClickOutside$1 },
  props: timePickerDefaultProps,
  emits: ["update:modelValue", "change", "focus", "blur", "calendar-change"],
  setup(props2, ctx) {
    const ELEMENT = useGlobalConfig();
    const { lang } = useLocaleInject();
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const elPopperOptions = inject("ElPopperOptions", {});
    const refPopper = ref(null);
    const pickerVisible = ref(false);
    const pickerActualVisible = ref(false);
    const valueOnOpen = ref(null);
    watch(pickerVisible, (val) => {
      var _a;
      if (!val) {
        userInput.value = null;
        nextTick(() => {
          emitChange(props2.modelValue);
        });
        ctx.emit("blur");
        blurInput();
        props2.validateEvent && ((_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "blur"));
      } else {
        valueOnOpen.value = props2.modelValue;
      }
    });
    const emitChange = (val, isClear) => {
      var _a;
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        ctx.emit("change", val);
        props2.validateEvent && ((_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change"));
      }
    };
    const emitInput = (val) => {
      if (!valueEquals(props2.modelValue, val)) {
        let formatValue;
        if (Array.isArray(val)) {
          formatValue = val.map((_2) => formatter(_2, props2.valueFormat, lang.value));
        } else if (val) {
          formatValue = formatter(val, props2.valueFormat, lang.value);
        }
        ctx.emit("update:modelValue", val ? formatValue : val, lang.value);
      }
    };
    const refInput = computed(() => {
      if (refPopper.value.triggerRef) {
        const _r = isRangeInput.value ? refPopper.value.triggerRef : refPopper.value.triggerRef.$el;
        return [].slice.call(_r.querySelectorAll("input"));
      }
      return [];
    });
    const setSelectionRange = (start2, end2, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length)
        return;
      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start2, end2);
        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start2, end2);
        _inputs[1].focus();
      }
    };
    const onPick = (date4 = "", visible = false) => {
      pickerVisible.value = visible;
      let result;
      if (Array.isArray(date4)) {
        result = date4.map((_2) => _2.toDate());
      } else {
        result = date4 ? date4.toDate() : date4;
      }
      userInput.value = null;
      emitInput(result);
    };
    const handleFocus = (e) => {
      if (props2.readonly || pickerDisabled.value || pickerVisible.value)
        return;
      pickerVisible.value = true;
      ctx.emit("focus", e);
    };
    const handleBlur = () => {
      pickerVisible.value = false;
      blurInput();
    };
    const pickerDisabled = computed(() => {
      return props2.disabled || elForm2.disabled;
    });
    const parsedValue = computed(() => {
      let result;
      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          result = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (Array.isArray(props2.modelValue)) {
          result = props2.modelValue.map((_2) => parser(_2, props2.valueFormat, lang.value));
        } else {
          result = parser(props2.modelValue, props2.valueFormat, lang.value);
        }
      }
      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(result);
        if (!isEqual_1(availableResult, result)) {
          result = availableResult;
          emitInput(Array.isArray(result) ? result.map((_2) => _2.toDate()) : result.toDate());
        }
      }
      if (Array.isArray(result) && result.some((_2) => !_2)) {
        result = [];
      }
      return result;
    });
    const displayValue = computed(() => {
      if (!pickerOptions.value.panelReady)
        return;
      const formattedValue = formatDayjsToString(parsedValue.value);
      if (Array.isArray(userInput.value)) {
        return [
          userInput.value[0] || formattedValue && formattedValue[0] || "",
          userInput.value[1] || formattedValue && formattedValue[1] || ""
        ];
      } else if (userInput.value !== null) {
        return userInput.value;
      }
      if (!isTimePicker.value && valueIsEmpty.value)
        return;
      if (!pickerVisible.value && valueIsEmpty.value)
        return;
      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }
      return "";
    });
    const isTimeLikePicker = computed(() => props2.type.includes("time"));
    const isTimePicker = computed(() => props2.type.startsWith("time"));
    const isDatesPicker = computed(() => props2.type === "dates");
    const triggerClass = computed(() => props2.prefixIcon || (isTimeLikePicker.value ? "el-icon-time" : "el-icon-date"));
    const showClose = ref(false);
    const onClearIconClick = (event) => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (showClose.value) {
        event.stopPropagation();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };
    const valueIsEmpty = computed(() => {
      return !props2.modelValue || Array.isArray(props2.modelValue) && !props2.modelValue.length;
    });
    const onMouseEnter = () => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (!valueIsEmpty.value && props2.clearable) {
        showClose.value = true;
      }
    };
    const onMouseLeave = () => {
      showClose.value = false;
    };
    const isRangeInput = computed(() => {
      return props2.type.indexOf("range") > -1;
    });
    const pickerSize = computed(() => {
      return props2.size || elFormItem2.size || ELEMENT.size;
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = refPopper.value) == null ? void 0 : _a.popperRef;
    });
    const onClickOutside = () => {
      if (!pickerVisible.value)
        return;
      pickerVisible.value = false;
    };
    const userInput = ref(null);
    const handleChange = () => {
      if (userInput.value) {
        const value = parseUserInputToDayjs(displayValue.value);
        if (value) {
          if (isValidValue(value)) {
            emitInput(Array.isArray(value) ? value.map((_2) => _2.toDate()) : value.toDate());
            userInput.value = null;
          }
        }
      }
      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };
    const blurInput = () => {
      refInput.value.forEach((input) => input.blur());
    };
    const parseUserInputToDayjs = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.parseUserInput(value);
    };
    const formatDayjsToString = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.formatToString(value);
    };
    const isValidValue = (value) => {
      return pickerOptions.value.isValidValue(value);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      if (code === EVENT_CODE.esc) {
        pickerVisible.value = false;
        event.stopPropagation();
        return;
      }
      if (code === EVENT_CODE.tab) {
        if (!isRangeInput.value) {
          handleChange();
          pickerVisible.value = false;
          event.stopPropagation();
        } else {
          setTimeout(() => {
            if (refInput.value.indexOf(document.activeElement) === -1) {
              pickerVisible.value = false;
              blurInput();
            }
          }, 0);
        }
        return;
      }
      if (code === EVENT_CODE.enter) {
        if (userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }
        event.stopPropagation();
        return;
      }
      if (userInput.value) {
        event.stopPropagation();
        return;
      }
      if (pickerOptions.value.handleKeydown) {
        pickerOptions.value.handleKeydown(event);
      }
    };
    const onUserInput = (e) => {
      userInput.value = e;
    };
    const handleStartInput = (event) => {
      if (userInput.value) {
        userInput.value = [event.target.value, userInput.value[1]];
      } else {
        userInput.value = [event.target.value, null];
      }
    };
    const handleEndInput = (event) => {
      if (userInput.value) {
        userInput.value = [userInput.value[0], event.target.value];
      } else {
        userInput.value = [null, event.target.value];
      }
    };
    const handleStartChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[0]);
      if (value && value.isValid()) {
        userInput.value = [formatDayjsToString(value), displayValue.value[1]];
        const newValue = [value, parsedValue.value && parsedValue.value[1]];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const handleEndChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[1]);
      if (value && value.isValid()) {
        userInput.value = [displayValue.value[0], formatDayjsToString(value)];
        const newValue = [parsedValue.value && parsedValue.value[0], value];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const pickerOptions = ref({});
    const onSetPickerOption = (e) => {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };
    const onCalendarChange = (e) => {
      ctx.emit("calendar-change", e);
    };
    provide("EP_PICKER_BASE", {
      props: props2
    });
    return {
      Effect,
      elPopperOptions,
      isDatesPicker,
      handleEndChange,
      handleStartChange,
      handleStartInput,
      handleEndInput,
      onUserInput,
      handleChange,
      handleKeydown,
      popperPaneRef,
      onClickOutside,
      pickerSize,
      isRangeInput,
      onMouseLeave,
      onMouseEnter,
      onClearIconClick,
      showClose,
      triggerClass,
      onPick,
      handleFocus,
      handleBlur,
      pickerVisible,
      pickerActualVisible,
      displayValue,
      parsedValue,
      setSelectionRange,
      refPopper,
      pickerDisabled,
      onSetPickerOption,
      onCalendarChange
    };
  }
});
const _hoisted_1$3$2 = ["name", "placeholder", "value", "disabled", "readonly"];
const _hoisted_2$3$2 = { class: "el-range-separator" };
const _hoisted_3$2$3 = ["name", "placeholder", "value", "disabled", "readonly"];
function render$3$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_popper, mergeProps({
    ref: "refPopper",
    visible: _ctx.pickerVisible,
    "onUpdate:visible": _cache[18] || (_cache[18] = ($event) => _ctx.pickerVisible = $event),
    "manual-mode": "",
    effect: _ctx.Effect.LIGHT,
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    "popper-class": `el-picker__popper ${_ctx.popperClass}`,
    "popper-options": _ctx.elPopperOptions,
    "fallback-placements": ["bottom", "top", "right", "left"],
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "append-to-body": "",
    onBeforeEnter: _cache[19] || (_cache[19] = ($event) => _ctx.pickerActualVisible = true),
    onAfterLeave: _cache[20] || (_cache[20] = ($event) => _ctx.pickerActualVisible = false)
  }), {
    trigger: withCtx(() => [
      !_ctx.isRangeInput ? withDirectives((openBlock(), createBlock(_component_el_input, {
        key: 0,
        "model-value": _ctx.displayValue,
        name: _ctx.name,
        size: _ctx.pickerSize,
        disabled: _ctx.pickerDisabled,
        placeholder: _ctx.placeholder,
        class: normalizeClass(["el-date-editor", "el-date-editor--" + _ctx.type]),
        readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
        onInput: _ctx.onUserInput,
        onFocus: _ctx.handleFocus,
        onKeydown: _ctx.handleKeydown,
        onChange: _ctx.handleChange,
        onMouseenter: _ctx.onMouseEnter,
        onMouseleave: _ctx.onMouseLeave
      }, {
        prefix: withCtx(() => [
          createElementVNode("i", {
            class: normalizeClass(["el-input__icon", _ctx.triggerClass]),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
          }, null, 2)
        ]),
        suffix: withCtx(() => [
          createElementVNode("i", {
            class: normalizeClass(["el-input__icon", [_ctx.showClose ? "" + _ctx.clearIcon : ""]]),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClearIconClick && _ctx.onClearIconClick(...args))
          }, null, 2)
        ]),
        _: 1
      }, 8, ["model-value", "name", "size", "disabled", "placeholder", "class", "readonly", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ]) : withDirectives((openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["el-date-editor el-range-editor el-input__inner", [
          "el-date-editor--" + _ctx.type,
          _ctx.pickerSize ? `el-range-editor--${_ctx.pickerSize}` : "",
          _ctx.pickerDisabled ? "is-disabled" : "",
          _ctx.pickerVisible ? "is-active" : ""
        ]]),
        onClick: _cache[9] || (_cache[9] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onMouseenter: _cache[10] || (_cache[10] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[11] || (_cache[11] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onKeydown: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }, [
        createElementVNode("i", {
          class: normalizeClass(["el-input__icon", "el-range__icon", _ctx.triggerClass])
        }, null, 2),
        createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[0],
          placeholder: _ctx.startPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[0],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onInput: _cache[2] || (_cache[2] = (...args) => _ctx.handleStartInput && _ctx.handleStartInput(...args)),
          onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleStartChange && _ctx.handleStartChange(...args)),
          onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
        }, null, 40, _hoisted_1$3$2),
        renderSlot(_ctx.$slots, "range-separator", {}, () => [
          createElementVNode("span", _hoisted_2$3$2, toDisplayString(_ctx.rangeSeparator), 1)
        ]),
        createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[1],
          placeholder: _ctx.endPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[1],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onInput: _cache[6] || (_cache[6] = (...args) => _ctx.handleEndInput && _ctx.handleEndInput(...args)),
          onChange: _cache[7] || (_cache[7] = (...args) => _ctx.handleEndChange && _ctx.handleEndChange(...args))
        }, null, 40, _hoisted_3$2$3),
        createElementVNode("i", {
          class: normalizeClass([[_ctx.showClose ? "" + _ctx.clearIcon : ""], "el-input__icon el-range__close-icon"]),
          onClick: _cache[8] || (_cache[8] = (...args) => _ctx.onClearIconClick && _ctx.onClearIconClick(...args))
        }, null, 2)
      ], 34)), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ])
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {
        visible: _ctx.pickerVisible,
        actualVisible: _ctx.pickerActualVisible,
        parsedValue: _ctx.parsedValue,
        format: _ctx.format,
        unlinkPanels: _ctx.unlinkPanels,
        type: _ctx.type,
        defaultValue: _ctx.defaultValue,
        onPick: _cache[13] || (_cache[13] = (...args) => _ctx.onPick && _ctx.onPick(...args)),
        onSelectRange: _cache[14] || (_cache[14] = (...args) => _ctx.setSelectionRange && _ctx.setSelectionRange(...args)),
        onSetPickerOption: _cache[15] || (_cache[15] = (...args) => _ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)),
        onCalendarChange: _cache[16] || (_cache[16] = (...args) => _ctx.onCalendarChange && _ctx.onCalendarChange(...args)),
        onMousedown: _cache[17] || (_cache[17] = withModifiers(() => {
        }, ["stop"]))
      })
    ]),
    _: 3
  }, 16, ["visible", "effect", "popper-class", "popper-options"]);
}
script$3$4.render = render$3$4;
script$3$4.__file = "packages/components/time-picker/src/common/picker.vue";
const makeList = (total, method4, methodFunc) => {
  const arr = [];
  const disabledArr = method4 && methodFunc();
  for (let i = 0; i < total; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }
  return arr;
};
const makeAvailableArr = (list) => {
  return list.map((_2, index2) => !_2 ? index2 : _2).filter((_2) => _2 !== true);
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare));
  };
  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare));
  };
  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };
  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };
  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
const useOldValue = (props2) => {
  const oldValue = ref(props2.parsedValue);
  watch(() => props2.visible, (val) => {
    if (!val) {
      oldValue.value = props2.parsedValue;
    }
  });
  return oldValue;
};
var script$2$9 = defineComponent({
  directives: {
    repeatClick: RepeatClick
  },
  components: {
    ElScrollbar: _Scrollbar
  },
  props: {
    role: {
      type: String,
      required: true
    },
    spinnerDate: {
      type: Object,
      required: true
    },
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean,
    amPmMode: {
      type: String,
      default: ""
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    }
  },
  emits: ["change", "select-range", "set-option"],
  setup(props2, ctx) {
    let isScrolling = false;
    const debouncedResetScroll = debounce_1((type4) => {
      isScrolling = false;
      adjustCurrentSpinner(type4);
    }, 200);
    const currentScrollbar = ref(null);
    const listHoursRef = ref(null);
    const listMinutesRef = ref(null);
    const listSecondsRef = ref(null);
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = computed(() => {
      const arr = ["hours", "minutes", "seconds"];
      return props2.showSeconds ? arr : arr.slice(0, 2);
    });
    const hours = computed(() => {
      return props2.spinnerDate.hour();
    });
    const minutes = computed(() => {
      return props2.spinnerDate.minute();
    });
    const seconds = computed(() => {
      return props2.spinnerDate.second();
    });
    const timePartsMap = computed(() => ({
      hours,
      minutes,
      seconds
    }));
    const hoursList = computed(() => {
      return getHoursList(props2.role);
    });
    const minutesList = computed(() => {
      return getMinutesList(hours.value, props2.role);
    });
    const secondsList = computed(() => {
      return getSecondsList(hours.value, minutes.value, props2.role);
    });
    const listMap = computed(() => ({
      hours: hoursList,
      minutes: minutesList,
      seconds: secondsList
    }));
    const arrowHourList = computed(() => {
      const hour = hours.value;
      return [
        hour > 0 ? hour - 1 : void 0,
        hour,
        hour < 23 ? hour + 1 : void 0
      ];
    });
    const arrowMinuteList = computed(() => {
      const minute = minutes.value;
      return [
        minute > 0 ? minute - 1 : void 0,
        minute,
        minute < 59 ? minute + 1 : void 0
      ];
    });
    const arrowSecondList = computed(() => {
      const second = seconds.value;
      return [
        second > 0 ? second - 1 : void 0,
        second,
        second < 59 ? second + 1 : void 0
      ];
    });
    const arrowListMap = computed(() => ({
      hours: arrowHourList,
      minutes: arrowMinuteList,
      seconds: arrowSecondList
    }));
    const getAmPmFlag = (hour) => {
      const shouldShowAmPm = !!props2.amPmMode;
      if (!shouldShowAmPm)
        return "";
      const isCapital = props2.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital)
        content = content.toUpperCase();
      return content;
    };
    const emitSelectRange = (type4) => {
      if (type4 === "hours") {
        ctx.emit("select-range", 0, 2);
      } else if (type4 === "minutes") {
        ctx.emit("select-range", 3, 5);
      } else if (type4 === "seconds") {
        ctx.emit("select-range", 6, 8);
      }
      currentScrollbar.value = type4;
    };
    const adjustCurrentSpinner = (type4) => {
      adjustSpinner(type4, timePartsMap.value[type4].value);
    };
    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };
    const adjustSpinner = (type4, value) => {
      if (props2.arrowControl)
        return;
      const el = listRefsMap[type4];
      if (el.value) {
        el.value.$el.querySelector(".el-scrollbar__wrap").scrollTop = Math.max(0, value * typeItemHeight(type4));
      }
    };
    const typeItemHeight = (type4) => {
      const el = listRefsMap[type4];
      return el.value.$el.querySelector("li").offsetHeight;
    };
    const onIncreaseClick = () => {
      scrollDown(1);
    };
    const onDecreaseClick = () => {
      scrollDown(-1);
    };
    const scrollDown = (step) => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }
      const label2 = currentScrollbar.value;
      let now2 = timePartsMap.value[label2].value;
      const total = currentScrollbar.value === "hours" ? 24 : 60;
      now2 = (now2 + step + total) % total;
      modifyDateField(label2, now2);
      adjustSpinner(label2, now2);
      nextTick(() => emitSelectRange(currentScrollbar.value));
    };
    const modifyDateField = (type4, value) => {
      const list = listMap.value[type4].value;
      const isDisabled = list[value];
      if (isDisabled)
        return;
      switch (type4) {
        case "hours":
          ctx.emit("change", props2.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
          break;
        case "minutes":
          ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
          break;
        case "seconds":
          ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
          break;
      }
    };
    const handleClick = (type4, { value, disabled: disabled2 }) => {
      if (!disabled2) {
        modifyDateField(type4, value);
        emitSelectRange(type4);
        adjustSpinner(type4, value);
      }
    };
    const handleScroll = (type4) => {
      isScrolling = true;
      debouncedResetScroll(type4);
      const value = Math.min(Math.round((listRefsMap[type4].value.$el.querySelector(".el-scrollbar__wrap").scrollTop - (scrollBarHeight(type4) * 0.5 - 10) / typeItemHeight(type4) + 3) / typeItemHeight(type4)), type4 === "hours" ? 23 : 59);
      modifyDateField(type4, value);
    };
    const scrollBarHeight = (type4) => {
      return listRefsMap[type4].value.$el.offsetHeight;
    };
    const bindScrollEvent = () => {
      const bindFuntion = (type4) => {
        if (listRefsMap[type4].value) {
          listRefsMap[type4].value.$el.querySelector(".el-scrollbar__wrap").onscroll = () => {
            handleScroll(type4);
          };
        }
      };
      bindFuntion("hours");
      bindFuntion("minutes");
      bindFuntion("seconds");
    };
    onMounted(() => {
      nextTick(() => {
        !props2.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props2.role === "start")
          emitSelectRange("hours");
      });
    });
    const getRefId = (item) => {
      return `list${item.charAt(0).toUpperCase() + item.slice(1)}Ref`;
    };
    ctx.emit("set-option", [`${props2.role}_scrollDown`, scrollDown]);
    ctx.emit("set-option", [`${props2.role}_emitSelectRange`, emitSelectRange]);
    const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds);
    watch(() => props2.spinnerDate, () => {
      if (isScrolling)
        return;
      adjustSpinners();
    });
    return {
      getRefId,
      spinnerItems,
      currentScrollbar,
      hours,
      minutes,
      seconds,
      hoursList,
      minutesList,
      arrowHourList,
      arrowMinuteList,
      arrowSecondList,
      getAmPmFlag,
      emitSelectRange,
      adjustCurrentSpinner,
      typeItemHeight,
      listHoursRef,
      listMinutesRef,
      listSecondsRef,
      onIncreaseClick,
      onDecreaseClick,
      handleClick,
      secondsList,
      timePartsMap,
      arrowListMap,
      listMap
    };
  }
});
const _hoisted_1$2$4 = ["onClick"];
const _hoisted_2$2$3 = ["onMouseenter"];
const _hoisted_3$1$7 = { class: "el-time-spinner__arrow el-icon-arrow-up" };
const _hoisted_4$1$5 = { class: "el-time-spinner__arrow el-icon-arrow-down" };
const _hoisted_5$1$4 = { class: "el-time-spinner__list" };
function render$2$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-time-spinner", { "has-seconds": _ctx.showSeconds }])
  }, [
    !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createBlock(_component_el_scrollbar, {
        key: item,
        ref: _ctx.getRefId(item),
        class: "el-time-spinner__wrapper",
        "wrap-style": "max-height: inherit;",
        "view-class": "el-time-spinner__list",
        noresize: "",
        tag: "ul",
        onMouseenter: ($event) => _ctx.emitSelectRange(item),
        onMousemove: ($event) => _ctx.adjustCurrentSpinner(item)
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listMap[item].value, (disabled2, key2) => {
            return openBlock(), createElementBlock("li", {
              key: key2,
              class: normalizeClass(["el-time-spinner__item", { active: key2 === _ctx.timePartsMap[item].value, disabled: disabled2 }]),
              onClick: ($event) => _ctx.handleClick(item, { value: key2, disabled: disabled2 })
            }, [
              item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key2 % 12 || 12 : key2)).slice(-2)) + toDisplayString(_ctx.getAmPmFlag(key2)), 1)
              ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(("0" + key2).slice(-2)), 1)
              ], 2112))
            ], 10, _hoisted_1$2$4);
          }), 128))
        ]),
        _: 2
      }, 1032, ["onMouseenter", "onMousemove"]);
    }), 128)) : createCommentVNode("v-if", true),
    _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createElementBlock("div", {
        key: item,
        class: "el-time-spinner__wrapper is-arrow",
        onMouseenter: ($event) => _ctx.emitSelectRange(item)
      }, [
        withDirectives(createElementVNode("i", _hoisted_3$1$7, null, 512), [
          [_directive_repeat_click, _ctx.onDecreaseClick]
        ]),
        withDirectives(createElementVNode("i", _hoisted_4$1$5, null, 512), [
          [_directive_repeat_click, _ctx.onIncreaseClick]
        ]),
        createElementVNode("ul", _hoisted_5$1$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.arrowListMap[item].value, (time, key2) => {
            return openBlock(), createElementBlock("li", {
              key: key2,
              class: normalizeClass(["el-time-spinner__item", {
                active: time === _ctx.timePartsMap[item].value,
                disabled: _ctx.listMap[item].value[time]
              }])
            }, toDisplayString(time === void 0 ? "" : ("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2) + _ctx.getAmPmFlag(time)), 3);
          }), 128))
        ])
      ], 40, _hoisted_2$2$3);
    }), 128)) : createCommentVNode("v-if", true)
  ], 2);
}
script$2$9.render = render$2$8;
script$2$9.__file = "packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue";
var script$1$d = defineComponent({
  components: {
    TimeSpinner: script$2$9
  },
  props: {
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    datetimeRole: {
      type: String
    },
    parsedValue: {
      type: [Object, String]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const selectionRange = ref([0, 2]);
    const oldValue = useOldValue(props2);
    const transitionName = computed(() => {
      return props2.actualVisible === void 0 ? "el-zoom-in-top" : "";
    });
    const showSeconds = computed(() => {
      return props2.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props2.format.includes("A"))
        return "A";
      if (props2.format.includes("a"))
        return "a";
      return "";
    });
    const isValidValue = (_date) => {
      const parsedDate = dayjs(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };
    const handleCancel = () => {
      ctx.emit("pick", oldValue.value, false);
    };
    const handleConfirm = (visible = false, first = false) => {
      if (first)
        return;
      ctx.emit("pick", props2.parsedValue, visible);
    };
    const handleChange = (_date) => {
      if (!props2.visible) {
        return;
      }
      const result = getRangeAvailableTime(_date).millisecond(0);
      ctx.emit("pick", result, true);
    };
    const setSelectionRange = (start2, end2) => {
      ctx.emit("select-range", start2, end2);
      selectionRange.value = [start2, end2];
    };
    const changeSelectionRange = (step) => {
      const list = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      timePickerOptions["start_emitSelectRange"](mapping[next]);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event.preventDefault();
        return;
      }
    };
    const getRangeAvailableTime = (date4) => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      let result = date4;
      ["hour", "minute", "second"].forEach((_2) => {
        if (availableMap[_2]) {
          let availableArr;
          const method4 = availableMap[_2];
          if (_2 === "minute") {
            availableArr = method4(result.hour(), props2.datetimeRole);
          } else if (_2 === "second") {
            availableArr = method4(result.hour(), result.minute(), props2.datetimeRole);
          } else {
            availableArr = method4(props2.datetimeRole);
          }
          if (availableArr && availableArr.length && !availableArr.includes(result[_2]())) {
            result = result[_2](availableArr[0]);
          }
        }
      });
      return result;
    };
    const parseUserInput = (value) => {
      if (!value)
        return null;
      return dayjs(value, props2.format).locale(lang.value);
    };
    const formatToString = (value) => {
      if (!value)
        return null;
      return value.format(props2.format);
    };
    const getDefaultValue = () => {
      return dayjs(defaultValue2).locale(lang.value);
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx.emit("set-picker-option", [
      "getRangeAvailableTime",
      getRangeAvailableTime
    ]);
    ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    const timePickerOptions = {};
    const onSetOption = (e) => {
      timePickerOptions[e[0]] = e[1];
    };
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue: defaultValue2
    } = pickerBase.props;
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
    return {
      transitionName,
      arrowControl,
      onSetOption,
      t,
      handleConfirm,
      handleChange,
      setSelectionRange,
      amPmMode,
      showSeconds,
      handleCancel,
      disabledHours,
      disabledMinutes,
      disabledSeconds
    };
  }
});
const _hoisted_1$1$a = {
  key: 0,
  class: "el-time-panel"
};
const _hoisted_2$1$9 = { class: "el-time-panel__footer" };
function render$1$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = resolveComponent("time-spinner");
  return openBlock(), createBlock(Transition, { name: _ctx.transitionName }, {
    default: withCtx(() => [
      _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", _hoisted_1$1$a, [
        createElementVNode("div", {
          class: normalizeClass(["el-time-panel__content", { "has-seconds": _ctx.showSeconds }])
        }, [
          createVNode(_component_time_spinner, {
            ref: "spinner",
            role: _ctx.datetimeRole || "start",
            "arrow-control": _ctx.arrowControl,
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "spinner-date": _ctx.parsedValue,
            "disabled-hours": _ctx.disabledHours,
            "disabled-minutes": _ctx.disabledMinutes,
            "disabled-seconds": _ctx.disabledSeconds,
            onChange: _ctx.handleChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setSelectionRange
          }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2),
        createElementVNode("div", _hoisted_2$1$9, [
          createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn cancel",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
          createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn confirm",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
          }, toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ])
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["name"]);
}
script$1$d.render = render$1$d;
script$1$d.__file = "packages/components/time-picker/src/time-picker-com/panel-time-pick.vue";
const makeSelectRange = (start2, end2) => {
  const result = [];
  for (let i = start2; i <= end2; i++) {
    result.push(i);
  }
  return result;
};
var script$p = defineComponent({
  components: { TimeSpinner: script$2$9 },
  props: {
    visible: Boolean,
    actualVisible: Boolean,
    parsedValue: {
      type: [Array]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const minDate = computed(() => props2.parsedValue[0]);
    const maxDate = computed(() => props2.parsedValue[1]);
    const oldValue = useOldValue(props2);
    const handleCancel = () => {
      ctx.emit("pick", oldValue.value, null);
    };
    const showSeconds = computed(() => {
      return props2.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props2.format.includes("A"))
        return "A";
      if (props2.format.includes("a"))
        return "a";
      return "";
    });
    const minSelectableRange = ref([]);
    const maxSelectableRange = ref([]);
    const handleConfirm = (visible = false) => {
      ctx.emit("pick", [minDate.value, maxDate.value], visible);
    };
    const handleMinChange = (date4) => {
      handleChange(date4.millisecond(0), maxDate.value);
    };
    const handleMaxChange = (date4) => {
      handleChange(minDate.value, date4.millisecond(0));
    };
    const isValidValue = (_date) => {
      const parsedDate = _date.map((_2) => dayjs(_2).locale(lang.value));
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
    };
    const handleChange = (_minDate, _maxDate) => {
      ctx.emit("pick", [_minDate, _maxDate], true);
    };
    const btnConfirmDisabled = computed(() => {
      return minDate.value > maxDate.value;
    });
    const selectionRange = ref([0, 2]);
    const setMinSelectionRange = (start2, end2) => {
      ctx.emit("select-range", start2, end2, "min");
      selectionRange.value = [start2, end2];
    };
    const offset2 = computed(() => showSeconds.value ? 11 : 8);
    const setMaxSelectionRange = (start2, end2) => {
      ctx.emit("select-range", start2, end2, "max");
      selectionRange.value = [start2 + offset2.value, end2 + offset2.value];
    };
    const changeSelectionRange = (step) => {
      const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      const half = list.length / 2;
      if (next < half) {
        timePickerOptions["start_emitSelectRange"](mapping[next]);
      } else {
        timePickerOptions["end_emitSelectRange"](mapping[next - half]);
      }
    };
    const handleKeydown = (event) => {
      const code = event.code;
      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        const role = selectionRange.value[0] < offset2.value ? "start" : "end";
        timePickerOptions[`${role}_scrollDown`](step);
        event.preventDefault();
        return;
      }
    };
    const disabledHours_ = (role, compare) => {
      const defaultDisable = disabledHours ? disabledHours(role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const disabledMinutes_ = (hour, role, compare) => {
      const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      if (hour !== compareHour) {
        return defaultDisable;
      }
      const compareMinute = compareDate.minute();
      const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const disabledSeconds_ = (hour, minute, role, compare) => {
      const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      const compareMinute = compareDate.minute();
      if (hour !== compareHour || minute !== compareMinute) {
        return defaultDisable;
      }
      const compareSecond = compareDate.second();
      const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const getRangeAvailableTime = (dates) => {
      return dates.map((_2, index2) => getRangeAvailableTimeEach(dates[0], dates[1], index2 === 0 ? "start" : "end"));
    };
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = getAvailableArrs(disabledHours_, disabledMinutes_, disabledSeconds_);
    const getRangeAvailableTimeEach = (startDate, endDate, role) => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      const isStart = role === "start";
      let result = isStart ? startDate : endDate;
      const compareDate = isStart ? endDate : startDate;
      ["hour", "minute", "second"].forEach((_2) => {
        if (availableMap[_2]) {
          let availableArr;
          const method4 = availableMap[_2];
          if (_2 === "minute") {
            availableArr = method4(result.hour(), role, compareDate);
          } else if (_2 === "second") {
            availableArr = method4(result.hour(), result.minute(), role, compareDate);
          } else {
            availableArr = method4(role, compareDate);
          }
          if (availableArr && availableArr.length && !availableArr.includes(result[_2]())) {
            const pos = isStart ? 0 : availableArr.length - 1;
            result = result[_2](availableArr[pos]);
          }
        }
      });
      return result;
    };
    const parseUserInput = (value) => {
      if (!value)
        return null;
      if (Array.isArray(value)) {
        return value.map((_2) => dayjs(_2, props2.format).locale(lang.value));
      }
      return dayjs(value, props2.format).locale(lang.value);
    };
    const formatToString = (value) => {
      if (!value)
        return null;
      if (Array.isArray(value)) {
        return value.map((_2) => _2.format(props2.format));
      }
      return value.format(props2.format);
    };
    const getDefaultValue = () => {
      if (Array.isArray(defaultValue2)) {
        return defaultValue2.map((_2) => dayjs(_2).locale(lang.value));
      }
      const defaultDay = dayjs(defaultValue2).locale(lang.value);
      return [defaultDay, defaultDay.add(60, "m")];
    };
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    ctx.emit("set-picker-option", [
      "getRangeAvailableTime",
      getRangeAvailableTime
    ]);
    const timePickerOptions = {};
    const onSetOption = (e) => {
      timePickerOptions[e[0]] = e[1];
    };
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue: defaultValue2
    } = pickerBase.props;
    return {
      arrowControl,
      onSetOption,
      setMaxSelectionRange,
      setMinSelectionRange,
      btnConfirmDisabled,
      handleCancel,
      handleConfirm,
      t,
      showSeconds,
      minDate,
      maxDate,
      amPmMode,
      handleMinChange,
      handleMaxChange,
      minSelectableRange,
      maxSelectableRange,
      disabledHours_,
      disabledMinutes_,
      disabledSeconds_
    };
  }
});
const _hoisted_1$M = {
  key: 0,
  class: "el-time-range-picker el-picker-panel"
};
const _hoisted_2$C = { class: "el-time-range-picker__content" };
const _hoisted_3$x = { class: "el-time-range-picker__cell" };
const _hoisted_4$o = { class: "el-time-range-picker__header" };
const _hoisted_5$k = { class: "el-time-range-picker__cell" };
const _hoisted_6$g = { class: "el-time-range-picker__header" };
const _hoisted_7$b = { class: "el-time-panel__footer" };
const _hoisted_8$7 = ["disabled"];
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = resolveComponent("time-spinner");
  return _ctx.actualVisible ? (openBlock(), createElementBlock("div", _hoisted_1$M, [
    createElementVNode("div", _hoisted_2$C, [
      createElementVNode("div", _hoisted_3$x, [
        createElementVNode("div", _hoisted_4$o, toDisplayString(_ctx.t("el.datepicker.startTime")), 1),
        createElementVNode("div", {
          class: normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          createVNode(_component_time_spinner, {
            ref: "minSpinner",
            role: "start",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.minDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMinChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMinSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ]),
      createElementVNode("div", _hoisted_5$k, [
        createElementVNode("div", _hoisted_6$g, toDisplayString(_ctx.t("el.datepicker.endTime")), 1),
        createElementVNode("div", {
          class: normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          createVNode(_component_time_spinner, {
            ref: "maxSpinner",
            role: "end",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.maxDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMaxChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMaxSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ])
    ]),
    createElementVNode("div", _hoisted_7$b, [
      createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn cancel",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleCancel())
      }, toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
      createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn confirm",
        disabled: _ctx.btnConfirmDisabled,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
      }, toDisplayString(_ctx.t("el.datepicker.confirm")), 9, _hoisted_8$7)
    ])
  ])) : createCommentVNode("v-if", true);
}
script$p.render = render$p;
script$p.__file = "packages/components/time-picker/src/time-picker-com/panel-time-range.vue";
var __defProp$h = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key2, value) => key2 in obj ? __defProp$h(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$h = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$h.call(b2, prop))
      __defNormalProp$h(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b2)) {
      if (__propIsEnum$h.call(b2, prop))
        __defNormalProp$h(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$c = (a2, b2) => __defProps$c(a2, __getOwnPropDescs$c(b2));
dayjs.extend(customParseFormat);
var TimePicker = defineComponent({
  name: "ElTimePicker",
  install: null,
  props: __spreadProps$c(__spreadValues$h({}, timePickerDefaultProps), {
    isRange: {
      type: Boolean,
      default: false
    }
  }),
  emits: ["update:modelValue"],
  setup(props2, ctx) {
    const commonPicker = ref(null);
    const type4 = props2.isRange ? "timerange" : "time";
    const panel = props2.isRange ? script$p : script$1$d;
    const refProps = __spreadProps$c(__spreadValues$h({}, props2), {
      focus: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
      },
      blur: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleBlur();
      }
    });
    provide("ElPopperOptions", props2.popperOptions);
    ctx.expose(refProps);
    return () => {
      var _a;
      const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_TIME;
      return h$1(script$3$4, __spreadProps$c(__spreadValues$h({}, props2), {
        format: format2,
        type: type4,
        ref: commonPicker,
        "onUpdate:modelValue": (value) => ctx.emit("update:modelValue", value)
      }), {
        default: (scopedProps) => h$1(panel, scopedProps)
      });
    };
  }
});
const rangeArr = (n) => {
  return Array.from(Array(n).keys());
};
const extractDateFormat = (format2) => {
  return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format2) => {
  return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
const _TimePicker = TimePicker;
_TimePicker.install = (app) => {
  app.component(_TimePicker.name, _TimePicker);
};
const ElTimePicker = _TimePicker;
const cardProps = {
  header: {
    type: String,
    default: ""
  },
  bodyStyle: buildProp({
    type: definePropType([String, Object, Array]),
    default: ""
  }),
  shadow: {
    type: String,
    default: ""
  }
};
var script$o = defineComponent({
  name: "ElCard",
  props: cardProps
});
const _hoisted_1$L = {
  key: 0,
  class: "el-card__header"
};
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-card", _ctx.shadow ? "is-" + _ctx.shadow + "-shadow" : "is-always-shadow"])
  }, [
    _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", _hoisted_1$L, [
      renderSlot(_ctx.$slots, "header", {}, () => [
        createTextVNode(toDisplayString(_ctx.header), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      class: "el-card__body",
      style: normalizeStyle(_ctx.bodyStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 2);
}
script$o.render = render$o;
script$o.__file = "packages/components/card/src/card.vue";
const ElCard = withInstall(script$o);
var debounce = debounce_1, isObject$4 = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options2) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject$4(options2)) {
    leading = "leading" in options2 ? !!options2.leading : leading;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
function scrollIntoView(container, selected) {
  if (isServer)
    return;
  if (!selected) {
    container.scrollTop = 0;
    return;
  }
  const offsetParents = [];
  let pointer = selected.offsetParent;
  while (pointer !== null && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }
  const top2 = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
  const bottom2 = top2 + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;
  if (top2 < viewRectTop) {
    container.scrollTop = top2;
  } else if (bottom2 > viewRectBottom) {
    container.scrollTop = bottom2 - container.clientHeight;
  }
}
const useCheckboxProps = {
  modelValue: {
    type: [Boolean, Number, String],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  size: String
};
const useCheckboxGroup = () => {
  const ELEMENT = useGlobalConfig();
  const elForm2 = inject(elFormKey, {});
  const elFormItem2 = inject(elFormItemKey, {});
  const checkboxGroup = inject("CheckboxGroup", {});
  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = computed(() => {
    return elFormItem2.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm: elForm2,
    ELEMENT,
    elFormItemSize,
    elFormItem: elFormItem2
  };
};
const useModel = (props2) => {
  const selfModel = ref(false);
  const { emit: emit2 } = getCurrentInstance();
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitExceeded = ref(false);
  const store = computed(() => {
    var _a;
    return checkboxGroup ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : props2.modelValue;
  });
  const model = computed({
    get() {
      var _a;
      return isGroup.value ? store.value : (_a = props2.modelValue) != null ? _a : selfModel.value;
    },
    set(val) {
      var _a;
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = false;
        if (checkboxGroup.min !== void 0 && val.length < checkboxGroup.min.value) {
          isLimitExceeded.value = true;
        }
        if (checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value) {
          isLimitExceeded.value = true;
        }
        isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a.call(checkboxGroup, val));
      } else {
        emit2(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isLimitExceeded
  };
};
const useCheckboxStatus = (props2, { model }) => {
  const { isGroup, checkboxGroup, elFormItemSize, ELEMENT } = useCheckboxGroup();
  const focus = ref(false);
  const size2 = computed(() => {
    var _a;
    return ((_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value) || elFormItemSize.value || ELEMENT.size;
  });
  const isChecked = computed(() => {
    const value = model.value;
    if (toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props2.label);
    } else if (value !== null && value !== void 0) {
      return value === props2.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = computed(() => {
    var _a;
    const temCheckboxSize = props2.size || elFormItemSize.value || ELEMENT.size;
    return isGroup.value ? ((_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value) || temCheckboxSize : temCheckboxSize;
  });
  return {
    isChecked,
    focus,
    size: size2,
    checkboxSize
  };
};
const useDisabled = (props2, {
  model,
  isChecked
}) => {
  const { elForm: elForm2, isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitDisabled = computed(() => {
    var _a, _b;
    const max2 = (_a = checkboxGroup.max) == null ? void 0 : _a.value;
    const min2 = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
    return !!(max2 || min2) && model.value.length >= max2 && !isChecked.value || model.value.length <= min2 && isChecked.value;
  });
  const isDisabled = computed(() => {
    var _a;
    const disabled2 = props2.disabled || elForm2.disabled;
    return isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled2 || isLimitDisabled.value : props2.disabled || elForm2.disabled;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props2, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props2.label)) {
      model.value.push(props2.label);
    } else {
      model.value = props2.trueLabel || true;
    }
  }
  props2.checked && addToStore();
};
const useEvent$1 = (props2, { isLimitExceeded }) => {
  const { elFormItem: elFormItem2 } = useCheckboxGroup();
  const { emit: emit2 } = getCurrentInstance();
  function handleChange(e) {
    var _a, _b;
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    const value = target.checked ? (_a = props2.trueLabel) != null ? _a : true : (_b = props2.falseLabel) != null ? _b : false;
    emit2("change", value, e);
  }
  watch(() => props2.modelValue, () => {
    var _a;
    (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
  });
  return {
    handleChange
  };
};
const useCheckbox = (props2) => {
  const { model, isLimitExceeded } = useModel(props2);
  const { focus, size: size2, isChecked, checkboxSize } = useCheckboxStatus(props2, {
    model
  });
  const { isDisabled } = useDisabled(props2, { model, isChecked });
  const { handleChange } = useEvent$1(props2, { isLimitExceeded });
  setStoreValue(props2, { model });
  return {
    isChecked,
    isDisabled,
    checkboxSize,
    model,
    handleChange,
    focus,
    size: size2
  };
};
var script$2$8 = defineComponent({
  name: "ElCheckbox",
  props: {
    modelValue: {
      type: [Boolean, Number, String],
      default: () => void 0
    },
    label: {
      type: [String, Boolean, Number, Object]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: void 0
    },
    trueLabel: {
      type: [String, Number],
      default: void 0
    },
    falseLabel: {
      type: [String, Number],
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    controls: {
      type: String,
      default: void 0
    },
    border: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    return useCheckbox(props2);
  }
});
const _hoisted_1$2$3 = ["id", "aria-controls"];
const _hoisted_2$1$8 = ["tabindex", "role", "aria-checked"];
const _hoisted_3$1$6 = /* @__PURE__ */ createElementVNode("span", { class: "el-checkbox__inner" }, null, -1);
const _hoisted_4$n = ["aria-hidden", "name", "disabled", "true-value", "false-value"];
const _hoisted_5$j = ["aria-hidden", "disabled", "value", "name"];
const _hoisted_6$f = {
  key: 0,
  class: "el-checkbox__label"
};
function render$2$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    id: _ctx.id,
    class: normalizeClass(["el-checkbox", [
      _ctx.checkboxSize ? "el-checkbox--" + _ctx.checkboxSize : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-bordered": _ctx.border },
      { "is-checked": _ctx.isChecked }
    ]]),
    "aria-controls": _ctx.indeterminate ? _ctx.controls : null
  }, [
    createElementVNode("span", {
      class: normalizeClass(["el-checkbox__input", {
        "is-disabled": _ctx.isDisabled,
        "is-checked": _ctx.isChecked,
        "is-indeterminate": _ctx.indeterminate,
        "is-focus": _ctx.focus
      }]),
      tabindex: _ctx.indeterminate ? 0 : void 0,
      role: _ctx.indeterminate ? "checkbox" : void 0,
      "aria-checked": _ctx.indeterminate ? "mixed" : false
    }, [
      _hoisted_3$1$6,
      _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
        key: 0,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        name: _ctx.name,
        disabled: _ctx.isDisabled,
        "true-value": _ctx.trueLabel,
        "false-value": _ctx.falseLabel,
        onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_4$n)), [
        [vModelCheckbox, _ctx.model]
      ]) : withDirectives((openBlock(), createElementBlock("input", {
        key: 1,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        disabled: _ctx.isDisabled,
        value: _ctx.label,
        name: _ctx.name,
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
        onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_5$j)), [
        [vModelCheckbox, _ctx.model]
      ])
    ], 10, _hoisted_2$1$8),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", _hoisted_6$f, [
      renderSlot(_ctx.$slots, "default"),
      !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ], 2112)) : createCommentVNode("v-if", true)
    ])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$2$3);
}
script$2$8.render = render$2$7;
script$2$8.__file = "packages/components/checkbox/src/checkbox.vue";
var script$1$c = defineComponent({
  name: "ElCheckboxButton",
  props: useCheckboxProps,
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    const { focus, isChecked, isDisabled, size: size2, model, handleChange } = useCheckbox(props2);
    const { checkboxGroup } = useCheckboxGroup();
    const activeStyle = computed(() => {
      var _a, _b, _c, _d;
      const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
      };
    });
    return {
      focus,
      isChecked,
      isDisabled,
      model,
      handleChange,
      activeStyle,
      size: size2
    };
  }
});
const _hoisted_1$1$9 = ["aria-checked", "aria-disabled"];
const _hoisted_2$B = ["name", "disabled", "true-value", "false-value"];
const _hoisted_3$w = ["name", "disabled", "value"];
function render$1$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-checkbox-button", [
      _ctx.size ? "el-checkbox-button--" + _ctx.size : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-checked": _ctx.isChecked },
      { "is-focus": _ctx.focus }
    ]]),
    role: "checkbox",
    "aria-checked": _ctx.isChecked,
    "aria-disabled": _ctx.isDisabled
  }, [
    _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
      key: 0,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      "true-value": _ctx.trueLabel,
      "false-value": _ctx.falseLabel,
      onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
      onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$B)), [
      [vModelCheckbox, _ctx.model]
    ]) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      value: _ctx.label,
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
      onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_3$w)), [
      [vModelCheckbox, _ctx.model]
    ]),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
      key: 2,
      class: "el-checkbox-button__inner",
      style: normalizeStyle(_ctx.isChecked ? _ctx.activeStyle : null)
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 4)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$1$9);
}
script$1$c.render = render$1$c;
script$1$c.__file = "packages/components/checkbox/src/checkbox-button.vue";
var __defProp$g = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key2, value) => key2 in obj ? __defProp$g(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$g = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$g.call(b2, prop))
      __defNormalProp$g(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b2)) {
      if (__propIsEnum$g.call(b2, prop))
        __defNormalProp$g(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$b = (a2, b2) => __defProps$b(a2, __getOwnPropDescs$b(b2));
var script$n = defineComponent({
  name: "ElCheckboxGroup",
  props: {
    modelValue: {
      type: [Object, Boolean, Array],
      default: () => void 0
    },
    disabled: Boolean,
    min: {
      type: Number,
      default: void 0
    },
    max: {
      type: Number,
      default: void 0
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    fill: {
      type: String,
      default: void 0
    },
    textColor: {
      type: String,
      default: void 0
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx) {
    const { elFormItem: elFormItem2, elFormItemSize, ELEMENT } = useCheckboxGroup();
    const checkboxGroupSize = computed(() => props2.size || elFormItemSize.value || ELEMENT.size);
    const changeEvent = (value) => {
      ctx.emit(UPDATE_MODEL_EVENT, value);
      nextTick(() => {
        ctx.emit("change", value);
      });
    };
    const modelValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        changeEvent(val);
      }
    });
    provide("CheckboxGroup", __spreadProps$b(__spreadValues$g({
      name: "ElCheckboxGroup",
      modelValue
    }, toRefs(props2)), {
      checkboxGroupSize,
      changeEvent
    }));
    watch(() => props2.modelValue, () => {
      var _a;
      (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
    });
  }
});
const _hoisted_1$K = {
  class: "el-checkbox-group",
  role: "group",
  "aria-label": "checkbox-group"
};
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$K, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$n.render = render$n;
script$n.__file = "packages/components/checkbox/src/checkbox-group.vue";
const ElCheckbox = withInstall(script$2$8, {
  CheckboxButton: script$1$c,
  CheckboxGroup: script$n
});
withNoopInstall(script$1$c);
const ElCheckboxGroup$1 = withNoopInstall(script$n);
const radioGroupKey = "RadioGroup";
const useRadio = () => {
  const ELEMENT = useGlobalConfig();
  const elForm2 = inject(elFormKey, {});
  const elFormItem2 = inject(elFormItemKey, {});
  const radioGroup = inject(radioGroupKey, {});
  const focus = ref(false);
  const isGroup = computed(() => (radioGroup == null ? void 0 : radioGroup.name) === "ElRadioGroup");
  const elFormItemSize = computed(() => elFormItem2.size || ELEMENT.size);
  return {
    isGroup,
    focus,
    radioGroup,
    elForm: elForm2,
    ELEMENT,
    elFormItemSize
  };
};
const useRadioAttrs = (props2, { isGroup, radioGroup, elForm: elForm2, model }) => {
  const isDisabled = computed(() => {
    return isGroup.value ? radioGroup.disabled || props2.disabled || elForm2.disabled : props2.disabled || elForm2.disabled;
  });
  const tabIndex = computed(() => {
    return isDisabled.value || isGroup.value && model.value !== props2.label ? -1 : 0;
  });
  return {
    isDisabled,
    tabIndex
  };
};
var script$2$7 = defineComponent({
  name: "ElRadio",
  componentName: "ElRadio",
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    disabled: Boolean,
    name: {
      type: String,
      default: ""
    },
    border: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx) {
    const { isGroup, radioGroup, elFormItemSize, ELEMENT, focus, elForm: elForm2 } = useRadio();
    const radioRef = ref();
    const model = computed({
      get() {
        return isGroup.value ? radioGroup.modelValue : props2.modelValue;
      },
      set(val) {
        if (isGroup.value) {
          radioGroup.changeEvent(val);
        } else {
          ctx.emit(UPDATE_MODEL_EVENT, val);
        }
        radioRef.value.checked = props2.modelValue === props2.label;
      }
    });
    const { tabIndex, isDisabled } = useRadioAttrs(props2, {
      isGroup,
      radioGroup,
      elForm: elForm2,
      model
    });
    const radioSize = computed(() => {
      const temRadioSize = props2.size || elFormItemSize.value || ELEMENT.size;
      return isGroup.value ? radioGroup.radioGroupSize || temRadioSize : temRadioSize;
    });
    function handleChange() {
      nextTick(() => {
        ctx.emit("change", model.value);
      });
    }
    return {
      focus,
      isGroup,
      isDisabled,
      model,
      tabIndex,
      radioSize,
      handleChange,
      radioRef
    };
  }
});
const _hoisted_1$1$8 = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$1$7 = /* @__PURE__ */ createElementVNode("span", { class: "el-radio__inner" }, null, -1);
const _hoisted_3$v = ["value", "name", "disabled"];
function render$2$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-radio", {
      [`el-radio--${_ctx.radioSize || ""}`]: _ctx.radioSize,
      "is-disabled": _ctx.isDisabled,
      "is-focus": _ctx.focus,
      "is-bordered": _ctx.border,
      "is-checked": _ctx.model === _ctx.label
    }]),
    role: "radio",
    "aria-checked": _ctx.model === _ctx.label,
    "aria-disabled": _ctx.isDisabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.model = _ctx.isDisabled ? _ctx.model : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    createElementVNode("span", {
      class: normalizeClass(["el-radio__input", {
        "is-disabled": _ctx.isDisabled,
        "is-checked": _ctx.model === _ctx.label
      }])
    }, [
      _hoisted_2$1$7,
      withDirectives(createElementVNode("input", {
        ref: "radioRef",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        class: "el-radio__original",
        value: _ctx.label,
        type: "radio",
        "aria-hidden": "true",
        name: _ctx.name,
        disabled: _ctx.isDisabled,
        tabindex: "-1",
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
        onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false),
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
      }, null, 40, _hoisted_3$v), [
        [vModelRadio, _ctx.model]
      ])
    ], 2),
    createElementVNode("span", {
      class: "el-radio__label",
      onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 32)
  ], 42, _hoisted_1$1$8);
}
script$2$7.render = render$2$6;
script$2$7.__file = "packages/components/radio/src/radio.vue";
var script$1$b = defineComponent({
  name: "ElRadioButton",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    disabled: Boolean,
    name: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const { isGroup, radioGroup, elFormItemSize, ELEMENT, focus, elForm: elForm2 } = useRadio();
    const size2 = computed(() => {
      return radioGroup.radioGroupSize || elFormItemSize.value || ELEMENT.size;
    });
    const radioRef = ref();
    const value = computed({
      get() {
        return radioGroup.modelValue;
      },
      set(value2) {
        radioGroup.changeEvent(value2);
        radioRef.value.checked = radioGroup.modelValue === props2.label;
      }
    });
    const { isDisabled, tabIndex } = useRadioAttrs(props2, {
      model: value,
      elForm: elForm2,
      radioGroup,
      isGroup
    });
    const activeStyle = computed(() => {
      return {
        backgroundColor: radioGroup.fill || "",
        borderColor: radioGroup.fill || "",
        boxShadow: radioGroup.fill ? `-1px 0 0 0 ${radioGroup.fill}` : "",
        color: radioGroup.textColor || ""
      };
    });
    return {
      isGroup,
      size: size2,
      isDisabled,
      tabIndex,
      value,
      focus,
      activeStyle,
      radioRef
    };
  }
});
const _hoisted_1$J = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$A = ["value", "name", "disabled"];
function render$1$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-radio-button", [
      _ctx.size ? "el-radio-button--" + _ctx.size : "",
      {
        "is-active": _ctx.value === _ctx.label,
        "is-disabled": _ctx.isDisabled,
        "is-focus": _ctx.focus
      }
    ]]),
    role: "radio",
    "aria-checked": _ctx.value === _ctx.label,
    "aria-disabled": _ctx.isDisabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.value = _ctx.isDisabled ? _ctx.value : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    withDirectives(createElementVNode("input", {
      ref: "radioRef",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
      class: "el-radio-button__original-radio",
      value: _ctx.label,
      type: "radio",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      tabindex: "-1",
      onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
      onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$A), [
      [vModelRadio, _ctx.value]
    ]),
    createElementVNode("span", {
      class: "el-radio-button__inner",
      style: normalizeStyle(_ctx.value === _ctx.label ? _ctx.activeStyle : null),
      onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 36)
  ], 42, _hoisted_1$J);
}
script$1$b.render = render$1$b;
script$1$b.__file = "packages/components/radio/src/radio-button.vue";
var __defProp$f = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key2, value) => key2 in obj ? __defProp$f(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$f = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$f.call(b2, prop))
      __defNormalProp$f(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b2)) {
      if (__propIsEnum$f.call(b2, prop))
        __defNormalProp$f(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$a = (a2, b2) => __defProps$a(a2, __getOwnPropDescs$a(b2));
var script$m = defineComponent({
  name: "ElRadioGroup",
  componentName: "ElRadioGroup",
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    fill: {
      type: String,
      default: ""
    },
    textColor: {
      type: String,
      default: ""
    },
    disabled: Boolean
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx) {
    const radioGroup = ref(null);
    const elFormItem2 = inject(elFormItemKey, {});
    const radioGroupSize = computed(() => {
      return props2.size || elFormItem2.size;
    });
    const changeEvent = (value) => {
      ctx.emit(UPDATE_MODEL_EVENT, value);
      nextTick(() => {
        ctx.emit("change", value);
      });
    };
    provide(radioGroupKey, reactive(__spreadProps$a(__spreadValues$f({
      name: "ElRadioGroup"
    }, toRefs(props2)), {
      radioGroupSize,
      changeEvent
    })));
    watch(() => props2.modelValue, () => {
      var _a;
      (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
    });
    const handleKeydown = (e) => {
      const target = e.target;
      const className = target.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
      const radios = radioGroup.value.querySelectorAll(className);
      const length = radios.length;
      const index2 = Array.from(radios).indexOf(target);
      const roleRadios = radioGroup.value.querySelectorAll("[role=radio]");
      let nextIndex = null;
      switch (e.code) {
        case EVENT_CODE.left:
        case EVENT_CODE.up:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index2 === 0 ? length - 1 : index2 - 1;
          break;
        case EVENT_CODE.right:
        case EVENT_CODE.down:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index2 === length - 1 ? 0 : index2 + 1;
          break;
      }
      if (nextIndex === null)
        return;
      roleRadios[nextIndex].click();
      roleRadios[nextIndex].focus();
    };
    onMounted(() => {
      const radios = radioGroup.value.querySelectorAll("[type=radio]");
      const firstLabel = radios[0];
      if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    });
    return {
      handleKeydown,
      radioGroupSize,
      radioGroup
    };
  }
});
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "radioGroup",
    class: "el-radio-group",
    role: "radiogroup",
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 544);
}
script$m.render = render$m;
script$m.__file = "packages/components/radio/src/radio-group.vue";
const ElRadio = withInstall(script$2$7, {
  RadioButton: script$1$b,
  RadioGroup: script$m
});
const ElRadioGroup = withNoopInstall(script$m);
const ElRadioButton = withNoopInstall(script$1$b);
var NodeContent = defineComponent({
  name: "NodeContent",
  render() {
    const { node, panel } = this.$parent;
    const { data, label: label2 } = node;
    const { renderLabelFn } = panel;
    return h$1("span", { class: "el-cascader-node__label" }, renderLabelFn ? renderLabelFn({ node, data }) : label2);
  }
});
var ExpandTrigger$1;
(function(ExpandTrigger2) {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
})(ExpandTrigger$1 || (ExpandTrigger$1 = {}));
const CASCADER_PANEL_INJECTION_KEY = Symbol();
var script$2$6 = defineComponent({
  name: "ElCascaderNode",
  components: {
    ElCheckbox,
    ElRadio,
    NodeContent
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(props2, { emit: emit2 }) {
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const isHoverMenu = computed(() => panel.isHoverMenu);
    const multiple2 = computed(() => panel.config.multiple);
    const checkStrictly = computed(() => panel.config.checkStrictly);
    const checkedNodeId = computed(() => {
      var _a;
      return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
    });
    const isDisabled = computed(() => props2.node.isDisabled);
    const isLeaf2 = computed(() => props2.node.isLeaf);
    const expandable = computed(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
    const inExpandingPath = computed(() => isInPath(panel.expandingNode));
    const inCheckedPath = computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
    const isInPath = (node) => {
      var _a;
      const { level, uid: uid2 } = props2.node;
      return ((_a = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid2;
    };
    const doExpand = () => {
      if (inExpandingPath.value)
        return;
      panel.expandNode(props2.node);
    };
    const doCheck = (checked) => {
      const { node } = props2;
      if (checked === node.checked)
        return;
      panel.handleCheckChange(node, checked);
    };
    const doLoad = () => {
      panel.lazyLoad(props2.node, () => {
        if (!isLeaf2.value)
          doExpand();
      });
    };
    const handleHoverExpand = (e) => {
      if (!isHoverMenu.value)
        return;
      handleExpand();
      !isLeaf2.value && emit2("expand", e);
    };
    const handleExpand = () => {
      const { node } = props2;
      if (!expandable.value || node.loading)
        return;
      node.loaded ? doExpand() : doLoad();
    };
    const handleClick = () => {
      if (isHoverMenu.value && !isLeaf2.value)
        return;
      if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple2.value) {
        handleCheck(true);
      } else {
        handleExpand();
      }
    };
    const handleCheck = (checked) => {
      if (!props2.node.loaded) {
        doLoad();
      } else {
        doCheck(checked);
        !checkStrictly.value && doExpand();
      }
    };
    return {
      panel,
      isHoverMenu,
      multiple: multiple2,
      checkStrictly,
      checkedNodeId,
      isDisabled,
      isLeaf: isLeaf2,
      expandable,
      inExpandingPath,
      inCheckedPath,
      handleHoverExpand,
      handleExpand,
      handleClick,
      handleCheck
    };
  }
});
const _hoisted_1$1$7 = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
const _hoisted_2$1$6 = /* @__PURE__ */ createElementVNode("span", null, null, -1);
const _hoisted_3$u = {
  key: 2,
  class: "el-icon-check el-cascader-node__prefix"
};
const _hoisted_4$m = {
  key: 0,
  class: "el-icon-loading el-cascader-node__postfix"
};
const _hoisted_5$i = {
  key: 1,
  class: "el-icon-arrow-right el-cascader-node__postfix"
};
function render$2$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_radio = resolveComponent("el-radio");
  const _component_node_content = resolveComponent("node-content");
  return openBlock(), createElementBlock("li", {
    id: `${_ctx.menuId}-${_ctx.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !_ctx.isLeaf,
    "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
    "aria-expanded": _ctx.inExpandingPath,
    tabindex: _ctx.expandable ? -1 : null,
    class: normalizeClass([
      "el-cascader-node",
      _ctx.checkStrictly && "is-selectable",
      _ctx.inExpandingPath && "in-active-path",
      _ctx.inCheckedPath && "in-checked-path",
      _ctx.node.checked && "is-active",
      !_ctx.expandable && "is-disabled"
    ]),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createCommentVNode(" prefix "),
    _ctx.multiple ? (openBlock(), createBlock(_component_el_checkbox, {
      key: 0,
      "model-value": _ctx.node.checked,
      indeterminate: _ctx.node.indeterminate,
      disabled: _ctx.isDisabled,
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["stop"])),
      "onUpdate:modelValue": _ctx.handleCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? (openBlock(), createBlock(_component_el_radio, {
      key: 1,
      "model-value": _ctx.checkedNodeId,
      label: _ctx.node.uid,
      disabled: _ctx.isDisabled,
      "onUpdate:modelValue": _ctx.handleCheck,
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(() => [
        createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
        _hoisted_2$1$6
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? (openBlock(), createElementBlock("i", _hoisted_3$u)) : createCommentVNode("v-if", true),
    createCommentVNode(" content "),
    createVNode(_component_node_content),
    createCommentVNode(" postfix "),
    !_ctx.isLeaf ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      _ctx.node.loading ? (openBlock(), createElementBlock("i", _hoisted_4$m)) : (openBlock(), createElementBlock("i", _hoisted_5$i))
    ], 2112)) : createCommentVNode("v-if", true)
  ], 42, _hoisted_1$1$7);
}
script$2$6.render = render$2$5;
script$2$6.__file = "packages/components/cascader-panel/src/node.vue";
var script$1$a = defineComponent({
  name: "ElCascaderMenu",
  components: {
    ElScrollbar: _Scrollbar,
    ElCascaderNode: script$2$6
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { t } = useLocaleInject();
    const id2 = generateId();
    let activeNode = null;
    let hoverTimer = null;
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const hoverZone = ref(null);
    const isEmpty2 = computed(() => !props2.nodes.length);
    const menuId = computed(() => `cascader-menu-${id2}-${props2.index}`);
    const handleExpand = (e) => {
      activeNode = e.target;
    };
    const handleMouseMove = (e) => {
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
        return;
      if (activeNode.contains(e.target)) {
        clearHoverTimer();
        const el = instance.vnode.el;
        const { left: left2 } = el.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = el;
        const startX = e.clientX - left2;
        const top2 = activeNode.offsetTop;
        const bottom2 = top2 + activeNode.offsetHeight;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top2} L${offsetWidth} 0 V${top2} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom2} L${offsetWidth} ${offsetHeight} V${bottom2} Z" />
        `;
      } else if (!hoverTimer) {
        hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };
    const clearHoverTimer = () => {
      if (!hoverTimer)
        return;
      clearTimeout(hoverTimer);
      hoverTimer = null;
    };
    const clearHoverZone = () => {
      if (!hoverZone.value)
        return;
      hoverZone.value.innerHTML = "";
      clearHoverTimer();
    };
    return {
      panel,
      hoverZone,
      isEmpty: isEmpty2,
      menuId,
      t,
      handleExpand,
      handleMouseMove,
      clearHoverZone
    };
  }
});
const _hoisted_1$I = {
  key: 0,
  class: "el-cascader-menu__empty-text"
};
const _hoisted_2$z = {
  key: 1,
  ref: "hoverZone",
  class: "el-cascader-menu__hover-zone"
};
function render$1$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_node = resolveComponent("el-cascader-node");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return openBlock(), createBlock(_component_el_scrollbar, {
    key: _ctx.menuId,
    tag: "ul",
    role: "menu",
    class: "el-cascader-menu",
    "wrap-class": "el-cascader-menu__wrap",
    "view-class": ["el-cascader-menu__list", _ctx.isEmpty && "is-empty"],
    onMousemove: _ctx.handleMouseMove,
    onMouseleave: _ctx.clearHoverZone
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodes, (node) => {
        return openBlock(), createBlock(_component_el_cascader_node, {
          key: node.uid,
          node,
          "menu-id": _ctx.menuId,
          onExpand: _ctx.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]);
      }), 128)),
      _ctx.isEmpty ? (openBlock(), createElementBlock("div", _hoisted_1$I, toDisplayString(_ctx.t("el.cascader.noData")), 1)) : _ctx.panel.isHoverMenu ? (openBlock(), createElementBlock("svg", _hoisted_2$z, null, 512)) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["view-class", "onMousemove", "onMouseleave"]);
}
script$1$a.render = render$1$a;
script$1$a.__file = "packages/components/cascader-panel/src/menu.vue";
var ExpandTrigger;
(function(ExpandTrigger2) {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
})(ExpandTrigger || (ExpandTrigger = {}));
let uid = 0;
const calculatePathNodes = (node) => {
  const nodes = [node];
  let { parent } = node;
  while (parent) {
    nodes.unshift(parent);
    parent = parent.parent;
  }
  return nodes;
};
class Node$1 {
  constructor(data, config, parent, root2 = false) {
    this.data = data;
    this.config = config;
    this.parent = parent;
    this.root = root2;
    this.uid = uid++;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    const { value: valueKey, label: labelKey, children: childrenKey } = config;
    const childrenData = data[childrenKey];
    const pathNodes = calculatePathNodes(this);
    this.level = root2 ? 0 : parent ? parent.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map((node) => node.value);
    this.pathLabels = pathNodes.map((node) => node.label);
    this.childrenData = childrenData;
    this.children = (childrenData || []).map((child) => new Node$1(child, config, this));
    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
  }
  get isDisabled() {
    const { data, parent, config } = this;
    const { disabled: disabled2, checkStrictly } = config;
    const isDisabled = isFunction$3(disabled2) ? disabled2(data, this) : !!data[disabled2];
    return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
  }
  get isLeaf() {
    const { data, config, childrenData, loaded } = this;
    const { lazy, leaf } = config;
    const isLeaf2 = isFunction$3(leaf) ? leaf(data, this) : data[leaf];
    return isUndefined(isLeaf2) ? lazy && !loaded ? false : !Array.isArray(childrenData) : !!isLeaf2;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(childData) {
    const { childrenData, children } = this;
    const node = new Node$1(childData, this.config, this);
    if (Array.isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }
    children.push(node);
    return node;
  }
  calcText(allLevels, separator) {
    const text = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text;
    return text;
  }
  broadcast(event, ...args) {
    const handlerName = `onParent${capitalize(event)}`;
    this.children.forEach((child) => {
      if (child) {
        child.broadcast(event, ...args);
        child[handlerName] && child[handlerName](...args);
      }
    });
  }
  emit(event, ...args) {
    const { parent } = this;
    const handlerName = `onChild${capitalize(event)}`;
    if (parent) {
      parent[handlerName] && parent[handlerName](...args);
      parent.emit(event, ...args);
    }
  }
  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }
  onChildCheck() {
    const { children } = this;
    const validChildren = children.filter((child) => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked);
  }
  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c2, p2) => {
      const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
      return c2 + num;
    }, 0);
    this.checked = this.loaded && this.children.every((child) => child.loaded && child.checked) && checked;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  }
  doCheck(checked) {
    if (this.checked === checked)
      return;
    const { checkStrictly, multiple: multiple2 } = this.config;
    if (checkStrictly || !multiple2) {
      this.checked = checked;
    } else {
      this.broadcast("check", checked);
      this.setCheckState(checked);
      this.emit("check");
    }
  }
}
const flatNodes = (nodes, leafOnly) => {
  return nodes.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }
    return res;
  }, []);
};
class Store {
  constructor(data, config) {
    this.config = config;
    const nodes = (data || []).map((nodeData) => new Node$1(nodeData, this.config));
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  }
  appendNode(nodeData, parentNode) {
    const node = parentNode ? parentNode.appendChild(nodeData) : new Node$1(nodeData, this.config);
    if (!parentNode)
      this.nodes.push(node);
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
  }
  appendNodes(nodeDataList, parentNode) {
    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
  }
  getNodeByValue(value, leafOnly = false) {
    if (!value && value !== 0)
      return null;
    const nodes = this.getFlattedNodes(leafOnly).filter((node) => isEqual_1(node.value, value) || isEqual_1(node.pathValues, value));
    return nodes[0] || null;
  }
  getSameNode(node) {
    if (!node)
      return null;
    const nodes = this.getFlattedNodes(false).filter(({ value, level }) => isEqual_1(node.value, value) && node.level === level);
    return nodes[0] || null;
  }
}
var __defProp$1$3 = Object.defineProperty;
var __getOwnPropSymbols$1$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$3 = (obj, key2, value) => key2 in obj ? __defProp$1$3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1$3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1$3.call(b2, prop))
      __defNormalProp$1$3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1$3)
    for (var prop of __getOwnPropSymbols$1$3(b2)) {
      if (__propIsEnum$1$3.call(b2, prop))
        __defNormalProp$1$3(a2, prop, b2[prop]);
    }
  return a2;
};
const CommonProps = {
  modelValue: [Number, String, Array],
  options: {
    type: Array,
    default: () => []
  },
  props: {
    type: Object,
    default: () => ({})
  }
};
const DefaultProps = {
  expandTrigger: ExpandTrigger.CLICK,
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
};
const useCascaderConfig = (props2) => {
  return computed(() => __spreadValues$1$3(__spreadValues$1$3({}, DefaultProps), props2.props));
};
const isLeaf = (el) => !el.getAttribute("aria-owns");
const getSibling = (el, distance) => {
  const { parentNode } = el;
  if (!parentNode)
    return null;
  const siblings = parentNode.querySelectorAll('.el-cascader-node[tabindex="-1"]');
  const index2 = Array.prototype.indexOf.call(siblings, el);
  return siblings[index2 + distance] || null;
};
const getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
const focusNode = (el) => {
  if (!el)
    return;
  el.focus();
  !isLeaf(el) && el.click();
};
const checkNode = (el) => {
  if (!el)
    return;
  const input = el.querySelector("input");
  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
const sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node) => node.uid);
  const res = oldNodes.reduce((acc, item) => {
    const index2 = newIds.indexOf(item.uid);
    if (index2 > -1) {
      acc.push(item);
      newNodesCopy.splice(index2, 1);
      newIds.splice(index2, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};
var __defProp$e = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key2, value) => key2 in obj ? __defProp$e(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$e = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$e.call(b2, prop))
      __defNormalProp$e(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b2)) {
      if (__propIsEnum$e.call(b2, prop))
        __defNormalProp$e(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$9 = (a2, b2) => __defProps$9(a2, __getOwnPropDescs$9(b2));
var script$l = defineComponent({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: script$1$a
  },
  props: __spreadProps$9(__spreadValues$e({}, CommonProps), {
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  }),
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "close", "expand-change"],
  setup(props2, { emit: emit2, slots }) {
    let initialLoaded = true;
    let manualChecked = false;
    const config = useCascaderConfig(props2);
    const store = ref(null);
    const menuList = ref([]);
    const checkedValue = ref(null);
    const menus = ref([]);
    const expandingNode = ref(null);
    const checkedNodes = ref([]);
    const isHoverMenu = computed(() => config.value.expandTrigger === ExpandTrigger.HOVER);
    const renderLabelFn = computed(() => props2.renderLabel || slots.default);
    let oldConfig;
    let oldOptions;
    const initStore = () => {
      const { options: options2 } = props2;
      const cfg = config.value;
      const configTemp = config;
      if (oldOptions === void 0 || oldOptions !== options2 || oldConfig === void 0 || configTemp !== oldConfig) {
        manualChecked = false;
        store.value = new Store(options2, cfg);
        menus.value = [store.value.getNodes()];
        if (cfg.lazy && isEmpty(props2.options)) {
          initialLoaded = false;
          lazyLoad(null, () => {
            initialLoaded = true;
            syncCheckedValue(false, true);
          });
        } else {
          syncCheckedValue(false, true);
        }
      }
      oldConfig = configTemp;
      oldOptions = options2;
    };
    const lazyLoad = (node, cb) => {
      const cfg = config.value;
      node = node || new Node$1({}, cfg, null, true);
      node.loading = true;
      const resolve = (dataList) => {
        const parent = node.root ? null : node;
        dataList && store.value.appendNodes(dataList, parent);
        node.loading = false;
        node.loaded = true;
        node.childrenData = node.childrenData || [];
        cb && cb(dataList);
      };
      cfg.lazyLoad(node, resolve);
    };
    const expandNode = (node, silent) => {
      var _a;
      const { level } = node;
      const newMenus = menus.value.slice(0, level);
      let newExpandingNode;
      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }
      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit2("expand-change", (node == null ? void 0 : node.pathValues) || []);
      }
    };
    const handleCheckChange = (node, checked, emitClose = true) => {
      const { checkStrictly, multiple: multiple2 } = config.value;
      const oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple2 && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked);
      calculateCheckedValue();
      emitClose && !multiple2 && !checkStrictly && emit2("close");
    };
    const getFlattedNodes = (leafOnly) => {
      return store.value.getFlattedNodes(leafOnly);
    };
    const getCheckedNodes = (leafOnly) => {
      return getFlattedNodes(leafOnly).filter((node) => node.checked !== false);
    };
    const clearCheckedNodes = () => {
      checkedNodes.value.forEach((node) => node.doCheck(false));
      calculateCheckedValue();
    };
    const calculateCheckedValue = () => {
      var _a;
      const { checkStrictly, multiple: multiple2 } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = getCheckedNodes(!checkStrictly);
      const nodes = sortByOriginalOrder(oldNodes, newNodes);
      const values = nodes.map((node) => node.valueByOption);
      checkedNodes.value = nodes;
      checkedValue.value = multiple2 ? values : (_a = values[0]) != null ? _a : null;
    };
    const syncCheckedValue = (loaded = false, forced = false) => {
      const { modelValue } = props2;
      const { lazy, multiple: multiple2, checkStrictly } = config.value;
      const leafOnly = !checkStrictly;
      if (!initialLoaded || manualChecked || !forced && isEqual_1(modelValue, checkedValue.value))
        return;
      if (lazy && !loaded) {
        const values = deduplicate(arrayFlat(coerceTruthyValueToArray(modelValue)));
        const nodes = values.map((val) => store.value.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
        if (nodes.length) {
          nodes.forEach((node) => {
            lazyLoad(node, () => syncCheckedValue(false, forced));
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        const values = multiple2 ? coerceTruthyValueToArray(modelValue) : [modelValue];
        const nodes = deduplicate(values.map((val) => store.value.getNodeByValue(val, leafOnly)));
        syncMenuState(nodes, false);
        checkedValue.value = modelValue;
      }
    };
    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
      const { checkStrictly } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
      const oldExpandingNode = store.value.getSameNode(expandingNode.value);
      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
      } else {
        expandingNode.value = null;
      }
      oldNodes.forEach((node) => node.doCheck(false));
      newNodes.forEach((node) => node.doCheck(true));
      checkedNodes.value = newNodes;
      nextTick(scrollToExpandingNode);
    };
    const scrollToExpandingNode = () => {
      if (isServer)
        return;
      menuList.value.forEach((menu) => {
        const menuElement = menu == null ? void 0 : menu.$el;
        if (menuElement) {
          const container = menuElement.querySelector(".el-scrollbar__wrap");
          const activeNode = menuElement.querySelector(".el-cascader-node.is-active") || menuElement.querySelector(".el-cascader-node.in-active-path");
          scrollIntoView(container, activeNode);
        }
      });
    };
    const handleKeyDown = (e) => {
      const target = e.target;
      const { code } = e;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          const distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance));
          break;
        }
        case EVENT_CODE.left: {
          const preMenu = menuList.value[getMenuIndex(target) - 1];
          const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
          focusNode(expandedNode);
          break;
        }
        case EVENT_CODE.right: {
          const nextMenu = menuList.value[getMenuIndex(target) + 1];
          const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
          focusNode(firstNode);
          break;
        }
        case EVENT_CODE.enter:
          checkNode(target);
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          emit2("close");
          break;
      }
    };
    provide(CASCADER_PANEL_INJECTION_KEY, reactive({
      config,
      expandingNode,
      checkedNodes,
      isHoverMenu,
      renderLabelFn,
      lazyLoad,
      expandNode,
      handleCheckChange
    }));
    watch([config, () => props2.options], () => initStore(), {
      deep: true,
      immediate: true
    });
    watch(() => props2.modelValue, () => {
      manualChecked = false;
      syncCheckedValue();
    });
    watch(checkedValue, (val) => {
      if (!isEqual_1(val, props2.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(CHANGE_EVENT, val);
      }
    });
    onBeforeUpdate(() => menuList.value = []);
    onMounted(() => !isEmpty(props2.modelValue) && syncCheckedValue());
    return {
      menuList,
      menus,
      checkedNodes,
      handleKeyDown,
      handleCheckChange,
      getFlattedNodes,
      getCheckedNodes,
      clearCheckedNodes,
      calculateCheckedValue,
      scrollToExpandingNode
    };
  }
});
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_menu = resolveComponent("el-cascader-menu");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-cascader-panel", _ctx.border && "is-bordered"]),
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (menu, index2) => {
      return openBlock(), createBlock(_component_el_cascader_menu, {
        key: index2,
        ref: (item) => _ctx.menuList[index2] = item,
        index: index2,
        nodes: menu
      }, null, 8, ["index", "nodes"]);
    }), 128))
  ], 34);
}
script$l.render = render$l;
script$l.__file = "packages/components/cascader-panel/src/index.vue";
script$l.install = (app) => {
  app.component(script$l.name, script$l);
};
const _CascaderPanel = script$l;
const tagProps = {
  closable: Boolean,
  type: buildProp({
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  }),
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: buildProp({
    type: String,
    values: ["medium", "small", "mini"]
  }),
  effect: buildProp({
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  })
};
const tagEmits = {
  close: (evt) => evt instanceof MouseEvent,
  click: (evt) => evt instanceof MouseEvent
};
var script$k = defineComponent({
  name: "ElTag",
  props: tagProps,
  emits: tagEmits,
  setup(props2, { emit: emit2 }) {
    const ELEMENT = useGlobalConfig();
    const tagSize = computed(() => props2.size || ELEMENT.size);
    const classes = computed(() => {
      const { type: type4, hit, effect: effect2 } = props2;
      return [
        "el-tag",
        type4 ? `el-tag--${type4}` : "",
        tagSize.value ? `el-tag--${tagSize.value}` : "",
        effect2 ? `el-tag--${effect2}` : "",
        hit && "is-hit"
      ];
    });
    const handleClose = (event) => {
      event.stopPropagation();
      emit2("close", event);
    };
    const handleClick = (event) => {
      emit2("click", event);
    };
    return {
      classes,
      handleClose,
      handleClick
    };
  }
});
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return !_ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle({ backgroundColor: _ctx.color }),
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.closable ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: "el-tag__close el-icon-close",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
    })) : createCommentVNode("v-if", true)
  ], 6)) : (openBlock(), createBlock(Transition, {
    key: 1,
    name: "el-zoom-in-center"
  }, {
    default: withCtx(() => [
      createElementVNode("span", {
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle({ backgroundColor: _ctx.color }),
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        renderSlot(_ctx.$slots, "default"),
        _ctx.closable ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "el-tag__close el-icon-close",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        })) : createCommentVNode("v-if", true)
      ], 6)
    ]),
    _: 3
  }));
}
script$k.render = render$k;
script$k.__file = "packages/components/tag/src/tag.vue";
const ElTag = withInstall(script$k);
var __defProp$d = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key2, value) => key2 in obj ? __defProp$d(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$d = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$d.call(b2, prop))
      __defNormalProp$d(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b2)) {
      if (__propIsEnum$d.call(b2, prop))
        __defNormalProp$d(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$8 = (a2, b2) => __defProps$8(a2, __getOwnPropDescs$8(b2));
const DEFAULT_INPUT_HEIGHT = 40;
const INPUT_HEIGHT_MAP = {
  medium: 36,
  small: 32,
  mini: 28
};
const popperOptions = {
  modifiers: [
    {
      name: "arrowPosition",
      enabled: true,
      phase: "main",
      fn: ({ state }) => {
        const { modifiersData, placement } = state;
        if (["right", "left"].includes(placement))
          return;
        modifiersData.arrow.x = 35;
      },
      requires: ["arrow"]
    }
  ]
};
var script$j = defineComponent({
  name: "ElCascader",
  components: {
    ElCascaderPanel: _CascaderPanel,
    ElInput: _Input,
    ElPopper: _Popper,
    ElScrollbar: _Scrollbar,
    ElTag
  },
  directives: {
    Clickoutside: ClickOutside$1
  },
  props: __spreadProps$8(__spreadValues$d({}, CommonProps), {
    size: {
      type: String,
      validator: isValidComponentSize
    },
    placeholder: {
      type: String
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: Function,
      default: (node, keyword) => node.text.includes(keyword)
    },
    separator: {
      type: String,
      default: " / "
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    collapseTags: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: () => true
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    }
  }),
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "focus",
    "blur",
    "visible-change",
    "expand-change",
    "remove-tag"
  ],
  setup(props2, { emit: emit2 }) {
    let inputInitialHeight = 0;
    let pressDeleteCount = 0;
    const { t } = useLocaleInject();
    const $ELEMENT2 = useGlobalConfig();
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const popper2 = ref(null);
    const input = ref(null);
    const tagWrapper = ref(null);
    const panel = ref(null);
    const suggestionPanel = ref(null);
    const popperVisible = ref(false);
    const inputHover = ref(false);
    const filtering = ref(false);
    const inputValue = ref("");
    const searchInputValue = ref("");
    const presentTags = ref([]);
    const suggestions = ref([]);
    const isDisabled = computed(() => props2.disabled || elForm2.disabled);
    const inputPlaceholder = computed(() => props2.placeholder || t("el.cascader.placeholder"));
    const realSize = computed(() => props2.size || elFormItem2.size || $ELEMENT2.size);
    const tagSize = computed(() => ["small", "mini"].includes(realSize.value) ? "mini" : "small");
    const multiple2 = computed(() => !!props2.props.multiple);
    const readonly = computed(() => !props2.filterable || multiple2.value);
    const searchKeyword = computed(() => multiple2.value ? searchInputValue.value : inputValue.value);
    const checkedNodes = computed(() => {
      var _a;
      return ((_a = panel.value) == null ? void 0 : _a.checkedNodes) || [];
    });
    const clearBtnVisible = computed(() => {
      if (!props2.clearable || isDisabled.value || filtering.value || !inputHover.value)
        return false;
      return !!checkedNodes.value.length;
    });
    const presentText = computed(() => {
      const { showAllLevels, separator } = props2;
      const nodes = checkedNodes.value;
      return nodes.length ? multiple2.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
    });
    const checkedValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        var _a;
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(CHANGE_EVENT, val);
        (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
      }
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = popper2.value) == null ? void 0 : _a.popperRef;
    });
    const togglePopperVisible = (visible) => {
      if (isDisabled.value)
        return;
      visible = visible != null ? visible : !popperVisible.value;
      if (visible !== popperVisible.value) {
        popperVisible.value = visible;
        input.value.input.setAttribute("aria-expanded", visible);
        if (visible) {
          updatePopperPosition();
          nextTick(panel.value.scrollToExpandingNode);
        } else if (props2.filterable) {
          const { value } = presentText;
          inputValue.value = value;
          searchInputValue.value = value;
        }
        emit2("visible-change", visible);
      }
    };
    const updatePopperPosition = () => {
      nextTick(popper2.value.update);
    };
    const hideSuggestionPanel = () => {
      filtering.value = false;
    };
    const genTag2 = (node) => {
      const { showAllLevels, separator } = props2;
      return {
        node,
        key: node.uid,
        text: node.calcText(showAllLevels, separator),
        hitState: false,
        closable: !isDisabled.value && !node.isDisabled
      };
    };
    const deleteTag = (tag) => {
      const { node } = tag;
      node.doCheck(false);
      panel.value.calculateCheckedValue();
      emit2("remove-tag", node.valueByOption);
    };
    const calculatePresentTags = () => {
      if (!multiple2.value)
        return;
      const nodes = checkedNodes.value;
      const tags2 = [];
      if (nodes.length) {
        const [first, ...rest] = nodes;
        const restCount = rest.length;
        tags2.push(genTag2(first));
        if (restCount) {
          if (props2.collapseTags) {
            tags2.push({
              key: -1,
              text: `+ ${restCount}`,
              closable: false
            });
          } else {
            rest.forEach((node) => tags2.push(genTag2(node)));
          }
        }
      }
      presentTags.value = tags2;
    };
    const calculateSuggestions = () => {
      const { filterMethod, showAllLevels, separator } = props2;
      const res = panel.value.getFlattedNodes(!props2.props.checkStrictly).filter((node) => {
        if (node.isDisabled)
          return false;
        node.calcText(showAllLevels, separator);
        return filterMethod(node, searchKeyword.value);
      });
      if (multiple2.value) {
        presentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
      }
      filtering.value = true;
      suggestions.value = res;
      updatePopperPosition();
    };
    const focusFirstNode = () => {
      var _a;
      let firstNode = null;
      if (filtering.value && suggestionPanel.value) {
        firstNode = suggestionPanel.value.$el.querySelector(".el-cascader__suggestion-item");
      } else {
        firstNode = (_a = panel.value) == null ? void 0 : _a.$el.querySelector('.el-cascader-node[tabindex="-1"]');
      }
      if (firstNode) {
        firstNode.focus();
        !filtering.value && firstNode.click();
      }
    };
    const updateStyle = () => {
      var _a;
      const inputInner = input.value.input;
      const tagWrapperEl = tagWrapper.value;
      const suggestionPanelEl = (_a = suggestionPanel.value) == null ? void 0 : _a.$el;
      if (isServer || !inputInner)
        return;
      if (suggestionPanelEl) {
        const suggestionList = suggestionPanelEl.querySelector(".el-cascader__suggestion-list");
        suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
      }
      if (tagWrapperEl) {
        const { offsetHeight } = tagWrapperEl;
        const height2 = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
        inputInner.style.height = height2;
        updatePopperPosition();
      }
    };
    const getCheckedNodes = (leafOnly) => {
      return panel.value.getCheckedNodes(leafOnly);
    };
    const handleExpandChange = (value) => {
      updatePopperPosition();
      emit2("expand-change", value);
    };
    const handleKeyDown = (e) => {
      switch (e.code) {
        case EVENT_CODE.enter:
          togglePopperVisible();
          break;
        case EVENT_CODE.down:
          togglePopperVisible(true);
          nextTick(focusFirstNode);
          e.preventDefault();
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };
    const handleClear = () => {
      panel.value.clearCheckedNodes();
      togglePopperVisible(false);
    };
    const handleSuggestionClick = (node) => {
      const { checked } = node;
      if (multiple2.value) {
        panel.value.handleCheckChange(node, !checked, false);
      } else {
        !checked && panel.value.handleCheckChange(node, true, false);
        togglePopperVisible(false);
      }
    };
    const handleDelete = () => {
      const tags2 = presentTags.value;
      const lastTag = tags2[tags2.length - 1];
      pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
      if (!lastTag || !pressDeleteCount)
        return;
      if (lastTag.hitState) {
        deleteTag(lastTag);
      } else {
        lastTag.hitState = true;
      }
    };
    const handleFilter = debounce_1(() => {
      const { value } = searchKeyword;
      if (!value)
        return;
      const passed = props2.beforeFilter(value);
      if (isPromise(passed)) {
        passed.then(calculateSuggestions).catch(() => {
        });
      } else if (passed !== false) {
        calculateSuggestions();
      } else {
        hideSuggestionPanel();
      }
    }, props2.debounce);
    const handleInput = (val, e) => {
      !popperVisible.value && togglePopperVisible(true);
      if (e == null ? void 0 : e.isComposing)
        return;
      val ? handleFilter() : hideSuggestionPanel();
    };
    watch(filtering, updatePopperPosition);
    watch([checkedNodes, isDisabled], calculatePresentTags);
    watch(presentTags, () => nextTick(updateStyle));
    watch(presentText, (val) => inputValue.value = val, { immediate: true });
    onMounted(() => {
      const inputEl = input.value.$el;
      inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
      addResizeListener(inputEl, updateStyle);
    });
    onBeforeUnmount(() => {
      removeResizeListener(input.value.$el, updateStyle);
    });
    return {
      Effect,
      popperOptions,
      popper: popper2,
      popperPaneRef,
      input,
      tagWrapper,
      panel,
      suggestionPanel,
      popperVisible,
      inputHover,
      inputPlaceholder,
      filtering,
      presentText,
      checkedValue,
      inputValue,
      searchInputValue,
      presentTags,
      suggestions,
      isDisabled,
      realSize,
      tagSize,
      multiple: multiple2,
      readonly,
      clearBtnVisible,
      t,
      togglePopperVisible,
      hideSuggestionPanel,
      deleteTag,
      focusFirstNode,
      getCheckedNodes,
      handleExpandChange,
      handleKeyDown,
      handleClear,
      handleSuggestionClick,
      handleDelete,
      handleInput
    };
  }
});
const _hoisted_1$H = {
  key: 0,
  ref: "tagWrapper",
  class: "el-cascader__tags"
};
const _hoisted_2$y = ["placeholder"];
const _hoisted_3$t = ["onClick"];
const _hoisted_4$l = {
  key: 0,
  class: "el-icon-check"
};
const _hoisted_5$h = { class: "el-cascader__empty-text" };
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.popperVisible,
    "onUpdate:visible": _cache[15] || (_cache[15] = ($event) => _ctx.popperVisible = $event),
    "manual-mode": "",
    "append-to-body": _ctx.popperAppendToBody,
    placement: "bottom-start",
    "popper-class": `el-cascader__dropdown ${_ctx.popperClass}`,
    "popper-options": _ctx.popperOptions,
    "fallback-placements": ["bottom-start", "top-start", "right", "left"],
    "stop-popper-mouse-event": false,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    effect: _ctx.Effect.LIGHT,
    pure: "",
    onAfterLeave: _ctx.hideSuggestionPanel
  }, {
    trigger: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: normalizeClass([
          "el-cascader",
          _ctx.realSize && `el-cascader--${_ctx.realSize}`,
          { "is-disabled": _ctx.isDisabled }
        ]),
        onClick: _cache[9] || (_cache[9] = () => _ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)),
        onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
        onMouseenter: _cache[11] || (_cache[11] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[12] || (_cache[12] = ($event) => _ctx.inputHover = false)
      }, [
        createVNode(_component_el_input, {
          ref: "input",
          modelValue: _ctx.inputValue,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
          modelModifiers: { trim: true },
          placeholder: _ctx.inputPlaceholder,
          readonly: _ctx.readonly,
          disabled: _ctx.isDisabled,
          "validate-event": false,
          size: _ctx.realSize,
          class: normalizeClass({ "is-focus": _ctx.popperVisible }),
          onFocus: _cache[3] || (_cache[3] = (e) => _ctx.$emit("focus", e)),
          onBlur: _cache[4] || (_cache[4] = (e) => _ctx.$emit("blur", e)),
          onInput: _ctx.handleInput
        }, {
          suffix: withCtx(() => [
            _ctx.clearBtnVisible ? (openBlock(), createElementBlock("i", {
              key: "clear",
              class: "el-input__icon el-icon-circle-close",
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
            })) : (openBlock(), createElementBlock("i", {
              key: "arrow-down",
              class: normalizeClass([
                "el-input__icon",
                "el-icon-arrow-down",
                _ctx.popperVisible && "is-reverse"
              ]),
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.togglePopperVisible(), ["stop"]))
            }, null, 2))
          ]),
          _: 1
        }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onInput"]),
        _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.presentTags, (tag) => {
            return openBlock(), createBlock(_component_el_tag, {
              key: tag.key,
              type: "info",
              size: _ctx.tagSize,
              hit: tag.hitState,
              closable: tag.closable,
              "disable-transitions": "",
              onClose: ($event) => _ctx.deleteTag(tag)
            }, {
              default: withCtx(() => [
                createElementVNode("span", null, toDisplayString(tag.text), 1)
              ]),
              _: 2
            }, 1032, ["size", "hit", "closable", "onClose"]);
          }), 128)),
          _ctx.filterable && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.searchInputValue = $event),
            type: "text",
            class: "el-cascader__search-input",
            placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
            onInput: _cache[6] || (_cache[6] = (e) => _ctx.handleInput(_ctx.searchInputValue, e)),
            onClick: _cache[7] || (_cache[7] = withModifiers(($event) => _ctx.togglePopperVisible(true), ["stop"])),
            onKeydown: _cache[8] || (_cache[8] = withKeys((...args) => _ctx.handleDelete && _ctx.handleDelete(...args), ["delete"]))
          }, null, 40, _hoisted_2$y)), [
            [
              vModelText,
              _ctx.searchInputValue,
              void 0,
              { trim: true }
            ]
          ]) : createCommentVNode("v-if", true)
        ], 512)) : createCommentVNode("v-if", true)
      ], 34), [
        [_directive_clickoutside, () => _ctx.togglePopperVisible(false), _ctx.popperPaneRef]
      ])
    ]),
    default: withCtx(() => [
      withDirectives(createVNode(_component_el_cascader_panel, {
        ref: "panel",
        modelValue: _ctx.checkedValue,
        "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.checkedValue = $event),
        options: _ctx.options,
        props: _ctx.props,
        border: false,
        "render-label": _ctx.$slots.default,
        onExpandChange: _ctx.handleExpandChange,
        onClose: _cache[14] || (_cache[14] = ($event) => _ctx.togglePopperVisible(false))
      }, null, 8, ["modelValue", "options", "props", "render-label", "onExpandChange"]), [
        [vShow, !_ctx.filtering]
      ]),
      _ctx.filterable ? withDirectives((openBlock(), createBlock(_component_el_scrollbar, {
        key: 0,
        ref: "suggestionPanel",
        tag: "ul",
        class: "el-cascader__suggestion-panel",
        "view-class": "el-cascader__suggestion-list"
      }, {
        default: withCtx(() => [
          _ctx.suggestions.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.suggestions, (item) => {
            return openBlock(), createElementBlock("li", {
              key: item.uid,
              class: normalizeClass([
                "el-cascader__suggestion-item",
                item.checked && "is-checked"
              ]),
              tabindex: -1,
              onClick: ($event) => _ctx.handleSuggestionClick(item)
            }, [
              createElementVNode("span", null, toDisplayString(item.text), 1),
              item.checked ? (openBlock(), createElementBlock("i", _hoisted_4$l)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_3$t);
          }), 128)) : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
            createElementVNode("li", _hoisted_5$h, toDisplayString(_ctx.t("el.cascader.noMatch")), 1)
          ])
        ]),
        _: 3
      }, 512)), [
        [vShow, _ctx.filtering]
      ]) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["visible", "append-to-body", "popper-class", "popper-options", "effect", "onAfterLeave"]);
}
script$j.render = render$j;
script$j.__file = "packages/components/cascader/src/index.vue";
script$j.install = (app) => {
  app.component(script$j.name, script$j);
};
const _Cascader = script$j;
const ElCascader = _Cascader;
const ElCol$1 = defineComponent({
  name: "ElCol",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: [Number, Object],
      default: () => ({})
    },
    sm: {
      type: [Number, Object],
      default: () => ({})
    },
    md: {
      type: [Number, Object],
      default: () => ({})
    },
    lg: {
      type: [Number, Object],
      default: () => ({})
    },
    xl: {
      type: [Number, Object],
      default: () => ({})
    }
  },
  setup(props2, { slots }) {
    const { gutter: gutter2 } = inject("ElRow", { gutter: { value: 0 } });
    const style = computed(() => {
      if (gutter2.value) {
        return {
          paddingLeft: `${gutter2.value / 2}px`,
          paddingRight: `${gutter2.value / 2}px`
        };
      }
      return {};
    });
    const classList = computed(() => {
      const ret = [];
      const pos = ["span", "offset", "pull", "push"];
      pos.forEach((prop) => {
        const size2 = props2[prop];
        if (typeof size2 === "number") {
          if (prop === "span")
            ret.push(`el-col-${props2[prop]}`);
          else if (size2 > 0)
            ret.push(`el-col-${prop}-${props2[prop]}`);
        }
      });
      const sizes2 = ["xs", "sm", "md", "lg", "xl"];
      sizes2.forEach((size2) => {
        if (typeof props2[size2] === "number") {
          ret.push(`el-col-${size2}-${props2[size2]}`);
        } else if (typeof props2[size2] === "object") {
          const sizeProps = props2[size2];
          Object.keys(sizeProps).forEach((prop) => {
            ret.push(prop !== "span" ? `el-col-${size2}-${prop}-${sizeProps[prop]}` : `el-col-${size2}-${sizeProps[prop]}`);
          });
        }
      });
      if (gutter2.value) {
        ret.push("is-guttered");
      }
      return ret;
    });
    return () => {
      var _a;
      return h$1(props2.tag, {
        class: ["el-col", classList.value],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const _Col = ElCol$1;
_Col.install = (app) => {
  app.component(_Col.name, _Col);
};
const ElCol = _Col;
let isDragging = false;
function draggable(element, options2) {
  if (isServer)
    return;
  const moveFn = function(event) {
    var _a;
    (_a = options2.drag) == null ? void 0 : _a.call(options2, event);
  };
  const upFn = function(event) {
    var _a;
    off(document, "mousemove", moveFn);
    off(document, "mouseup", upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    (_a = options2.end) == null ? void 0 : _a.call(options2, event);
  };
  on(element, "mousedown", function(event) {
    var _a;
    if (isDragging)
      return;
    document.onselectstart = () => false;
    document.ondragstart = () => false;
    on(document, "mousemove", moveFn);
    on(document, "mouseup", upFn);
    isDragging = true;
    (_a = options2.start) == null ? void 0 : _a.call(options2, event);
  });
}
var script$4$2 = defineComponent({
  name: "ElColorAlphaSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const thumb = shallowRef(null);
    const bar = shallowRef(null);
    const thumbLeft = ref(0);
    const thumbTop = ref(0);
    const background = ref(null);
    watch(() => props2.color.get("alpha"), () => {
      update();
    });
    watch(() => props2.color.value, () => {
      update();
    });
    function getThumbLeft() {
      if (props2.vertical)
        return 0;
      const el = instance.vnode.el;
      const alpha = props2.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
    }
    function getThumbTop() {
      const el = instance.vnode.el;
      if (!props2.vertical)
        return 0;
      const alpha = props2.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
    }
    function getBackground() {
      if (props2.color && props2.color.value) {
        const { r, g, b: b2 } = props2.color.toRgb();
        return `linear-gradient(to right, rgba(${r}, ${g}, ${b2}, 0) 0%, rgba(${r}, ${g}, ${b2}, 1) 100%)`;
      }
      return null;
    }
    function handleClick(event) {
      const target = event.target;
      if (target !== thumb.value) {
        handleDrag(event);
      }
    }
    function handleDrag(event) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      if (!props2.vertical) {
        let left2 = event.clientX - rect.left;
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        props2.color.set("alpha", Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
      } else {
        let top2 = event.clientY - rect.top;
        top2 = Math.max(thumb.value.offsetHeight / 2, top2);
        top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
        props2.color.set("alpha", Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
      }
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
      background.value = getBackground();
    }
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      thumb,
      bar,
      thumbLeft,
      thumbTop,
      background,
      handleClick,
      update
    };
  }
});
function render$4$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-color-alpha-slider", { "is-vertical": _ctx.vertical }])
  }, [
    createElementVNode("div", {
      ref: "bar",
      class: "el-color-alpha-slider__bar",
      style: normalizeStyle({
        background: _ctx.background
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 4),
    createElementVNode("div", {
      ref: "thumb",
      class: "el-color-alpha-slider__thumb",
      style: normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
script$4$2.render = render$4$2;
script$4$2.__file = "packages/components/color-picker/src/components/alpha-slider.vue";
var script$3$3 = defineComponent({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: Boolean
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const thumb = ref(null);
    const bar = ref(null);
    const thumbLeft = ref(0);
    const thumbTop = ref(0);
    const hueValue = computed(() => {
      return props2.color.get("hue");
    });
    watch(() => hueValue.value, () => {
      update();
    });
    function handleClick(event) {
      const target = event.target;
      if (target !== thumb.value) {
        handleDrag(event);
      }
    }
    function handleDrag(event) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      let hue;
      if (!props2.vertical) {
        let left2 = event.clientX - rect.left;
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        hue = Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
      } else {
        let top2 = event.clientY - rect.top;
        top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
        top2 = Math.max(thumb.value.offsetHeight / 2, top2);
        hue = Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
      }
      props2.color.set("hue", hue);
    }
    function getThumbLeft() {
      const el = instance.vnode.el;
      if (props2.vertical)
        return 0;
      const hue = props2.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
    }
    function getThumbTop() {
      const el = instance.vnode.el;
      if (!props2.vertical)
        return 0;
      const hue = props2.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
    }
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      bar,
      thumb,
      thumbLeft,
      thumbTop,
      hueValue,
      handleClick,
      update
    };
  }
});
function render$3$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-color-hue-slider", { "is-vertical": _ctx.vertical }])
  }, [
    createElementVNode("div", {
      ref: "bar",
      class: "el-color-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 512),
    createElementVNode("div", {
      ref: "thumb",
      class: "el-color-hue-slider__thumb",
      style: normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
script$3$3.render = render$3$3;
script$3$3.__file = "packages/components/color-picker/src/components/hue-slider.vue";
const OPTIONS_KEY = Symbol();
const useOptions = () => {
  return inject(OPTIONS_KEY);
};
const hsv2hsl = function(hue, sat, val) {
  return [
    hue,
    sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
    hue / 2
  ];
};
const isOnePointZero = function(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
};
const isPercentage = function(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
};
const bound01 = function(value, max2) {
  if (isOnePointZero(value))
    value = "100%";
  const processPercent = isPercentage(value);
  value = Math.min(max2, Math.max(0, parseFloat(`${value}`)));
  if (processPercent) {
    value = parseInt(`${value * max2}`, 10) / 100;
  }
  if (Math.abs(value - max2) < 1e-6) {
    return 1;
  }
  return value % max2 / parseFloat(max2);
};
const INT_HEX_MAP = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" };
const toHex = function({ r, g, b: b2 }) {
  const hexOne = function(value) {
    value = Math.min(Math.round(value), 255);
    const high = Math.floor(value / 16);
    const low = value % 16;
    return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
  };
  if (isNaN(r) || isNaN(g) || isNaN(b2))
    return "";
  return `#${hexOne(r)}${hexOne(g)}${hexOne(b2)}`;
};
const HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
const parseHexChannel = function(hex2) {
  if (hex2.length === 2) {
    return (HEX_INT_MAP[hex2[0].toUpperCase()] || +hex2[0]) * 16 + (HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1]);
  }
  return HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1];
};
const hsl2hsv = function(hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  let smin = sat;
  const lmin = Math.max(light, 0.01);
  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v2 = (light + sat) / 2;
  const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v2 * 100
  };
};
const rgb2hsv = function(r, g, b2) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  const max2 = Math.max(r, g, b2);
  const min2 = Math.min(r, g, b2);
  let h2;
  const v2 = max2;
  const d2 = max2 - min2;
  const s2 = max2 === 0 ? 0 : d2 / max2;
  if (max2 === min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r: {
        h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
        break;
      }
      case g: {
        h2 = (b2 - r) / d2 + 2;
        break;
      }
      case b2: {
        h2 = (r - g) / d2 + 4;
        break;
      }
    }
    h2 /= 6;
  }
  return { h: h2 * 360, s: s2 * 100, v: v2 * 100 };
};
const hsv2rgb = function(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  const i = Math.floor(h2);
  const f2 = h2 - i;
  const p2 = v2 * (1 - s2);
  const q = v2 * (1 - f2 * s2);
  const t = v2 * (1 - (1 - f2) * s2);
  const mod = i % 6;
  const r = [v2, q, p2, p2, t, v2][mod];
  const g = [t, v2, v2, q, p2, p2][mod];
  const b2 = [p2, p2, t, v2, v2, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b2 * 255)
  };
};
class Color {
  constructor(options2) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = "hex";
    this.value = "";
    options2 = options2 || {};
    for (const option2 in options2) {
      if (hasOwn(options2, option2)) {
        this[option2] = options2[option2];
      }
    }
    this.doOnChange();
  }
  set(prop, value) {
    if (arguments.length === 1 && typeof prop === "object") {
      for (const p2 in prop) {
        if (hasOwn(prop, p2)) {
          this.set(p2, prop[p2]);
        }
      }
      return;
    }
    this[`_${prop}`] = value;
    this.doOnChange();
  }
  get(prop) {
    return this[`_${prop}`];
  }
  toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  }
  fromString(value) {
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    const fromHSV = (h2, s2, v2) => {
      this._hue = Math.max(0, Math.min(360, h2));
      this._saturation = Math.max(0, Math.min(100, s2));
      this._value = Math.max(0, Math.min(100, v2));
      this.doOnChange();
    };
    if (value.indexOf("hsl") !== -1) {
      const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h2, s: s2, v: v2 } = hsl2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h2, s2, v2);
      }
    } else if (value.indexOf("hsv") !== -1) {
      const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.indexOf("rgb") !== -1) {
      const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h2, s: s2, v: v2 } = rgb2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h2, s2, v2);
      }
    } else if (value.indexOf("#") !== -1) {
      const hex2 = value.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex2))
        return;
      let r, g, b2;
      if (hex2.length === 3) {
        r = parseHexChannel(hex2[0] + hex2[0]);
        g = parseHexChannel(hex2[1] + hex2[1]);
        b2 = parseHexChannel(hex2[2] + hex2[2]);
      } else if (hex2.length === 6 || hex2.length === 8) {
        r = parseHexChannel(hex2.substring(0, 2));
        g = parseHexChannel(hex2.substring(2, 4));
        b2 = parseHexChannel(hex2.substring(4, 6));
      }
      if (hex2.length === 8) {
        this._alpha = Math.floor(parseHexChannel(hex2.substring(6)) / 255 * 100);
      } else if (hex2.length === 3 || hex2.length === 6) {
        this._alpha = 100;
      }
      const { h: h2, s: s2, v: v2 } = rgb2hsv(r, g, b2);
      fromHSV(h2, s2, v2);
    }
  }
  compare(color) {
    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue, _saturation, _value, _alpha, format: format2 } = this;
    if (this.enableAlpha) {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${_alpha / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${_alpha / 100})`;
          break;
        }
        default: {
          const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgba(${r}, ${g}, ${b2}, ${_alpha / 100})`;
        }
      }
    } else {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
          break;
        }
        case "rgb": {
          const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgb(${r}, ${g}, ${b2})`;
          break;
        }
        default: {
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
        }
      }
    }
  }
}
var script$2$5 = defineComponent({
  props: {
    colors: { type: Array, required: true },
    color: {
      type: Object,
      required: true
    }
  },
  setup(props2) {
    const { currentColor } = useOptions();
    const rgbaColors = ref(parseColors(props2.colors, props2.color));
    watch(() => currentColor.value, (val) => {
      const color = new Color();
      color.fromString(val);
      rgbaColors.value.forEach((item) => {
        item.selected = color.compare(item);
      });
    });
    watchEffect(() => {
      rgbaColors.value = parseColors(props2.colors, props2.color);
    });
    function handleSelect(index2) {
      props2.color.fromString(props2.colors[index2]);
    }
    function parseColors(colors, color) {
      return colors.map((value) => {
        const c2 = new Color();
        c2.enableAlpha = true;
        c2.format = "rgba";
        c2.fromString(value);
        c2.selected = c2.value === color.value;
        return c2;
      });
    }
    return {
      rgbaColors,
      handleSelect
    };
  }
});
const _hoisted_1$2$2 = { class: "el-color-predefine" };
const _hoisted_2$2$2 = { class: "el-color-predefine__colors" };
const _hoisted_3$2$2 = ["onClick"];
function render$2$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2$2, [
    createElementVNode("div", _hoisted_2$2$2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index2) => {
        return openBlock(), createElementBlock("div", {
          key: _ctx.colors[index2],
          class: normalizeClass(["el-color-predefine__color-selector", { selected: item.selected, "is-alpha": item._alpha < 100 }]),
          onClick: ($event) => _ctx.handleSelect(index2)
        }, [
          createElementVNode("div", {
            style: normalizeStyle({ backgroundColor: item.value })
          }, null, 4)
        ], 10, _hoisted_3$2$2);
      }), 128))
    ])
  ]);
}
script$2$5.render = render$2$4;
script$2$5.__file = "packages/components/color-picker/src/components/predefine.vue";
var script$1$9 = defineComponent({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: true
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const background = ref("hsl(0, 100%, 50%)");
    const colorValue = computed(() => {
      const hue = props2.color.get("hue");
      const value = props2.color.get("value");
      return { hue, value };
    });
    function update() {
      const saturation = props2.color.get("saturation");
      const value = props2.color.get("value");
      const el = instance.vnode.el;
      const { clientWidth: width2, clientHeight: height2 } = el;
      cursorLeft.value = saturation * width2 / 100;
      cursorTop.value = (100 - value) * height2 / 100;
      background.value = `hsl(${props2.color.get("hue")}, 100%, 50%)`;
    }
    function handleDrag(event) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      let left2 = event.clientX - rect.left;
      let top2 = event.clientY - rect.top;
      left2 = Math.max(0, left2);
      left2 = Math.min(left2, rect.width);
      top2 = Math.max(0, top2);
      top2 = Math.min(top2, rect.height);
      cursorLeft.value = left2;
      cursorTop.value = top2;
      props2.color.set({
        saturation: left2 / rect.width * 100,
        value: 100 - top2 / rect.height * 100
      });
    }
    watch(() => colorValue.value, () => {
      update();
    });
    onMounted(() => {
      draggable(instance.vnode.el, {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      });
      update();
    });
    return {
      cursorTop,
      cursorLeft,
      background,
      colorValue,
      handleDrag,
      update
    };
  }
});
const _hoisted_1$1$6 = /* @__PURE__ */ createElementVNode("div", { class: "el-color-svpanel__white" }, null, -1);
const _hoisted_2$1$5 = /* @__PURE__ */ createElementVNode("div", { class: "el-color-svpanel__black" }, null, -1);
const _hoisted_3$1$5 = /* @__PURE__ */ createElementVNode("div", null, null, -1);
const _hoisted_4$1$4 = [
  _hoisted_3$1$5
];
function render$1$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "el-color-svpanel",
    style: normalizeStyle({
      backgroundColor: _ctx.background
    })
  }, [
    _hoisted_1$1$6,
    _hoisted_2$1$5,
    createElementVNode("div", {
      class: "el-color-svpanel__cursor",
      style: normalizeStyle({
        top: _ctx.cursorTop + "px",
        left: _ctx.cursorLeft + "px"
      })
    }, _hoisted_4$1$4, 4)
  ], 4);
}
script$1$9.render = render$1$9;
script$1$9.__file = "packages/components/color-picker/src/components/sv-panel.vue";
var script$i = defineComponent({
  name: "ElColorPicker",
  components: {
    ElButton,
    ElPopper: _Popper,
    ElInput: _Input,
    SvPanel: script$1$9,
    HueSlider: script$3$3,
    AlphaSlider: script$4$2,
    Predefine: script$2$5
  },
  directives: {
    ClickOutside: ClickOutside$1
  },
  props: {
    modelValue: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    popperClass: String,
    predefine: Array
  },
  emits: ["change", "active-change", UPDATE_MODEL_EVENT],
  setup(props2, { emit: emit2 }) {
    const ELEMENT = useGlobalConfig();
    const { t } = useLocaleInject();
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const hue = ref(null);
    const svPanel = ref(null);
    const alpha = ref(null);
    const popper2 = ref(null);
    const color = reactive(new Color({
      enableAlpha: props2.showAlpha,
      format: props2.colorFormat
    }));
    const showPicker = ref(false);
    const showPanelColor = ref(false);
    const customInput = ref("");
    const displayedColor = computed(() => {
      if (!props2.modelValue && !showPanelColor.value) {
        return "transparent";
      }
      return displayedRgb(color, props2.showAlpha);
    });
    const colorSize = computed(() => {
      return props2.size || elFormItem2.size || ELEMENT.size;
    });
    const colorDisabled = computed(() => {
      return props2.disabled || elForm2.disabled;
    });
    const currentColor = computed(() => {
      return !props2.modelValue && !showPanelColor.value ? "" : color.value;
    });
    watch(() => props2.modelValue, (newVal) => {
      if (!newVal) {
        showPanelColor.value = false;
      } else if (newVal && newVal !== color.value) {
        color.fromString(newVal);
      }
    });
    watch(() => currentColor.value, (val) => {
      customInput.value = val;
      emit2("active-change", val);
    });
    watch(() => color.value, () => {
      if (!props2.modelValue && !showPanelColor.value) {
        showPanelColor.value = true;
      }
    });
    function displayedRgb(color2, showAlpha2) {
      if (!(color2 instanceof Color)) {
        throw Error("color should be instance of _color Class");
      }
      const { r, g, b: b2 } = color2.toRgb();
      return showAlpha2 ? `rgba(${r}, ${g}, ${b2}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b2})`;
    }
    function setShowPicker(value) {
      showPicker.value = value;
    }
    const debounceSetShowPicker = debounce_1(setShowPicker, 100);
    function hide2() {
      debounceSetShowPicker(false);
      resetColor();
    }
    function resetColor() {
      nextTick(() => {
        if (props2.modelValue) {
          color.fromString(props2.modelValue);
        } else {
          showPanelColor.value = false;
        }
      });
    }
    function handleTrigger() {
      if (colorDisabled.value)
        return;
      debounceSetShowPicker(!showPicker.value);
    }
    function handleConfirm() {
      color.fromString(customInput.value);
    }
    function confirmValue() {
      var _a;
      const value = color.value;
      emit2(UPDATE_MODEL_EVENT, value);
      emit2("change", value);
      (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
      debounceSetShowPicker(false);
      nextTick(() => {
        const newColor = new Color({
          enableAlpha: props2.showAlpha,
          format: props2.colorFormat
        });
        newColor.fromString(props2.modelValue);
        if (!color.compare(newColor)) {
          resetColor();
        }
      });
    }
    function clear() {
      var _a;
      debounceSetShowPicker(false);
      emit2(UPDATE_MODEL_EVENT, null);
      emit2("change", null);
      if (props2.modelValue !== null) {
        (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
      }
      resetColor();
    }
    onMounted(() => {
      if (props2.modelValue) {
        color.fromString(props2.modelValue);
        customInput.value = currentColor.value;
      }
    });
    watch(() => showPicker.value, () => {
      nextTick(() => {
        var _a, _b, _c;
        (_a = hue.value) == null ? void 0 : _a.update();
        (_b = svPanel.value) == null ? void 0 : _b.update();
        (_c = alpha.value) == null ? void 0 : _c.update();
      });
    });
    provide(OPTIONS_KEY, {
      currentColor
    });
    return {
      Effect,
      color,
      colorDisabled,
      colorSize,
      displayedColor,
      showPanelColor,
      showPicker,
      customInput,
      handleConfirm,
      hide: hide2,
      handleTrigger,
      clear,
      confirmValue,
      t,
      hue,
      svPanel,
      alpha,
      popper: popper2
    };
  }
});
const _hoisted_1$G = { class: "el-color-dropdown__main-wrapper" };
const _hoisted_2$x = { class: "el-color-dropdown__btns" };
const _hoisted_3$s = { class: "el-color-dropdown__value" };
const _hoisted_4$k = {
  key: 0,
  class: "el-color-picker__mask"
};
const _hoisted_5$g = {
  key: 0,
  class: "el-color-picker__empty el-icon-close"
};
const _hoisted_6$e = { class: "el-color-picker__icon el-icon-arrow-down" };
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hue_slider = resolveComponent("hue-slider");
  const _component_sv_panel = resolveComponent("sv-panel");
  const _component_alpha_slider = resolveComponent("alpha-slider");
  const _component_predefine = resolveComponent("predefine");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.showPicker,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.showPicker = $event),
    effect: _ctx.Effect.LIGHT,
    "manual-mode": "",
    trigger: "click",
    "show-arrow": false,
    "fallback-placements": ["bottom", "top", "right", "left"],
    offset: 0,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "popper-class": `el-color-picker__panel el-color-dropdown ${_ctx.popperClass}`,
    "stop-popper-mouse-event": false
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", null, [
        createElementVNode("div", _hoisted_1$G, [
          createVNode(_component_hue_slider, {
            ref: "hue",
            class: "hue-slider",
            color: _ctx.color,
            vertical: ""
          }, null, 8, ["color"]),
          createVNode(_component_sv_panel, {
            ref: "svPanel",
            color: _ctx.color
          }, null, 8, ["color"])
        ]),
        _ctx.showAlpha ? (openBlock(), createBlock(_component_alpha_slider, {
          key: 0,
          ref: "alpha",
          color: _ctx.color
        }, null, 8, ["color"])) : createCommentVNode("v-if", true),
        _ctx.predefine ? (openBlock(), createBlock(_component_predefine, {
          key: 1,
          ref: "predefine",
          color: _ctx.color,
          colors: _ctx.predefine
        }, null, 8, ["color", "colors"])) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_2$x, [
          createElementVNode("span", _hoisted_3$s, [
            createVNode(_component_el_input, {
              modelValue: _ctx.customInput,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customInput = $event),
              "validate-event": false,
              size: "mini",
              onKeyup: withKeys(_ctx.handleConfirm, ["enter"]),
              onBlur: _ctx.handleConfirm
            }, null, 8, ["modelValue", "onKeyup", "onBlur"])
          ]),
          createVNode(_component_el_button, {
            size: "mini",
            type: "text",
            class: "el-color-dropdown__link-btn",
            onClick: _ctx.clear
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.t("el.colorpicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["onClick"]),
          createVNode(_component_el_button, {
            plain: "",
            size: "mini",
            class: "el-color-dropdown__btn",
            onClick: _ctx.confirmValue
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.t("el.colorpicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ], 512), [
        [_directive_click_outside, _ctx.hide]
      ])
    ]),
    trigger: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass([
          "el-color-picker",
          _ctx.colorDisabled ? "is-disabled" : "",
          _ctx.colorSize ? `el-color-picker--${_ctx.colorSize}` : ""
        ])
      }, [
        _ctx.colorDisabled ? (openBlock(), createElementBlock("div", _hoisted_4$k)) : createCommentVNode("v-if", true),
        createElementVNode("div", {
          class: "el-color-picker__trigger",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrigger && _ctx.handleTrigger(...args))
        }, [
          createElementVNode("span", {
            class: normalizeClass(["el-color-picker__color", { "is-alpha": _ctx.showAlpha }])
          }, [
            createElementVNode("span", {
              class: "el-color-picker__color-inner",
              style: normalizeStyle({
                backgroundColor: _ctx.displayedColor
              })
            }, null, 4),
            !_ctx.modelValue && !_ctx.showPanelColor ? (openBlock(), createElementBlock("span", _hoisted_5$g)) : createCommentVNode("v-if", true)
          ], 2),
          withDirectives(createElementVNode("span", _hoisted_6$e, null, 512), [
            [vShow, _ctx.modelValue || _ctx.showPanelColor]
          ])
        ])
      ], 2)
    ]),
    _: 1
  }, 8, ["visible", "effect", "popper-class"]);
}
script$i.render = render$i;
script$i.__file = "packages/components/color-picker/src/index.vue";
script$i.install = (app) => {
  app.component(script$i.name, script$i);
};
const _ColorPicker = script$i;
const ElColorPicker = _ColorPicker;
var advancedFormat$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, r) {
      var n = t.prototype, s2 = n.format;
      r.en.ordinal = function(e2) {
        var t2 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
        return "[" + e2 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
      }, n.format = function(e2) {
        var t2 = this, r2 = this.$locale();
        if (!this.isValid())
          return s2.bind(this)(e2);
        var n2 = this.$utils(), a2 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return n2.s(t2.week(), e3 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t2.isoWeek(), e3 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t2.$H === 0 ? 24 : t2.$H), e3 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return s2.bind(this)(a2);
      };
    };
  });
})(advancedFormat$1);
var advancedFormat = advancedFormat$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    var e = "week", t = "year";
    return function(i, n, r) {
      var f2 = n.prototype;
      f2.week = function(i2) {
        if (i2 === void 0 && (i2 = null), i2 !== null)
          return this.add(7 * (i2 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f3 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
          if (f3.isBefore(s2))
            return 1;
        }
        var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o2 = this.diff(a2, e, true);
        return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
      }, f2.weeks = function(e2) {
        return e2 === void 0 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.weekYear = function() {
        var e2 = this.month(), t2 = this.week(), n = this.year();
        return t2 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t2 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var dayOfYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, n) {
      t.prototype.dayOfYear = function(e2) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return e2 == null ? t2 : this.add(e2 - t2, "day");
      };
    };
  });
})(dayOfYear$1);
var dayOfYear = dayOfYear$1.exports;
var isSameOrAfter$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.isSameOrAfter = function(e2, t2) {
        return this.isSame(e2, t2) || this.isAfter(e2, t2);
      };
    };
  });
})(isSameOrAfter$1);
var isSameOrAfter = isSameOrAfter$1.exports;
var isSameOrBefore$1 = { exports: {} };
(function(module, exports) {
  !function(e, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    return function(e, i) {
      i.prototype.isSameOrBefore = function(e2, i2) {
        return this.isSame(e2, i2) || this.isBefore(e2, i2);
      };
    };
  });
})(isSameOrBefore$1);
var isSameOrBefore = isSameOrBefore$1.exports;
var script$5$1 = defineComponent({
  props: {
    date: {
      type: Object
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    selectionMode: {
      type: String,
      default: "day"
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const tableRows = ref([[], [], [], [], [], []]);
    const firstDayOfWeek = props2.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props2.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
    const offsetDay = computed(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = computed(() => {
      const startDayOfMonth = props2.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = computed(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const rows2 = computed(() => {
      var _a;
      const startOfMonth = props2.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      const offset2 = offsetDay.value;
      const rows_ = tableRows.value;
      let count = 1;
      const selectedDate = props2.selectionMode === "dates" ? coerceTruthyValueToArray(props2.parsedValue) : [];
      const calNow = dayjs().locale(lang.value).startOf("day");
      for (let i = 0; i < 6; i++) {
        const row = rows_[i];
        if (props2.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: "week",
              text: startDate.value.add(i * 7 + 1, "day").week()
            };
          }
        }
        for (let j = 0; j < 7; j++) {
          let cell = row[props2.showWeekNumber ? j + 1 : j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          const index2 = i * 7 + j;
          const calTime = startDate.value.add(index2 - offset2, "day");
          cell.type = "normal";
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "day") && calEndDate && calTime.isSameOrBefore(calEndDate, "day") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "day") && calEndDate && calTime.isSameOrAfter(calEndDate, "day");
          if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "day");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "day");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "day");
            cell.end = calEndDate && calTime.isSame(calEndDate, "day");
          }
          const isToday = calTime.isSame(calNow, "day");
          if (isToday) {
            cell.type = "today";
          }
          if (i >= 0 && i <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count++;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count++;
            } else {
              cell.text = count++ - dateCountOfMonth;
              cell.type = "next-month";
            }
          }
          const cellDate = calTime.toDate();
          cell.selected = selectedDate.find((_2) => _2.valueOf() === calTime.valueOf());
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          cell.customClass = props2.cellClassName && props2.cellClassName(cellDate);
          row[props2.showWeekNumber ? j + 1 : j] = cell;
        }
        if (props2.selectionMode === "week") {
          const start2 = props2.showWeekNumber ? 1 : 0;
          const end2 = props2.showWeekNumber ? 7 : 6;
          const isActive = isWeekActive(row[start2 + 1]);
          row[start2].inRange = isActive;
          row[start2].start = isActive;
          row[end2].inRange = isActive;
          row[end2].end = isActive;
        }
      }
      return rows_;
    });
    const cellMatchesDate = (cell, date4) => {
      if (!date4)
        return false;
      return dayjs(date4).locale(lang.value).isSame(props2.date.date(Number(cell.text)), "day");
    };
    const getCellClasses = (cell) => {
      const classes = [];
      if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
        classes.push("available");
        if (cell.type === "today") {
          classes.push("today");
        }
      } else {
        classes.push(cell.type);
      }
      if (props2.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props2.parsedValue)) {
        classes.push("current");
      }
      if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props2.selectionMode === "week")) {
        classes.push("in-range");
        if (cell.start) {
          classes.push("start-date");
        }
        if (cell.end) {
          classes.push("end-date");
        }
      }
      if (cell.disabled) {
        classes.push("disabled");
      }
      if (cell.selected) {
        classes.push("selected");
      }
      if (cell.customClass) {
        classes.push(cell.customClass);
      }
      return classes.join(" ");
    };
    const getDateOfCell = (row, column) => {
      const offsetFromStart = row * 7 + (column - (props2.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };
    const handleMouseMove = (event) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      if (rows2.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };
    const handleClick = (event) => {
      let target = event.target;
      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      const cell = rows2.value[row][column];
      if (cell.disabled || cell.type === "week")
        return;
      const newDate = getDateOfCell(row, column);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx.emit("pick", { minDate: newDate, maxDate: null });
          ctx.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx.emit("select", false);
        }
      } else if (props2.selectionMode === "day") {
        ctx.emit("pick", newDate);
      } else if (props2.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value = `${newDate.year()}w${weekNumber}`;
        ctx.emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value,
          date: newDate.startOf("week")
        });
      } else if (props2.selectionMode === "dates") {
        const newValue = cell.selected ? coerceTruthyValueToArray(props2.parsedValue).filter((_2) => _2.valueOf() !== newDate.valueOf()) : coerceTruthyValueToArray(props2.parsedValue).concat([newDate]);
        ctx.emit("pick", newValue);
      }
    };
    const isWeekActive = (cell) => {
      if (props2.selectionMode !== "week")
        return false;
      let newDate = props2.date.startOf("day");
      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }
      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }
      newDate = newDate.date(parseInt(cell.text, 10));
      if (props2.parsedValue && !Array.isArray(props2.parsedValue)) {
        const dayOffset = (props2.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props2.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }
      return false;
    };
    return {
      handleMouseMove,
      t,
      rows: rows2,
      isWeekActive,
      getCellClasses,
      WEEKS,
      handleClick
    };
  }
});
const _hoisted_1$5$1 = { key: 0 };
function render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: normalizeClass(["el-date-table", { "is-week-mode": _ctx.selectionMode === "week" }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_1$5$1, toDisplayString(_ctx.t("el.datepicker.week")), 1)) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.WEEKS, (week, key2) => {
          return openBlock(), createElementBlock("th", { key: key2 }, toDisplayString(_ctx.t("el.datepicker.weeks." + week)), 1);
        }), 128))
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key2) => {
        return openBlock(), createElementBlock("tr", {
          key: key2,
          class: normalizeClass(["el-date-table__row", { current: _ctx.isWeekActive(row[1]) }])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellClasses(cell))
            }, [
              createElementVNode("div", null, [
                createElementVNode("span", null, toDisplayString(cell.text), 1)
              ])
            ], 2);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 34);
}
script$5$1.render = render$5$1;
script$5$1.__file = "packages/components/date-picker/src/date-picker-com/basic-date-table.vue";
const datesInMonth = (year, month, lang) => {
  const firstDay = dayjs().locale(lang).startOf("month").month(month).year(year);
  const numOfDays = firstDay.daysInMonth();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
var script$4$1 = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    selectionMode: {
      type: String,
      default: "month"
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    date: {
      type: Object
    },
    parsedValue: {
      type: Object
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const months = ref(props2.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
    const tableRows = ref([[], [], []]);
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const rows2 = computed(() => {
      var _a;
      const rows22 = tableRows.value;
      const now2 = dayjs().locale(lang.value).startOf("month");
      for (let i = 0; i < 3; i++) {
        const row = rows22[i];
        for (let j = 0; j < 4; j++) {
          let cell = row[j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          cell.type = "normal";
          const index2 = i * 4 + j;
          const calTime = props2.date.startOf("year").month(index2);
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month");
          if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "month");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "month");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "month");
            cell.end = calEndDate && calTime.isSame(calEndDate, "month");
          }
          const isToday = now2.isSame(calTime);
          if (isToday) {
            cell.type = "today";
          }
          cell.text = index2;
          const cellDate = calTime.toDate();
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          row[j] = cell;
        }
      }
      return rows22;
    });
    const getCellStyle = (cell) => {
      const style = {};
      const year = props2.date.year();
      const today = new Date();
      const month = cell.text;
      style.disabled = props2.disabledDate ? datesInMonth(year, month, lang.value).every(props2.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props2.parsedValue).findIndex((date4) => date4.year() === year && date4.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      if (cell.inRange) {
        style["in-range"] = true;
        if (cell.start) {
          style["start-date"] = true;
        }
        if (cell.end) {
          style["end-date"] = true;
        }
      }
      return style;
    };
    const handleMouseMove = (event) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex;
      const column = target.cellIndex;
      if (rows2.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: props2.date.startOf("year").month(row * 4 + column)
        });
      }
    };
    const handleMonthTableClick = (event) => {
      let target = event.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      if (hasClass(target, "disabled"))
        return;
      const column = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column;
      const newDate = props2.date.startOf("year").month(month);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx.emit("pick", { minDate: newDate, maxDate: null });
          ctx.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx.emit("select", false);
        }
      } else {
        ctx.emit("pick", month);
      }
    };
    return {
      handleMouseMove,
      handleMonthTableClick,
      rows: rows2,
      getCellStyle,
      t,
      months
    };
  }
});
const _hoisted_1$4$1 = { class: "cell" };
function render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-month-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key2) => {
        return openBlock(), createElementBlock("tr", { key: key2 }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellStyle(cell))
            }, [
              createElementVNode("div", null, [
                createElementVNode("a", _hoisted_1$4$1, toDisplayString(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)
              ])
            ], 2);
          }), 128))
        ]);
      }), 128))
    ])
  ], 32);
}
script$4$1.render = render$4$1;
script$4$1.__file = "packages/components/date-picker/src/date-picker-com/basic-month-table.vue";
const datesInYear = (year, lang) => {
  const firstDay = dayjs(String(year)).locale(lang).startOf("year");
  const lastDay = firstDay.endOf("year");
  const numOfDays = lastDay.dayOfYear();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
var script$3$2 = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    parsedValue: {
      type: Object
    },
    date: {
      type: Object
    }
  },
  emits: ["pick"],
  setup(props2, ctx) {
    const { lang } = useLocaleInject();
    const startYear = computed(() => {
      return Math.floor(props2.date.year() / 10) * 10;
    });
    const getCellStyle = (year) => {
      const style = {};
      const today = dayjs().locale(lang.value);
      style.disabled = props2.disabledDate ? datesInYear(year, lang.value).every(props2.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props2.parsedValue).findIndex((_2) => _2.year() === year) >= 0;
      style.today = today.year() === year;
      return style;
    };
    const handleYearTableClick = (event) => {
      const target = event.target;
      if (target.tagName === "A") {
        if (hasClass(target.parentNode, "disabled"))
          return;
        const year = target.textContent || target.innerText;
        ctx.emit("pick", Number(year));
      }
    };
    return {
      startYear,
      getCellStyle,
      handleYearTableClick
    };
  }
});
const _hoisted_1$3$1 = { class: "cell" };
const _hoisted_2$3$1 = { class: "cell" };
const _hoisted_3$3$1 = { class: "cell" };
const _hoisted_4$3$1 = { class: "cell" };
const _hoisted_5$3$1 = { class: "cell" };
const _hoisted_6$3$1 = { class: "cell" };
const _hoisted_7$3$1 = { class: "cell" };
const _hoisted_8$3$1 = { class: "cell" };
const _hoisted_9$3$1 = { class: "cell" };
const _hoisted_10$3$1 = { class: "cell" };
const _hoisted_11$2$1 = /* @__PURE__ */ createElementVNode("td", null, null, -1);
const _hoisted_12$2$1 = /* @__PURE__ */ createElementVNode("td", null, null, -1);
function render$3$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-year-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleYearTableClick && _ctx.handleYearTableClick(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 0)])
        }, [
          createElementVNode("a", _hoisted_1$3$1, toDisplayString(_ctx.startYear), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 1)])
        }, [
          createElementVNode("a", _hoisted_2$3$1, toDisplayString(_ctx.startYear + 1), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 2)])
        }, [
          createElementVNode("a", _hoisted_3$3$1, toDisplayString(_ctx.startYear + 2), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 3)])
        }, [
          createElementVNode("a", _hoisted_4$3$1, toDisplayString(_ctx.startYear + 3), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 4)])
        }, [
          createElementVNode("a", _hoisted_5$3$1, toDisplayString(_ctx.startYear + 4), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 5)])
        }, [
          createElementVNode("a", _hoisted_6$3$1, toDisplayString(_ctx.startYear + 5), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 6)])
        }, [
          createElementVNode("a", _hoisted_7$3$1, toDisplayString(_ctx.startYear + 6), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 7)])
        }, [
          createElementVNode("a", _hoisted_8$3$1, toDisplayString(_ctx.startYear + 7), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 8)])
        }, [
          createElementVNode("a", _hoisted_9$3$1, toDisplayString(_ctx.startYear + 8), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 9)])
        }, [
          createElementVNode("a", _hoisted_10$3$1, toDisplayString(_ctx.startYear + 9), 1)
        ], 2),
        _hoisted_11$2$1,
        _hoisted_12$2$1
      ])
    ])
  ]);
}
script$3$2.render = render$3$2;
script$3$2.__file = "packages/components/date-picker/src/date-picker-com/basic-year-table.vue";
const timeWithinRange = (_2, __, ___) => true;
var script$2$4 = defineComponent({
  components: {
    DateTable: script$5$1,
    ElInput: _Input,
    ElButton,
    TimePickPanel: script$1$d,
    MonthTable: script$4$1,
    YearTable: script$3$2
  },
  directives: { clickoutside: ClickOutside$1 },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    parsedValue: {
      type: [Object, Array]
    },
    format: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const innerDate = ref(dayjs().locale(lang.value));
    const month = computed(() => {
      return innerDate.value.month();
    });
    const year = computed(() => {
      return innerDate.value.year();
    });
    const selectableRange = ref([]);
    const userInputDate = ref(null);
    const userInputTime = ref(null);
    const checkDateWithinRange = (date4) => {
      return selectableRange.value.length > 0 ? timeWithinRange(date4, selectableRange.value, props2.format || "HH:mm:ss") : true;
    };
    const formatEmit = (emitDayjs) => {
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      if (showTime.value)
        return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };
    const emit2 = (value, ...args) => {
      if (!value) {
        ctx.emit("pick", value, ...args);
      } else if (Array.isArray(value)) {
        const dates = value.map(formatEmit);
        ctx.emit("pick", dates, ...args);
      } else {
        ctx.emit("pick", formatEmit(value), ...args);
      }
      userInputDate.value = null;
      userInputTime.value = null;
    };
    const handleDatePick = (value) => {
      if (selectionMode.value === "day") {
        let newDate = props2.parsedValue ? props2.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }
        innerDate.value = newDate;
        emit2(newDate, showTime.value);
      } else if (selectionMode.value === "week") {
        emit2(value.date);
      } else if (selectionMode.value === "dates") {
        emit2(value, true);
      }
    };
    const prevMonth_ = () => {
      innerDate.value = innerDate.value.subtract(1, "month");
    };
    const nextMonth_ = () => {
      innerDate.value = innerDate.value.add(1, "month");
    };
    const prevYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.subtract(10, "year");
      } else {
        innerDate.value = innerDate.value.subtract(1, "year");
      }
    };
    const nextYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.add(10, "year");
      } else {
        innerDate.value = innerDate.value.add(1, "year");
      }
    };
    const currentView = ref("date");
    const yearLabel = computed(() => {
      const yearTranslation = t("el.datepicker.year");
      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;
        if (yearTranslation) {
          return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
        }
        return `${startYear} - ${startYear + 9}`;
      }
      return `${year.value} ${yearTranslation}`;
    });
    const handleShortcutClick = (shortcut) => {
      const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValue) {
        emit2(dayjs(shortcutValue).locale(lang.value));
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const selectionMode = computed(() => {
      if (["week", "month", "year", "dates"].includes(props2.type)) {
        return props2.type;
      }
      return "day";
    });
    watch(() => selectionMode.value, (val) => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }
      currentView.value = "date";
    }, { immediate: true });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleMonthPick = (month2) => {
      innerDate.value = innerDate.value.startOf("month").month(month2);
      if (selectionMode.value === "month") {
        emit2(innerDate.value);
      } else {
        currentView.value = "date";
      }
    };
    const handleYearPick = (year2) => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit2(innerDate.value);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
      }
    };
    const showMonthPicker = () => {
      currentView.value = "month";
    };
    const showYearPicker = () => {
      currentView.value = "year";
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const footerVisible = computed(() => {
      return showTime.value || selectionMode.value === "dates";
    });
    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit2(props2.parsedValue);
      } else {
        let result = props2.parsedValue;
        if (!result) {
          const defaultTimeD = dayjs(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue();
          result = defaultTimeD.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }
        innerDate.value = result;
        emit2(result);
      }
    };
    const changeToNow = () => {
      const now2 = dayjs().locale(lang.value);
      const nowDate = now2.toDate();
      if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs().locale(lang.value);
        emit2(innerDate.value);
      }
    };
    const timeFormat = computed(() => {
      return extractTimeFormat(props2.format);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(props2.format);
    });
    const visibleTime = computed(() => {
      if (userInputTime.value)
        return userInputTime.value;
      if (!props2.parsedValue && !defaultValue2)
        return;
      return (props2.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = computed(() => {
      if (userInputDate.value)
        return userInputDate.value;
      if (!props2.parsedValue && !defaultValue2)
        return;
      return (props2.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = ref(false);
    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };
    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };
    const handleTimePick = (value, visible, first) => {
      const newDate = props2.parsedValue ? props2.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
      innerDate.value = newDate;
      emit2(innerDate.value, true);
      if (!first) {
        timePickerVisible.value = visible;
      }
    };
    const handleVisibleTimeChange = (value) => {
      const newDate = dayjs(value, timeFormat.value).locale(lang.value);
      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit2(innerDate.value, true);
      }
    };
    const handleVisibleDateChange = (value) => {
      const newDate = dayjs(value, dateFormat.value).locale(lang.value);
      if (newDate.isValid()) {
        if (disabledDate && disabledDate(newDate.toDate())) {
          return;
        }
        innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
        userInputDate.value = null;
        emit2(innerDate.value, true);
      }
    };
    const isValidValue = (date_) => {
      return date_.isValid() && (disabledDate ? !disabledDate(date_.toDate()) : true);
    };
    const formatToString = (value) => {
      if (selectionMode.value === "dates") {
        return value.map((_2) => _2.format(props2.format));
      }
      return value.format(props2.format);
    };
    const parseUserInput = (value) => {
      return dayjs(value, props2.format).locale(lang.value);
    };
    const getDefaultValue = () => {
      return dayjs(defaultValue2).locale(lang.value);
    };
    const handleKeydown = (event) => {
      const { code, keyCode } = event;
      const list = [
        EVENT_CODE.up,
        EVENT_CODE.down,
        EVENT_CODE.left,
        EVENT_CODE.right
      ];
      if (props2.visible && !timePickerVisible.value) {
        if (list.includes(code)) {
          handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }
        if (code === EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
          emit2(innerDate, false);
        }
      }
    };
    const handleKeyControl = (keyCode) => {
      const mapping = {
        year: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date4, step) => date4.setFullYear(date4.getFullYear() + step)
        },
        month: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date4, step) => date4.setMonth(date4.getMonth() + step)
        },
        week: {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: (date4, step) => date4.setDate(date4.getDate() + step * 7)
        },
        day: {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: (date4, step) => date4.setDate(date4.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();
      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map = mapping[selectionMode.value];
        map.offset(newDate, map[keyCode]);
        if (disabledDate && disabledDate(newDate)) {
          continue;
        }
        const result = dayjs(newDate).locale(lang.value);
        innerDate.value = result;
        ctx.emit("pick", result, true);
        break;
      }
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      defaultTime,
      defaultValue: defaultValue2,
      arrowControl
    } = pickerBase.props;
    watch(() => props2.parsedValue, (val) => {
      if (val) {
        if (selectionMode.value === "dates")
          return;
        if (Array.isArray(val))
          return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue();
      }
    }, { immediate: true });
    return {
      handleTimePick,
      handleTimePickClose,
      onTimePickerInputFocus,
      timePickerVisible,
      visibleTime,
      visibleDate,
      showTime,
      changeToNow,
      onConfirm,
      footerVisible,
      handleYearPick,
      showMonthPicker,
      showYearPicker,
      handleMonthPick,
      hasShortcuts,
      shortcuts,
      arrowControl,
      disabledDate,
      cellClassName,
      selectionMode,
      handleShortcutClick,
      prevYear_,
      nextYear_,
      prevMonth_,
      nextMonth_,
      innerDate,
      t,
      yearLabel,
      currentView,
      month,
      handleDatePick,
      handleVisibleTimeChange,
      handleVisibleDateChange,
      timeFormat,
      userInputTime,
      userInputDate
    };
  }
});
const _hoisted_1$2$1 = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$2$1 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$2$1 = ["onClick"];
const _hoisted_4$2$1 = { class: "el-picker-panel__body" };
const _hoisted_5$2$1 = {
  key: 0,
  class: "el-date-picker__time-header"
};
const _hoisted_6$2$1 = { class: "el-date-picker__editor-wrap" };
const _hoisted_7$2$1 = { class: "el-date-picker__editor-wrap" };
const _hoisted_8$2$1 = ["aria-label"];
const _hoisted_9$2$1 = ["aria-label"];
const _hoisted_10$2$1 = ["aria-label"];
const _hoisted_11$1$1 = ["aria-label"];
const _hoisted_12$1$1 = { class: "el-picker-panel__content" };
const _hoisted_13$1$1 = { class: "el-picker-panel__footer" };
function render$2$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_date_table = resolveComponent("date-table");
  const _component_year_table = resolveComponent("year-table");
  const _component_month_table = resolveComponent("month-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$2$1, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$2$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$2$1);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$2$1, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$2$1, [
          createElementVNode("span", _hoisted_6$2$1, [
            createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectDate"),
              "model-value": _ctx.visibleDate,
              size: "small",
              onInput: _cache[0] || (_cache[0] = (val) => _ctx.userInputDate = val),
              onChange: _ctx.handleVisibleDateChange
            }, null, 8, ["placeholder", "model-value", "onChange"])
          ]),
          withDirectives(createElementVNode("span", _hoisted_7$2$1, [
            createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectTime"),
              "model-value": _ctx.visibleTime,
              size: "small",
              onFocus: _ctx.onTimePickerInputFocus,
              onInput: _cache[1] || (_cache[1] = (val) => _ctx.userInputTime = val),
              onChange: _ctx.handleVisibleTimeChange
            }, null, 8, ["placeholder", "model-value", "onFocus", "onChange"]),
            createVNode(_component_time_pick_panel, {
              visible: _ctx.timePickerVisible,
              format: _ctx.timeFormat,
              "time-arrow-control": _ctx.arrowControl,
              "parsed-value": _ctx.innerDate,
              onPick: _ctx.handleTimePick
            }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
          ], 512), [
            [_directive_clickoutside, _ctx.handleTimePickClose]
          ])
        ])) : createCommentVNode("v-if", true),
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["el-date-picker__header", {
            "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month"
          }])
        }, [
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevYear`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prevYear_ && _ctx.prevYear_(...args))
          }, null, 8, _hoisted_8$2$1),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left",
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.prevMonth_ && _ctx.prevMonth_(...args))
          }, null, 8, _hoisted_9$2$1), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("span", {
            role: "button",
            class: "el-date-picker__header-label",
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showYearPicker && _ctx.showYearPicker(...args))
          }, toDisplayString(_ctx.yearLabel), 1),
          withDirectives(createElementVNode("span", {
            role: "button",
            class: normalizeClass(["el-date-picker__header-label", { active: _ctx.currentView === "month" }]),
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.showMonthPicker && _ctx.showMonthPicker(...args))
          }, toDisplayString(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextYear`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right",
            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.nextYear_ && _ctx.nextYear_(...args))
          }, null, 8, _hoisted_10$2$1),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right",
            onClick: _cache[7] || (_cache[7] = (...args) => _ctx.nextMonth_ && _ctx.nextMonth_(...args))
          }, null, 8, _hoisted_11$1$1), [
            [vShow, _ctx.currentView === "date"]
          ])
        ], 2), [
          [vShow, _ctx.currentView !== "time"]
        ]),
        createElementVNode("div", _hoisted_12$1$1, [
          _ctx.currentView === "date" ? (openBlock(), createBlock(_component_date_table, {
            key: 0,
            "selection-mode": _ctx.selectionMode,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleDatePick
          }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "year" ? (openBlock(), createBlock(_component_year_table, {
            key: 1,
            date: _ctx.innerDate,
            "disabled-date": _ctx.disabledDate,
            "parsed-value": _ctx.parsedValue,
            onPick: _ctx.handleYearPick
          }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "month" ? (openBlock(), createBlock(_component_month_table, {
            key: 2,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleMonthPick
          }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true)
        ])
      ])
    ]),
    withDirectives(createElementVNode("div", _hoisted_13$1$1, [
      withDirectives(createVNode(_component_el_button, {
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.changeToNow
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.now")), 1)
        ]),
        _: 1
      }, 8, ["onClick"]), [
        [vShow, _ctx.selectionMode !== "dates"]
      ]),
      createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.onConfirm
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])
    ], 512), [
      [vShow, _ctx.footerVisible && _ctx.currentView === "date"]
    ])
  ], 2);
}
script$2$4.render = render$2$3;
script$2$4.__file = "packages/components/date-picker/src/date-picker-com/panel-date-pick.vue";
var script$1$8 = defineComponent({
  directives: { clickoutside: ClickOutside$1 },
  components: { TimePickPanel: script$1$d, DateTable: script$5$1, ElInput: _Input, ElButton },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "calendar-change"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "month"));
    const minDate = ref(null);
    const maxDate = ref(null);
    const dateUserInput = ref({
      min: null,
      max: null
    });
    const timeUserInput = ref({
      min: null,
      max: null
    });
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const leftMonth = computed(() => {
      return leftDate.value.month();
    });
    const rightYear = computed(() => {
      return rightDate.value.year();
    });
    const rightMonth = computed(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const minVisibleDate = computed(() => {
      if (dateUserInput.value.min !== null)
        return dateUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = computed(() => {
      if (dateUserInput.value.max !== null)
        return dateUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = computed(() => {
      if (timeUserInput.value.min !== null)
        return timeUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = computed(() => {
      if (timeUserInput.value.max !== null)
        return timeUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = computed(() => {
      return extractTimeFormat(format2);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(format2);
    });
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
    };
    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }
    };
    const rightNextMonth = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };
    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };
    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
    };
    const enableMonthArrow = computed(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props2.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });
    const isValidValue = (value) => {
      return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const btnDisabled = computed(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };
    const formatEmit = (emitDayjs, index2) => {
      if (!emitDayjs)
        return;
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      return emitDayjs;
    };
    const handleRangePick = (val, close2 = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      ctx.emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2 || showTime.value)
        return;
      handleConfirm();
    };
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const minTimePickerVisible = ref(false);
    const maxTimePickerVisible = ref(false);
    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };
    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };
    const handleDateInput = (value, type4) => {
      dateUserInput.value[type4] = value;
      const parsedValueD = dayjs(value, dateFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (disabledDate && disabledDate(parsedValueD.toDate())) {
          return;
        }
        if (type4 === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };
    const handleDateChange = (_2, type4) => {
      dateUserInput.value[type4] = null;
    };
    const handleTimeInput = (value, type4) => {
      timeUserInput.value[type4] = value;
      const parsedValueD = dayjs(value, timeFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (type4 === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };
    const handleTimeChange = (value, type4) => {
      timeUserInput.value[type4] = null;
      if (type4 === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };
    const handleMinTimePick = (value, visible, first) => {
      if (timeUserInput.value.min)
        return;
      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        minTimePickerVisible.value = visible;
      }
      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value;
      }
    };
    const handleMaxTimePick = (value, visible, first) => {
      if (timeUserInput.value.max)
        return;
      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        maxTimePickerVisible.value = visible;
      }
      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };
    const handleClear = () => {
      leftDate.value = getDefaultValue()[0];
      rightDate.value = leftDate.value.add(1, "month");
      ctx.emit("pick", null);
    };
    const formatToString = (value) => {
      return Array.isArray(value) ? value.map((_2) => _2.format(format2)) : value.format(format2);
    };
    const parseUserInput = (value) => {
      return Array.isArray(value) ? value.map((_2) => dayjs(_2, format2).locale(lang.value)) : dayjs(value, format2).locale(lang.value);
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue2)) {
        const left2 = dayjs(defaultValue2[0]);
        let right2 = dayjs(defaultValue2[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "month");
        }
        return [left2, right2];
      } else if (defaultValue2) {
        start2 = dayjs(defaultValue2);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "month")];
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["handleClear", handleClear]);
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      format: format2,
      defaultTime,
      defaultValue: defaultValue2,
      arrowControl,
      clearable: clearable2
    } = pickerBase.props;
    watch(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const minDateMonth = minDate.value.month();
          const maxDateYear = maxDate.value.year();
          const maxDateMonth = maxDate.value.month();
          rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "month");
          if (maxDate.value) {
            rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
          }
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      cellClassName,
      minTimePickerVisible,
      maxTimePickerVisible,
      handleMinTimeClose,
      handleMaxTimeClose,
      handleShortcutClick,
      rangeState,
      minDate,
      maxDate,
      handleRangePick,
      onSelect,
      handleChangeRange,
      btnDisabled,
      enableYearArrow,
      enableMonthArrow,
      rightPrevMonth,
      rightPrevYear,
      rightNextMonth,
      rightNextYear,
      leftPrevMonth,
      leftPrevYear,
      leftNextMonth,
      leftNextYear,
      hasShortcuts,
      leftLabel,
      rightLabel,
      leftDate,
      rightDate,
      showTime,
      t,
      minVisibleDate,
      maxVisibleDate,
      minVisibleTime,
      maxVisibleTime,
      arrowControl,
      handleDateInput,
      handleDateChange,
      handleTimeInput,
      handleTimeChange,
      handleMinTimePick,
      handleMaxTimePick,
      handleClear,
      handleConfirm,
      timeFormat,
      clearable: clearable2
    };
  }
});
const _hoisted_1$1$5 = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$1$4 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$1$4 = ["onClick"];
const _hoisted_4$1$3 = { class: "el-picker-panel__body" };
const _hoisted_5$1$3 = {
  key: 0,
  class: "el-date-range-picker__time-header"
};
const _hoisted_6$1$2 = { class: "el-date-range-picker__editors-wrap" };
const _hoisted_7$1$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_8$1$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_9$1$1 = /* @__PURE__ */ createElementVNode("span", { class: "el-icon-arrow-right" }, null, -1);
const _hoisted_10$1$1 = { class: "el-date-range-picker__editors-wrap is-right" };
const _hoisted_11$3 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_12$3 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_13$2 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_14$2 = { class: "el-date-range-picker__header" };
const _hoisted_15$1 = ["disabled"];
const _hoisted_16$1 = ["disabled"];
const _hoisted_17$1 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_18$1 = { class: "el-date-range-picker__header" };
const _hoisted_19$1 = ["disabled"];
const _hoisted_20$1 = ["disabled"];
const _hoisted_21$1 = {
  key: 0,
  class: "el-picker-panel__footer"
};
function render$1$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_date_table = resolveComponent("date-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$1$5, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$1$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$1$4);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$1$3, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$1$3, [
          createElementVNode("span", _hoisted_6$1$2, [
            createElementVNode("span", _hoisted_7$1$1, [
              createVNode(_component_el_input, {
                size: "small",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startDate"),
                class: "el-date-range-picker__editor",
                "model-value": _ctx.minVisibleDate,
                onInput: _cache[0] || (_cache[0] = (val) => _ctx.handleDateInput(val, "min")),
                onChange: _cache[1] || (_cache[1] = (val) => _ctx.handleDateChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"])
            ]),
            withDirectives(createElementVNode("span", _hoisted_8$1$1, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startTime"),
                "model-value": _ctx.minVisibleTime,
                onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.minTimePickerVisible = true),
                onInput: _cache[3] || (_cache[3] = (val) => _ctx.handleTimeInput(val, "min")),
                onChange: _cache[4] || (_cache[4] = (val) => _ctx.handleTimeChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"]),
              createVNode(_component_time_pick_panel, {
                visible: _ctx.minTimePickerVisible,
                format: _ctx.timeFormat,
                "datetime-role": "start",
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.leftDate,
                onPick: _ctx.handleMinTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMinTimeClose]
            ])
          ]),
          _hoisted_9$1$1,
          createElementVNode("span", _hoisted_10$1$1, [
            createElementVNode("span", _hoisted_11$3, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endDate"),
                "model-value": _ctx.maxVisibleDate,
                readonly: !_ctx.minDate,
                onInput: _cache[5] || (_cache[5] = (val) => _ctx.handleDateInput(val, "max")),
                onChange: _cache[6] || (_cache[6] = (val) => _ctx.handleDateChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"])
            ]),
            withDirectives(createElementVNode("span", _hoisted_12$3, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endTime"),
                "model-value": _ctx.maxVisibleTime,
                readonly: !_ctx.minDate,
                onFocus: _cache[7] || (_cache[7] = ($event) => _ctx.minDate && (_ctx.maxTimePickerVisible = true)),
                onInput: _cache[8] || (_cache[8] = (val) => _ctx.handleTimeInput(val, "max")),
                onChange: _cache[9] || (_cache[9] = (val) => _ctx.handleTimeChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"]),
              createVNode(_component_time_pick_panel, {
                "datetime-role": "end",
                visible: _ctx.maxTimePickerVisible,
                format: _ctx.timeFormat,
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.rightDate,
                onPick: _ctx.handleMaxTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMaxTimeClose]
            ])
          ])
        ])) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_13$2, [
          createElementVNode("div", _hoisted_14$2, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-left",
              onClick: _cache[10] || (_cache[10] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-arrow-left",
              onClick: _cache[11] || (_cache[11] = (...args) => _ctx.leftPrevMonth && _ctx.leftPrevMonth(...args))
            }),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-right"]),
              onClick: _cache[12] || (_cache[12] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, null, 10, _hoisted_15$1)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn el-icon-arrow-right"]),
              onClick: _cache[13] || (_cache[13] = (...args) => _ctx.leftNextMonth && _ctx.leftNextMonth(...args))
            }, null, 10, _hoisted_16$1)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_17$1, [
          createElementVNode("div", _hoisted_18$1, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-left"]),
              onClick: _cache[14] || (_cache[14] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, null, 10, _hoisted_19$1)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn el-icon-arrow-left"]),
              onClick: _cache[15] || (_cache[15] = (...args) => _ctx.rightPrevMonth && _ctx.rightPrevMonth(...args))
            }, null, 10, _hoisted_20$1)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-right",
              onClick: _cache[16] || (_cache[16] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-arrow-right",
              onClick: _cache[17] || (_cache[17] = (...args) => _ctx.rightNextMonth && _ctx.rightNextMonth(...args))
            }),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ]),
    _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_21$1, [
      _ctx.clearable ? (openBlock(), createBlock(_component_el_button, {
        key: 0,
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.handleClear
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.clear")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])) : createCommentVNode("v-if", true),
      createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        disabled: _ctx.btnDisabled,
        onClick: _cache[18] || (_cache[18] = ($event) => _ctx.handleConfirm(false))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["disabled"])
    ])) : createCommentVNode("v-if", true)
  ], 2);
}
script$1$8.render = render$1$8;
script$1$8.__file = "packages/components/date-picker/src/date-picker-com/panel-date-range.vue";
var script$h = defineComponent({
  components: { MonthTable: script$4$1 },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  },
  emits: ["pick", "set-picker-option"],
  setup(props2, ctx) {
    const { t, lang } = useLocaleInject();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "year"));
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = rightDate.value.subtract(1, "year");
      }
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
      }
      rightDate.value = rightDate.value.add(1, "year");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const rightYear = computed(() => {
      return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const minDate = ref(null);
    const maxDate = ref(null);
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const handleRangePick = (val, close2 = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2)
        return;
      handleConfirm();
    };
    const isValidValue = (value) => {
      return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };
    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const formatToString = (value) => {
      return value.map((_2) => _2.format(format2));
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue2)) {
        const left2 = dayjs(defaultValue2[0]);
        let right2 = dayjs(defaultValue2[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "year");
        }
        return [left2, right2];
      } else if (defaultValue2) {
        start2 = dayjs(defaultValue2);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "year")];
    };
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    const pickerBase = inject("EP_PICKER_BASE");
    const { shortcuts, disabledDate, format: format2, defaultValue: defaultValue2 } = pickerBase.props;
    watch(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const maxDateYear = maxDate.value.year();
          rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "year");
        }
      } else {
        const defaultArr = getDefaultValue();
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      onSelect,
      handleRangePick,
      rangeState,
      handleChangeRange,
      minDate,
      maxDate,
      enableYearArrow,
      leftLabel,
      rightLabel,
      leftNextYear,
      leftPrevYear,
      rightNextYear,
      rightPrevYear,
      t,
      leftDate,
      rightDate,
      hasShortcuts,
      handleShortcutClick
    };
  }
});
const _hoisted_1$F = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$w = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$r = ["onClick"];
const _hoisted_4$j = { class: "el-picker-panel__body" };
const _hoisted_5$f = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_6$d = { class: "el-date-range-picker__header" };
const _hoisted_7$a = ["disabled"];
const _hoisted_8$6 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_9$5 = { class: "el-date-range-picker__header" };
const _hoisted_10$4 = ["disabled"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_month_table = resolveComponent("month-table");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$F, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$r);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$j, [
        createElementVNode("div", _hoisted_5$f, [
          createElementVNode("div", _hoisted_6$d, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-left",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-right"]),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, null, 10, _hoisted_7$a)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_8$6, [
          createElementVNode("div", _hoisted_9$5, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-left"]),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, null, 10, _hoisted_10$4)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-right",
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ])
  ], 2);
}
script$h.render = render$h;
script$h.__file = "packages/components/date-picker/src/date-picker-com/panel-month-range.vue";
var __defProp$c = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key2, value) => key2 in obj ? __defProp$c(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$c = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$c.call(b2, prop))
      __defNormalProp$c(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b2)) {
      if (__propIsEnum$c.call(b2, prop))
        __defNormalProp$c(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
dayjs.extend(localeData);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(dayOfYear);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
const getPanel = function(type4) {
  if (type4 === "daterange" || type4 === "datetimerange") {
    return script$1$8;
  } else if (type4 === "monthrange") {
    return script$h;
  }
  return script$2$4;
};
var DatePicker = defineComponent({
  name: "ElDatePicker",
  install: null,
  props: __spreadProps$7(__spreadValues$c({}, timePickerDefaultProps), {
    type: {
      type: String,
      default: "date"
    }
  }),
  emits: ["update:modelValue"],
  setup(props2, ctx) {
    provide("ElPopperOptions", props2.popperOptions);
    const commonPicker = ref(null);
    const refProps = __spreadProps$7(__spreadValues$c({}, props2), {
      focus: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
      }
    });
    ctx.expose(refProps);
    return () => {
      var _a;
      const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_DATEPICKER[props2.type] || DEFAULT_FORMATS_DATE;
      return h$1(script$3$4, __spreadProps$7(__spreadValues$c({}, props2), {
        format: format2,
        type: props2.type,
        ref: commonPicker,
        "onUpdate:modelValue": (value) => ctx.emit("update:modelValue", value)
      }), {
        default: (scopedProps) => h$1(getPanel(props2.type), scopedProps)
      });
    };
  }
});
const _DatePicker = DatePicker;
_DatePicker.install = (app) => {
  app.component(_DatePicker.name, _DatePicker);
};
const ElDatePicker = _DatePicker;
const overlayProps = {
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: {
    type: Boolean,
    default: false
  },
  overlayClass: buildProp({
    type: definePropType([
      String,
      Array,
      Object
    ])
  }),
  zIndex: buildProp({
    type: definePropType([String, Number])
  })
};
const overlayEmits = {
  click: (evt) => evt instanceof MouseEvent
};
var Overlay = defineComponent({
  name: "ElOverlay",
  props: overlayProps,
  emits: overlayEmits,
  setup(props2, { slots, emit: emit2 }) {
    const onMaskClick = (e) => {
      emit2("click", e);
    };
    const { onClick, onMousedown, onMouseup } = useSameTarget(props2.customMaskEvent ? void 0 : onMaskClick);
    return () => {
      return props2.mask ? createVNode("div", {
        class: ["el-overlay", props2.overlayClass],
        style: {
          zIndex: props2.zIndex
        },
        onClick,
        onMousedown,
        onMouseup
      }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
        class: props2.overlayClass,
        style: {
          zIndex: props2.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [renderSlot(slots, "default")]);
    };
  }
});
const ElOverlay = Overlay;
const dialogProps = {
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: buildProp({
    type: definePropType(Function)
  }),
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  customClass: {
    type: String,
    default: ""
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: buildProp({
    type: [String, Number],
    validator: isValidWidthUnit
  }),
  zIndex: {
    type: Number
  }
};
const dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [UPDATE_MODEL_EVENT]: (value) => typeof value === "boolean"
};
const useDialog = (props2, { emit: emit2 }, targetRef) => {
  const visible = ref(false);
  const closed = ref(false);
  const rendered = ref(false);
  const zIndex2 = ref(props2.zIndex || PopupManager$1.nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const normalizeWidth = computed(() => isNumber(props2.width) ? `${props2.width}px` : props2.width);
  const style = computed(() => {
    const style2 = {};
    const varPrefix = `--el-dialog`;
    if (!props2.fullscreen) {
      if (props2.top) {
        style2[`${varPrefix}-margin-top`] = props2.top;
      }
      if (props2.width) {
        style2[`${varPrefix}-width`] = normalizeWidth.value;
      }
    }
    return style2;
  });
  function afterEnter() {
    emit2("opened");
  }
  function afterLeave() {
    emit2("closed");
    emit2(UPDATE_MODEL_EVENT, false);
    if (props2.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    emit2("close");
  }
  function open() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();
    if (props2.openDelay && props2.openDelay > 0) {
      ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props2.openDelay));
    } else {
      doOpen();
    }
  }
  function close2() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();
    if (props2.closeDelay && props2.closeDelay > 0) {
      ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props2.closeDelay));
    } else {
      doClose();
    }
  }
  function hide2(shouldCancel) {
    if (shouldCancel)
      return;
    closed.value = true;
    visible.value = false;
  }
  function handleClose() {
    if (props2.beforeClose) {
      props2.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick2() {
    if (props2.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (isServer) {
      return;
    }
    visible.value = true;
  }
  function doClose() {
    visible.value = false;
  }
  if (props2.lockScroll) {
    useLockScreen(visible);
  }
  if (props2.closeOnPressEscape) {
    useModal({
      handleClose
    }, visible);
  }
  useRestoreActive(visible);
  watch(() => props2.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true;
      emit2("open");
      zIndex2.value = props2.zIndex ? zIndex2.value++ : PopupManager$1.nextZIndex();
      nextTick(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close2();
      }
    }
  });
  onMounted(() => {
    if (props2.modelValue) {
      visible.value = true;
      rendered.value = true;
      open();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick: onModalClick2,
    closed,
    style,
    rendered,
    visible,
    zIndex: zIndex2
  };
};
var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key2, value) => key2 in obj ? __defProp$b(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$b = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$b.call(b2, prop))
      __defNormalProp$b(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b2)) {
      if (__propIsEnum$b.call(b2, prop))
        __defNormalProp$b(a2, prop, b2[prop]);
    }
  return a2;
};
var script$g = defineComponent({
  name: "ElDialog",
  components: {
    ElOverlay
  },
  directives: {
    TrapFocus: TrapFocus$1
  },
  props: dialogProps,
  emits: dialogEmits,
  setup(props2, ctx) {
    const dialogRef = ref();
    const dialog = useDialog(props2, ctx, dialogRef);
    const overlayEvent = useSameTarget(dialog.onModalClick);
    return __spreadValues$b({
      dialogRef,
      overlayEvent
    }, dialog);
  }
});
const _hoisted_1$E = ["aria-label"];
const _hoisted_2$v = { class: "el-dialog__header" };
const _hoisted_3$q = { class: "el-dialog__title" };
const _hoisted_4$i = /* @__PURE__ */ createElementVNode("i", { class: "el-dialog__close el-icon el-icon-close" }, null, -1);
const _hoisted_5$e = [
  _hoisted_4$i
];
const _hoisted_6$c = {
  key: 0,
  class: "el-dialog__body"
};
const _hoisted_7$9 = {
  key: 1,
  class: "el-dialog__footer"
};
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_overlay = resolveComponent("el-overlay");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    createVNode(Transition, {
      name: "dialog-fade",
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(_component_el_overlay, {
          "custom-mask-event": "",
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex
        }, {
          default: withCtx(() => [
            createElementVNode("div", {
              class: "el-overlay-dialog",
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
              onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
              onMouseup: _cache[4] || (_cache[4] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
            }, [
              withDirectives(createElementVNode("div", {
                ref: "dialogRef",
                class: normalizeClass([
                  "el-dialog",
                  {
                    "is-fullscreen": _ctx.fullscreen,
                    "el-dialog--center": _ctx.center
                  },
                  _ctx.customClass
                ]),
                "aria-modal": "true",
                role: "dialog",
                "aria-label": _ctx.title || "dialog",
                style: normalizeStyle(_ctx.style),
                onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createElementVNode("div", _hoisted_2$v, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createElementVNode("span", _hoisted_3$q, toDisplayString(_ctx.title), 1)
                  ]),
                  _ctx.showClose ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    "aria-label": "close",
                    class: "el-dialog__headerbtn",
                    type: "button",
                    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                  }, _hoisted_5$e)) : createCommentVNode("v-if", true)
                ]),
                _ctx.rendered ? (openBlock(), createElementBlock("div", _hoisted_6$c, [
                  renderSlot(_ctx.$slots, "default")
                ])) : createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_7$9, [
                  renderSlot(_ctx.$slots, "footer")
                ])) : createCommentVNode("v-if", true)
              ], 14, _hoisted_1$E), [
                [_directive_trap_focus]
              ])
            ], 32)
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index"]), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
script$g.render = render$g;
script$g.__file = "packages/components/dialog/src/dialog.vue";
const ElDialog = withInstall(script$g);
const dividerProps = {
  direction: buildProp({
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  }),
  contentPosition: buildProp({
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  })
};
var script$f = defineComponent({
  name: "ElDivider",
  props: dividerProps
});
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-divider", `el-divider--${_ctx.direction}`])
  }, [
    _ctx.$slots.default && _ctx.direction !== "vertical" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["el-divider__text", `is-${_ctx.contentPosition}`])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
script$f.render = render$f;
script$f.__file = "packages/components/divider/src/divider.vue";
const ElDivider = withInstall(script$f);
let id = 0;
var script$1$7 = defineComponent({
  name: "ImgEmpty",
  setup() {
    return {
      id: ++id
    };
  }
});
const _hoisted_1$1$4 = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$1$3 = ["id"];
const _hoisted_3$1$3 = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_4$1$2 = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#EEEFF3",
  offset: "100%"
}, null, -1);
const _hoisted_5$1$2 = [
  _hoisted_3$1$3,
  _hoisted_4$1$2
];
const _hoisted_6$b = ["id"];
const _hoisted_7$8 = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_8$5 = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#E9EBEF",
  offset: "100%"
}, null, -1);
const _hoisted_9$4 = [
  _hoisted_7$8,
  _hoisted_8$5
];
const _hoisted_10$3 = ["id"];
const _hoisted_11$2 = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
};
const _hoisted_12$2 = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
};
const _hoisted_13$1 = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
};
const _hoisted_14$1 = /* @__PURE__ */ createElementVNode("path", {
  id: "Oval-Copy-2",
  d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
  fill: "#F7F8FC"
}, null, -1);
const _hoisted_15 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-14",
  fill: "#E5E7E9",
  transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
  points: "13 58 53 58 42 45 2 45"
}, null, -1);
const _hoisted_16 = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
};
const _hoisted_17 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-10",
  fill: "#E5E7E9",
  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
  points: "2.84078316e-14 3 18 3 23 7 5 7"
}, null, -1);
const _hoisted_18 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-11",
  fill: "#EDEEF2",
  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
}, null, -1);
const _hoisted_19 = ["fill"];
const _hoisted_20 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-13",
  fill: "#F8F9FB",
  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
}, null, -1);
const _hoisted_21 = ["fill"];
const _hoisted_22 = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
};
const _hoisted_23 = ["id"];
const _hoisted_24 = ["xlink:href"];
const _hoisted_25 = ["xlink:href"];
const _hoisted_26 = ["mask"];
const _hoisted_27 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-18",
  fill: "#F8F9FB",
  transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
  points: "62 45 79 45 70 58 53 58"
}, null, -1);
function render$1$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$4, [
    createElementVNode("defs", null, [
      createElementVNode("linearGradient", {
        id: `linearGradient-1-${_ctx.id}`,
        x1: "38.8503086%",
        y1: "0%",
        x2: "61.1496914%",
        y2: "100%"
      }, _hoisted_5$1$2, 8, _hoisted_2$1$3),
      createElementVNode("linearGradient", {
        id: `linearGradient-2-${_ctx.id}`,
        x1: "0%",
        y1: "9.5%",
        x2: "100%",
        y2: "90.5%"
      }, _hoisted_9$4, 8, _hoisted_6$b),
      createElementVNode("rect", {
        id: `path-3-${_ctx.id}`,
        x: "0",
        y: "0",
        width: "17",
        height: "36"
      }, null, 8, _hoisted_10$3)
    ]),
    createElementVNode("g", _hoisted_11$2, [
      createElementVNode("g", _hoisted_12$2, [
        createElementVNode("g", _hoisted_13$1, [
          _hoisted_14$1,
          _hoisted_15,
          createElementVNode("g", _hoisted_16, [
            _hoisted_17,
            _hoisted_18,
            createElementVNode("rect", {
              id: "Rectangle-Copy-12",
              fill: `url(#linearGradient-1-${_ctx.id})`,
              transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
              x: "38",
              y: "7",
              width: "17",
              height: "36"
            }, null, 8, _hoisted_19),
            _hoisted_20
          ]),
          createElementVNode("rect", {
            id: "Rectangle-Copy-15",
            fill: `url(#linearGradient-2-${_ctx.id})`,
            x: "13",
            y: "45",
            width: "40",
            height: "36"
          }, null, 8, _hoisted_21),
          createElementVNode("g", _hoisted_22, [
            createElementVNode("mask", {
              id: `mask-4-${_ctx.id}`,
              fill: "white"
            }, [
              createElementVNode("use", {
                "xlink:href": `#path-3-${_ctx.id}`
              }, null, 8, _hoisted_24)
            ], 8, _hoisted_23),
            createElementVNode("use", {
              id: "Mask",
              fill: "#E0E3E9",
              transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
              "xlink:href": `#path-3-${_ctx.id}`
            }, null, 8, _hoisted_25),
            createElementVNode("polygon", {
              id: "Rectangle-Copy",
              fill: "#D5D7DE",
              mask: `url(#mask-4-${_ctx.id})`,
              transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
              points: "7 0 24 0 20 18 -1.70530257e-13 16"
            }, null, 8, _hoisted_26)
          ]),
          _hoisted_27
        ])
      ])
    ])
  ]);
}
script$1$7.render = render$1$7;
script$1$7.__file = "packages/components/empty/src/img-empty.vue";
const emptyProps = {
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
};
var script$e = defineComponent({
  name: "ElEmpty",
  components: {
    ImgEmpty: script$1$7
  },
  props: emptyProps,
  setup(props2) {
    const { t } = useLocaleInject();
    const emptyDescription = computed(() => props2.description || t("el.table.emptyText"));
    const imageStyle = computed(() => ({
      width: props2.imageSize ? `${props2.imageSize}px` : ""
    }));
    return {
      emptyDescription,
      imageStyle
    };
  }
});
const _hoisted_1$D = { class: "el-empty" };
const _hoisted_2$u = ["src"];
const _hoisted_3$p = { class: "el-empty__description" };
const _hoisted_4$h = { key: 1 };
const _hoisted_5$d = {
  key: 0,
  class: "el-empty__bottom"
};
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_img_empty = resolveComponent("img-empty");
  return openBlock(), createElementBlock("div", _hoisted_1$D, [
    createElementVNode("div", {
      class: "el-empty__image",
      style: normalizeStyle(_ctx.imageStyle)
    }, [
      _ctx.image ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: _ctx.image,
        ondragstart: "return false"
      }, null, 8, _hoisted_2$u)) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
        createVNode(_component_img_empty)
      ])
    ], 4),
    createElementVNode("div", _hoisted_3$p, [
      _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_4$h, toDisplayString(_ctx.emptyDescription), 1))
    ]),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_5$d, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ]);
}
script$e.render = render$e;
script$e.__file = "packages/components/empty/src/empty.vue";
const ElEmpty = withInstall(script$e);
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$1(template2) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template2 === "function") {
    return template2.apply(null, args);
  }
  if (typeof template2 === "string") {
    var str = template2.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template2;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option2, func, callback, source) {
  if (option2.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option2.firstFields === true ? Object.keys(objArr) : option2.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue(value, path) {
  var v2 = value;
  for (var i = 0; i < path.length; i++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path[i]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value = source[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options2, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format$1(options2.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options2) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format$1(options2.messages.whitespace, rule.fullField));
  }
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && !!value.match(pattern$2.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === "string" && !!value.match(pattern$2.url);
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options2) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options2);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$1(options2.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$1(options2.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options2) {
  var len = typeof rule.len === "number";
  var min2 = typeof rule.min === "number";
  var max2 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key2 = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options2.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min2 && !max2 && val < rule.min) {
    errors.push(format$1(options2.messages[key2].min, rule.fullField, rule.min));
  } else if (max2 && !min2 && val > rule.max) {
    errors.push(format$1(options2.messages[key2].max, rule.fullField, rule.max));
  } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options2.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options2) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format$1(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options2) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format$1(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format$1(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules$1 = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2, "string");
    if (!isEmptyValue(value, "string")) {
      rules$1.type(rule, value, source, errors, options2);
      rules$1.range(rule, value, source, errors, options2);
      rules$1.pattern(rule, value, source, errors, options2);
      if (rule.whitespace === true) {
        rules$1.whitespace(rule, value, source, errors, options2);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
      rules$1.range(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (!isEmptyValue(value)) {
      rules$1.type(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
      rules$1.range(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
      rules$1.range(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2, "array");
    if (value !== void 0 && value !== null) {
      rules$1.type(rule, value, source, errors, options2);
      rules$1.range(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1.type(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (value !== void 0) {
      rules$1[ENUM](rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (!isEmptyValue(value, "string")) {
      rules$1.pattern(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules$1.type(rule, dateObject, source, errors, options2);
      if (dateObject) {
        rules$1.range(rule, dateObject.getTime(), source, errors, options2);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options2) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules$1.required(rule, value, source, errors, options2, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options2) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules$1.type(rule, value, source, errors, options2);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options2) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules$1.required(rule, value, source, errors, options2);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source = source_;
    var options2 = o2;
    var callback = oc;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options2.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options2.messages);
      options2.messages = messages$1;
    } else {
      options2.messages = this.messages();
    }
    var series = {};
    var keys2 = options2.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value,
          source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options2, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key2, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errorList = Array.isArray(e) ? e : [e];
        if (!options2.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options2.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options2.error) {
              filledErrors = [options2.error(rule, format$1(options2.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options2.messages);
          if (data.rule.options) {
            data.rule.options.messages = options2.messages;
            data.rule.options.error = options2.error;
          }
          schema.validate(data.value, data.rule.options || options2, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options2);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options2);
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;
var __defProp$1$2 = Object.defineProperty;
var __defProps$1$2 = Object.defineProperties;
var __getOwnPropDescs$1$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$2 = (obj, key2, value) => key2 in obj ? __defProp$1$2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1$2.call(b2, prop))
      __defNormalProp$1$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1$2)
    for (var prop of __getOwnPropSymbols$1$2(b2)) {
      if (__propIsEnum$1$2.call(b2, prop))
        __defNormalProp$1$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1$2 = (a2, b2) => __defProps$1$2(a2, __getOwnPropDescs$1$2(b2));
function useFormLabelWidth() {
  const potentialLabelWidthArr = ref([]);
  const autoLabelWidth = computed(() => {
    if (!potentialLabelWidthArr.value.length)
      return "0";
    const max2 = Math.max(...potentialLabelWidthArr.value);
    return max2 ? `${max2}px` : "";
  });
  function getLabelWidthIndex(width2) {
    const index2 = potentialLabelWidthArr.value.indexOf(width2);
    return index2;
  }
  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      const index2 = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index2, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }
  function deregisterLabelWidth(val) {
    const index2 = getLabelWidthIndex(val);
    index2 > -1 && potentialLabelWidthArr.value.splice(index2, 1);
  }
  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
}
var script$1$6 = defineComponent({
  name: "ElForm",
  props: {
    model: Object,
    rules: Object,
    labelPosition: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelSuffix: {
      type: String,
      default: ""
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    disabled: Boolean,
    validateOnRuleChange: {
      type: Boolean,
      default: true
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: false
    },
    scrollToError: Boolean
  },
  emits: ["validate"],
  setup(props2, { emit: emit2 }) {
    const fields = [];
    watch(() => props2.rules, () => {
      fields.forEach((field) => {
        field.evaluateValidationEnabled();
      });
      if (props2.validateOnRuleChange) {
        validate(() => ({}));
      }
    });
    const addField = (field) => {
      if (field) {
        fields.push(field);
      }
    };
    const removeField = (field) => {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    };
    const resetFields = () => {
      if (!props2.model) {
        return;
      }
      fields.forEach((field) => {
        field.resetField();
      });
    };
    const clearValidate = (props22 = []) => {
      const fds = props22.length ? typeof props22 === "string" ? fields.filter((field) => props22 === field.prop) : fields.filter((field) => props22.indexOf(field.prop) > -1) : fields;
      fds.forEach((field) => {
        field.clearValidate();
      });
    };
    const validate = (callback) => {
      if (!props2.model) {
        return;
      }
      let promise;
      if (typeof callback !== "function") {
        promise = new Promise((resolve, reject) => {
          callback = function(valid2, invalidFields2) {
            if (valid2) {
              resolve(true);
            } else {
              reject(invalidFields2);
            }
          };
        });
      }
      if (fields.length === 0) {
        callback(true);
      }
      let valid = true;
      let count = 0;
      let invalidFields = {};
      let firstInvalidFields;
      for (const field of fields) {
        field.validate("", (message2, field2) => {
          if (message2) {
            valid = false;
            firstInvalidFields || (firstInvalidFields = field2);
          }
          invalidFields = __spreadValues$1$2(__spreadValues$1$2({}, invalidFields), field2);
          if (++count === fields.length) {
            callback(valid, invalidFields);
          }
        });
      }
      if (!valid && props2.scrollToError) {
        scrollToField(Object.keys(firstInvalidFields)[0]);
      }
      return promise;
    };
    const validateField = (props22, cb) => {
      props22 = [].concat(props22);
      const fds = fields.filter((field) => props22.indexOf(field.prop) !== -1);
      if (!fields.length) {
        return;
      }
      fds.forEach((field) => {
        field.validate("", cb);
      });
    };
    const scrollToField = (prop) => {
      fields.forEach((item) => {
        if (item.prop === prop) {
          item.$el.scrollIntoView();
        }
      });
    };
    const elForm2 = reactive(__spreadValues$1$2(__spreadProps$1$2(__spreadValues$1$2({}, toRefs(props2)), {
      resetFields,
      clearValidate,
      validateField,
      emit: emit2,
      addField,
      removeField
    }), useFormLabelWidth()));
    provide(elFormKey, elForm2);
    return {
      validate,
      resetFields,
      clearValidate,
      validateField,
      scrollToField
    };
  }
});
function render$1$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    class: normalizeClass(["el-form", [
      _ctx.labelPosition ? "el-form--label-" + _ctx.labelPosition : "",
      { "el-form--inline": _ctx.inline }
    ]])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$1$6.render = render$1$6;
script$1$6.__file = "packages/components/form/src/form.vue";
var LabelWrap = defineComponent({
  name: "ElLabelWrap",
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(props2, { slots }) {
    const el = ref(null);
    const elForm2 = inject(elFormKey);
    const elFormItem2 = inject(elFormItemKey);
    const computedWidth = ref(0);
    watch(computedWidth, (val, oldVal) => {
      if (props2.updateAll) {
        elForm2.registerLabelWidth(val, oldVal);
        elFormItem2.updateComputedLabelWidth(val);
      }
    });
    const getLabelWidth = () => {
      var _a;
      if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
        const width2 = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(parseFloat(width2));
      } else {
        return 0;
      }
    };
    const updateLabelWidth = (action = "update") => {
      nextTick(() => {
        if (slots.default && props2.isAutoWidth) {
          if (action === "update") {
            computedWidth.value = getLabelWidth();
          } else if (action === "remove") {
            elForm2.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };
    const updateLabelWidthFn = () => updateLabelWidth("update");
    onMounted(() => {
      addResizeListener(el.value.firstElementChild, updateLabelWidthFn);
      updateLabelWidthFn();
    });
    onUpdated(updateLabelWidthFn);
    onBeforeUnmount(() => {
      var _a;
      updateLabelWidth("remove");
      removeResizeListener((_a = el.value) == null ? void 0 : _a.firstElementChild, updateLabelWidthFn);
    });
    function render2() {
      var _a, _b;
      if (!slots)
        return null;
      if (props2.isAutoWidth) {
        const autoLabelWidth = elForm2.autoLabelWidth;
        const style = {};
        if (autoLabelWidth && autoLabelWidth !== "auto") {
          const marginWidth = Math.max(0, parseInt(autoLabelWidth, 10) - computedWidth.value);
          const marginPosition = elForm2.labelPosition === "left" ? "marginRight" : "marginLeft";
          if (marginWidth) {
            style[marginPosition] = `${marginWidth}px`;
          }
        }
        return h$1("div", {
          ref: el,
          class: ["el-form-item__label-wrap"],
          style
        }, (_a = slots.default) == null ? void 0 : _a.call(slots));
      } else {
        return h$1(Fragment, { ref: el }, (_b = slots.default) == null ? void 0 : _b.call(slots));
      }
    }
    return render2;
  }
});
var __defProp$a = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key2, value) => key2 in obj ? __defProp$a(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$a = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$a.call(b2, prop))
      __defNormalProp$a(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b2)) {
      if (__propIsEnum$a.call(b2, prop))
        __defNormalProp$a(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
var script$d = defineComponent({
  name: "ElFormItem",
  componentName: "ElFormItem",
  components: {
    LabelWrap
  },
  props: {
    label: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    prop: String,
    required: {
      type: Boolean,
      default: void 0
    },
    rules: [Object, Array],
    error: String,
    validateStatus: String,
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ""
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  setup(props2, { slots }) {
    const $ELEMENT2 = useGlobalConfig();
    const elForm2 = inject(elFormKey, {});
    const validateState = ref("");
    const validateMessage = ref("");
    const isValidationEnabled = ref(false);
    const computedLabelWidth = ref("");
    const formItemRef = ref();
    const vm = getCurrentInstance();
    const isNested = computed(() => {
      let parent = vm.parent;
      while (parent && parent.type.name !== "ElForm") {
        if (parent.type.name === "ElFormItem") {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    });
    let initialValue = void 0;
    watch(() => props2.error, (val) => {
      validateMessage.value = val;
      validateState.value = val ? "error" : "";
    }, {
      immediate: true
    });
    watch(() => props2.validateStatus, (val) => {
      validateState.value = val;
    });
    const labelFor = computed(() => props2.for || props2.prop);
    const labelStyle = computed(() => {
      const ret = {};
      if (elForm2.labelPosition === "top")
        return ret;
      const labelWidth2 = addUnit(props2.labelWidth) || addUnit(elForm2.labelWidth);
      if (labelWidth2) {
        ret.width = labelWidth2;
      }
      return ret;
    });
    const contentStyle = computed(() => {
      const ret = {};
      if (elForm2.labelPosition === "top" || elForm2.inline) {
        return ret;
      }
      if (!props2.label && !props2.labelWidth && isNested.value) {
        return ret;
      }
      const labelWidth2 = addUnit(props2.labelWidth) || addUnit(elForm2.labelWidth);
      if (!props2.label && !slots.label) {
        ret.marginLeft = labelWidth2;
      }
      return ret;
    });
    const fieldValue = computed(() => {
      const model = elForm2.model;
      if (!model || !props2.prop) {
        return;
      }
      let path = props2.prop;
      if (path.indexOf(":") !== -1) {
        path = path.replace(/:/, ".");
      }
      return getPropByPath(model, path, true).v;
    });
    const isRequired = computed(() => {
      const rules2 = getRules();
      let required4 = false;
      if (rules2 && rules2.length) {
        rules2.every((rule) => {
          if (rule.required) {
            required4 = true;
            return false;
          }
          return true;
        });
      }
      return required4;
    });
    const elFormItemSize = computed(() => props2.size || elForm2.size);
    const sizeClass = computed(() => {
      return elFormItemSize.value || $ELEMENT2.size;
    });
    const validate = (trigger, callback = NOOP) => {
      if (!isValidationEnabled.value) {
        callback();
        return;
      }
      const rules2 = getFilteredRule(trigger);
      if ((!rules2 || rules2.length === 0) && props2.required === void 0) {
        callback();
        return;
      }
      validateState.value = "validating";
      const descriptor = {};
      if (rules2 && rules2.length > 0) {
        rules2.forEach((rule) => {
          delete rule.trigger;
        });
      }
      descriptor[props2.prop] = rules2;
      const validator = new Schema(descriptor);
      const model = {};
      model[props2.prop] = fieldValue.value;
      validator.validate(model, { firstFields: true }, (errors, invalidFields) => {
        var _a;
        validateState.value = !errors ? "success" : "error";
        validateMessage.value = errors ? errors[0].message || `${props2.prop} is required` : "";
        callback(validateMessage.value, invalidFields);
        (_a = elForm2.emit) == null ? void 0 : _a.call(elForm2, "validate", props2.prop, !errors, validateMessage.value || null);
      });
    };
    const clearValidate = () => {
      validateState.value = "";
      validateMessage.value = "";
    };
    const resetField = () => {
      validateState.value = "";
      validateMessage.value = "";
      const model = elForm2.model;
      const value = fieldValue.value;
      let path = props2.prop;
      if (path.indexOf(":") !== -1) {
        path = path.replace(/:/, ".");
      }
      const prop = getPropByPath(model, path, true);
      if (Array.isArray(value)) {
        prop.o[prop.k] = [].concat(initialValue);
      } else {
        prop.o[prop.k] = initialValue;
      }
    };
    const getRules = () => {
      const formRules = elForm2.rules;
      const selfRules = props2.rules;
      const requiredRule = props2.required !== void 0 ? { required: !!props2.required } : [];
      const prop = getPropByPath(formRules, props2.prop || "", false);
      const normalizedRule = formRules ? prop.o[props2.prop || ""] || prop.v : [];
      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);
    };
    const getFilteredRule = (trigger) => {
      const rules2 = getRules();
      return rules2.filter((rule) => {
        if (!rule.trigger || trigger === "")
          return true;
        if (Array.isArray(rule.trigger)) {
          return rule.trigger.indexOf(trigger) > -1;
        } else {
          return rule.trigger === trigger;
        }
      }).map((rule) => __spreadValues$a({}, rule));
    };
    const evaluateValidationEnabled = () => {
      var _a;
      isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);
    };
    const updateComputedLabelWidth = (width2) => {
      computedLabelWidth.value = width2 ? `${width2}px` : "";
    };
    const elFormItem2 = reactive(__spreadProps$6(__spreadValues$a({}, toRefs(props2)), {
      size: sizeClass,
      validateState,
      $el: formItemRef,
      evaluateValidationEnabled,
      resetField,
      clearValidate,
      validate,
      updateComputedLabelWidth
    }));
    onMounted(() => {
      if (props2.prop) {
        elForm2 == null ? void 0 : elForm2.addField(elFormItem2);
        const value = fieldValue.value;
        initialValue = Array.isArray(value) ? [...value] : value;
        evaluateValidationEnabled();
      }
    });
    onBeforeUnmount(() => {
      elForm2 == null ? void 0 : elForm2.removeField(elFormItem2);
    });
    provide(elFormItemKey, elFormItem2);
    const formItemClass = computed(() => [
      {
        "el-form-item--feedback": elForm2.statusIcon,
        "is-error": validateState.value === "error",
        "is-validating": validateState.value === "validating",
        "is-success": validateState.value === "success",
        "is-required": isRequired.value || props2.required,
        "is-no-asterisk": elForm2.hideRequiredAsterisk
      },
      sizeClass.value ? `el-form-item--${sizeClass.value}` : ""
    ]);
    const shouldShowError = computed(() => {
      return validateState.value === "error" && props2.showMessage && elForm2.showMessage;
    });
    return {
      formItemRef,
      formItemClass,
      shouldShowError,
      elForm: elForm2,
      labelStyle,
      contentStyle,
      validateMessage,
      labelFor,
      resetField,
      clearValidate
    };
  }
});
const _hoisted_1$C = ["for"];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabelWrap = resolveComponent("LabelWrap");
  return openBlock(), createElementBlock("div", {
    ref: "formItemRef",
    class: normalizeClass(["el-form-item", _ctx.formItemClass])
  }, [
    createVNode(_component_LabelWrap, {
      "is-auto-width": _ctx.labelStyle.width === "auto",
      "update-all": _ctx.elForm.labelWidth === "auto"
    }, {
      default: withCtx(() => [
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          for: _ctx.labelFor,
          class: "el-form-item__label",
          style: normalizeStyle(_ctx.labelStyle)
        }, [
          renderSlot(_ctx.$slots, "label", {
            label: _ctx.label + _ctx.elForm.labelSuffix
          }, () => [
            createTextVNode(toDisplayString(_ctx.label + _ctx.elForm.labelSuffix), 1)
          ])
        ], 12, _hoisted_1$C)) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["is-auto-width", "update-all"]),
    createElementVNode("div", {
      class: "el-form-item__content",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      renderSlot(_ctx.$slots, "default"),
      createVNode(Transition, { name: "el-zoom-in-top" }, {
        default: withCtx(() => [
          _ctx.shouldShowError ? renderSlot(_ctx.$slots, "error", {
            key: 0,
            error: _ctx.validateMessage
          }, () => [
            createElementVNode("div", {
              class: normalizeClass(["el-form-item__error", {
                "el-form-item__error--inline": typeof _ctx.inlineMessage === "boolean" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false
              }])
            }, toDisplayString(_ctx.validateMessage), 3)
          ]) : createCommentVNode("v-if", true)
        ]),
        _: 3
      })
    ], 4)
  ], 2);
}
script$d.render = render$d;
script$d.__file = "packages/components/form/src/form-item.vue";
const ElForm = withInstall(script$1$6, {
  FormItem: script$d
});
const ElFormItem = withNoopInstall(script$d);
var script$c = defineComponent({
  name: "ElInputNumber",
  components: {
    ElInput: _Input
  },
  directives: {
    RepeatClick
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    modelValue: {
      type: Number
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ""
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
      type: Number,
      validator: (val) => val >= 0 && val === parseInt(`${val}`, 10)
    }
  },
  emits: ["update:modelValue", "change", "input", "blur", "focus"],
  setup(props2, { emit: emit2 }) {
    const ELEMENT = useGlobalConfig();
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const input = ref(null);
    const data = reactive({
      currentValue: props2.modelValue,
      userInput: null
    });
    const minDisabled = computed(() => {
      return _decrease(props2.modelValue) < props2.min;
    });
    const maxDisabled = computed(() => {
      return _increase(props2.modelValue) > props2.max;
    });
    const numPrecision = computed(() => {
      const stepPrecision = getPrecision(props2.step);
      if (props2.precision !== void 0) {
        if (stepPrecision > props2.precision)
          ;
        return props2.precision;
      } else {
        return Math.max(getPrecision(props2.modelValue), stepPrecision);
      }
    });
    const controlsAtRight = computed(() => {
      return props2.controls && props2.controlsPosition === "right";
    });
    const inputNumberSize = computed(() => {
      return props2.size || elFormItem2.size || ELEMENT.size;
    });
    const inputNumberDisabled = computed(() => {
      return props2.disabled || elForm2.disabled;
    });
    const displayValue = computed(() => {
      if (data.userInput !== null) {
        return data.userInput;
      }
      let currentValue = data.currentValue;
      if (typeof currentValue === "number") {
        if (props2.precision !== void 0) {
          currentValue = currentValue.toFixed(props2.precision);
        }
      }
      return currentValue;
    });
    const toPrecision = (num, pre) => {
      if (pre === void 0)
        pre = numPrecision.value;
      return parseFloat(`${Math.round(num * Math.pow(10, pre)) / Math.pow(10, pre)}`);
    };
    const getPrecision = (value) => {
      if (value === void 0)
        return 0;
      const valueString = value.toString();
      const dotPosition = valueString.indexOf(".");
      let precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    };
    const _increase = (val) => {
      if (typeof val !== "number" && val !== void 0)
        return data.currentValue;
      const precisionFactor = Math.pow(10, numPrecision.value);
      return toPrecision((precisionFactor * val + precisionFactor * props2.step) / precisionFactor);
    };
    const _decrease = (val) => {
      if (typeof val !== "number" && val !== void 0)
        return data.currentValue;
      const precisionFactor = Math.pow(10, numPrecision.value);
      return toPrecision((precisionFactor * val - precisionFactor * props2.step) / precisionFactor);
    };
    const increase = () => {
      if (inputNumberDisabled.value || maxDisabled.value)
        return;
      const value = props2.modelValue || 0;
      const newVal = _increase(value);
      setCurrentValue(newVal);
    };
    const decrease = () => {
      if (inputNumberDisabled.value || minDisabled.value)
        return;
      const value = props2.modelValue || 0;
      const newVal = _decrease(value);
      setCurrentValue(newVal);
    };
    const setCurrentValue = (newVal) => {
      const oldVal = data.currentValue;
      if (typeof newVal === "number" && props2.precision !== void 0) {
        newVal = toPrecision(newVal, props2.precision);
      }
      if (newVal !== void 0 && newVal >= props2.max)
        newVal = props2.max;
      if (newVal !== void 0 && newVal <= props2.min)
        newVal = props2.min;
      if (oldVal === newVal)
        return;
      data.userInput = null;
      emit2("update:modelValue", newVal);
      emit2("input", newVal);
      emit2("change", newVal, oldVal);
      data.currentValue = newVal;
    };
    const handleInput = (value) => {
      return data.userInput = value;
    };
    const handleInputChange = (value) => {
      const newVal = value === "" ? void 0 : Number(value);
      if (!isNaN(newVal) || value === "") {
        setCurrentValue(newVal);
      }
      data.userInput = null;
    };
    const focus = () => {
      var _a, _b;
      (_b = (_a = input.value).focus) == null ? void 0 : _b.call(_a);
    };
    const blur = () => {
      var _a, _b;
      (_b = (_a = input.value).blur) == null ? void 0 : _b.call(_a);
    };
    watch(() => props2.modelValue, (value) => {
      let newVal = value === void 0 ? value : Number(value);
      if (newVal !== void 0) {
        if (isNaN(newVal))
          return;
        if (props2.stepStrictly) {
          const stepPrecision = getPrecision(props2.step);
          const precisionFactor = Math.pow(10, stepPrecision);
          newVal = Math.round(newVal / props2.step) * precisionFactor * props2.step / precisionFactor;
        }
        if (props2.precision !== void 0) {
          newVal = toPrecision(newVal, props2.precision);
        }
      }
      if (newVal !== void 0 && newVal >= props2.max) {
        newVal = props2.max;
        emit2("update:modelValue", newVal);
      }
      if (newVal !== void 0 && newVal <= props2.min) {
        newVal = props2.min;
        emit2("update:modelValue", newVal);
      }
      data.currentValue = newVal;
      data.userInput = null;
    }, { immediate: true });
    onMounted(() => {
      const innerInput = input.value.input;
      innerInput.setAttribute("role", "spinbutton");
      innerInput.setAttribute("aria-valuemax", props2.max);
      innerInput.setAttribute("aria-valuemin", props2.min);
      innerInput.setAttribute("aria-valuenow", data.currentValue);
      innerInput.setAttribute("aria-disabled", inputNumberDisabled.value);
      if (toRawType(props2.modelValue) !== "Number" && props2.modelValue !== void 0) {
        emit2("update:modelValue", void 0);
      }
    });
    onUpdated(() => {
      const innerInput = input.value.input;
      innerInput.setAttribute("aria-valuenow", data.currentValue);
    });
    return {
      input,
      displayValue,
      handleInput,
      handleInputChange,
      controlsAtRight,
      decrease,
      increase,
      inputNumberSize,
      inputNumberDisabled,
      maxDisabled,
      minDisabled,
      focus,
      blur
    };
  }
});
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      "el-input-number",
      _ctx.inputNumberSize ? "el-input-number--" + _ctx.inputNumberSize : "",
      { "is-disabled": _ctx.inputNumberDisabled },
      { "is-without-controls": !_ctx.controls },
      { "is-controls-right": _ctx.controlsAtRight }
    ]),
    onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
    }, ["prevent"]))
  }, [
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(["el-input-number__decrease", { "is-disabled": _ctx.minDisabled }]),
      role: "button",
      onKeydown: _cache[0] || (_cache[0] = withKeys((...args) => _ctx.decrease && _ctx.decrease(...args), ["enter"]))
    }, [
      createElementVNode("i", {
        class: normalizeClass(`el-icon-${_ctx.controlsAtRight ? "arrow-down" : "minus"}`)
      }, null, 2)
    ], 34)), [
      [_directive_repeat_click, _ctx.decrease]
    ]) : createCommentVNode("v-if", true),
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(["el-input-number__increase", { "is-disabled": _ctx.maxDisabled }]),
      role: "button",
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.increase && _ctx.increase(...args), ["enter"]))
    }, [
      createElementVNode("i", {
        class: normalizeClass(`el-icon-${_ctx.controlsAtRight ? "arrow-up" : "plus"}`)
      }, null, 2)
    ], 34)), [
      [_directive_repeat_click, _ctx.increase]
    ]) : createCommentVNode("v-if", true),
    createVNode(_component_el_input, {
      ref: "input",
      "model-value": _ctx.displayValue,
      placeholder: _ctx.placeholder,
      disabled: _ctx.inputNumberDisabled,
      size: _ctx.inputNumberSize,
      max: _ctx.max,
      min: _ctx.min,
      name: _ctx.name,
      label: _ctx.label,
      onKeydown: [
        withKeys(withModifiers(_ctx.increase, ["prevent"]), ["up"]),
        withKeys(withModifiers(_ctx.decrease, ["prevent"]), ["down"])
      ],
      onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
      onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event)),
      onInput: _ctx.handleInput,
      onChange: _ctx.handleInputChange
    }, null, 8, ["model-value", "placeholder", "disabled", "size", "max", "min", "name", "label", "onKeydown", "onInput", "onChange"])
  ], 34);
}
script$c.render = render$c;
script$c.__file = "packages/components/input-number/src/index.vue";
script$c.install = (app) => {
  app.component(script$c.name, script$c);
};
const _InputNumber = script$c;
const ElInputNumber = _InputNumber;
var __defProp$9 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key2, value) => key2 in obj ? __defProp$9(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$9 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$9.call(b2, prop))
      __defNormalProp$9(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b2)) {
      if (__propIsEnum$9.call(b2, prop))
        __defNormalProp$9(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$5 = (a2, b2) => __defProps$5(a2, __getOwnPropDescs$5(b2));
var Tooltip = defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper: _Popper
  },
  props: __spreadProps$5(__spreadValues$9({}, defaultProps$4), {
    manual: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      validator: (val) => {
        return typeof val === "boolean";
      },
      default: void 0
    },
    openDelay: {
      type: Number,
      default: 0
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: [String, Number],
      default: "0"
    }
  }),
  emits: [UPDATE_MODEL_EVENT],
  setup(props2, ctx) {
    if (props2.manual && typeof props2.modelValue === "undefined") {
      throwError("[ElTooltip]", "You need to pass a v-model to el-tooltip when `manual` is true");
    }
    const popper2 = ref(null);
    const onUpdateVisible = (val) => {
      ctx.emit(UPDATE_MODEL_EVENT, val);
    };
    const updatePopper = () => {
      return popper2.value.update();
    };
    return {
      popper: popper2,
      onUpdateVisible,
      updatePopper
    };
  },
  render() {
    const {
      $slots,
      content,
      manual,
      openDelay,
      onUpdateVisible,
      showAfter,
      visibleArrow,
      modelValue,
      tabindex
    } = this;
    const throwErrorTip = () => {
      throwError("[ElTooltip]", "you need to provide a valid default slot.");
    };
    const popper2 = h$1(_Popper, __spreadProps$5(__spreadValues$9({}, Object.keys(defaultProps$4).reduce((result, key2) => {
      return __spreadProps$5(__spreadValues$9({}, result), { [key2]: this[key2] });
    }, {})), {
      ref: "popper",
      manualMode: manual,
      showAfter: openDelay || showAfter,
      showArrow: visibleArrow,
      visible: modelValue,
      "onUpdate:visible": onUpdateVisible
    }), {
      default: () => $slots.content ? $slots.content() : content,
      trigger: () => {
        if ($slots.default) {
          const firstVnode = getFirstValidNode($slots.default(), 1);
          if (!firstVnode)
            throwErrorTip();
          return cloneVNode(firstVnode, { tabindex }, true);
        }
        throwErrorTip();
      }
    });
    return popper2;
  }
});
Tooltip.install = (app) => {
  app.component(Tooltip.name, Tooltip);
};
const _Tooltip = Tooltip;
const ElTooltip = _Tooltip;
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";
function useOption(props2, states) {
  const select = inject(selectKey);
  const selectGroup = inject(selectGroupKey, { disabled: false });
  const isObject2 = computed(() => {
    return Object.prototype.toString.call(props2.value).toLowerCase() === "[object object]";
  });
  const itemSelected = computed(() => {
    if (!select.props.multiple) {
      return isEqual2(props2.value, select.props.modelValue);
    } else {
      return contains2(select.props.modelValue, props2.value);
    }
  });
  const limitReached = computed(() => {
    if (select.props.multiple) {
      const modelValue = select.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = computed(() => {
    return props2.label || (isObject2.value ? "" : props2.value);
  });
  const currentValue = computed(() => {
    return props2.value || props2.label || "";
  });
  const isDisabled = computed(() => {
    return props2.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = getCurrentInstance();
  const contains2 = (arr = [], target) => {
    if (!isObject2.value) {
      return arr && arr.indexOf(target) > -1;
    } else {
      const valueKey = select.props.valueKey;
      return arr && arr.some((item) => {
        return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
      });
    }
  };
  const isEqual2 = (a2, b2) => {
    if (!isObject2.value) {
      return a2 === b2;
    } else {
      const { valueKey } = select.props;
      return getValueByPath(a2, valueKey) === getValueByPath(b2, valueKey);
    }
  };
  const hoverItem = () => {
    if (!props2.disabled && !selectGroup.disabled) {
      select.hoverIndex = select.optionsArray.indexOf(instance);
    }
  };
  watch(() => currentLabel.value, () => {
    if (!props2.created && !select.props.remote)
      select.setSelected();
  });
  watch(() => props2.value, (val, oldVal) => {
    const { remote, valueKey } = select.props;
    if (!props2.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }
      select.setSelected();
    }
  });
  watch(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, { immediate: true });
  const { queryChange } = toRaw(select);
  watch(queryChange, (changes) => {
    const { query: query2 } = unref(changes);
    const regexp4 = new RegExp(escapeRegexpString(query2), "i");
    states.visible = regexp4.test(currentLabel.value) || props2.created;
    if (!states.visible) {
      select.filteredOptionsCount--;
    }
  });
  return {
    select,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}
var script$3$1 = defineComponent({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const states = reactive({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption(props2, states);
    const { visible, hover } = toRefs(states);
    const vm = getCurrentInstance().proxy;
    const key2 = vm.value;
    select.onOptionCreate(vm);
    onBeforeUnmount(() => {
      const { selected } = select;
      const selectedOptions = select.props.multiple ? selected : [selected];
      const doesExist = select.cachedOptions.has(key2);
      const doesSelected = selectedOptions.some((item) => {
        return item.value === vm.value;
      });
      if (doesExist && !doesSelected) {
        select.cachedOptions.delete(key2);
      }
      select.onOptionDestroy(key2);
    });
    function selectOptionClick() {
      if (props2.disabled !== true && states.groupDisabled !== true) {
        select.handleOptionSelect(vm, true);
      }
    }
    return {
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem,
      visible,
      hover,
      selectOptionClick
    };
  }
});
function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("li", {
    class: normalizeClass(["el-select-dropdown__item", {
      selected: _ctx.itemSelected,
      "is-disabled": _ctx.isDisabled,
      hover: _ctx.hover
    }]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
    ])
  ], 34)), [
    [vShow, _ctx.visible]
  ]);
}
script$3$1.render = render$3$1;
script$3$1.__file = "packages/components/select/src/option.vue";
var script$2$3 = defineComponent({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const select = inject(selectKey);
    const popperClass = computed(() => select.props.popperClass);
    const isMultiple = computed(() => select.props.multiple);
    const minWidth = ref("");
    function updateMinWidth() {
      var _a;
      minWidth.value = `${(_a = select.selectWrapper) == null ? void 0 : _a.getBoundingClientRect().width}px`;
    }
    onMounted(() => {
      addResizeListener(select.selectWrapper, updateMinWidth);
    });
    onBeforeUnmount(() => {
      removeResizeListener(select.selectWrapper, updateMinWidth);
    });
    return {
      minWidth,
      popperClass,
      isMultiple
    };
  }
});
function render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-select-dropdown", [{ "is-multiple": _ctx.isMultiple }, _ctx.popperClass]]),
    style: normalizeStyle({ minWidth: _ctx.minWidth })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script$2$3.render = render$2$2;
script$2$3.__file = "packages/components/select/src/select-dropdown.vue";
function useSelectStates(props2) {
  const { t } = useLocaleInject();
  return reactive({
    options: new Map(),
    cachedOptions: new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props2.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    prefixWidth: null,
    tagInMultiLine: false
  });
}
const useSelect = (props2, states, ctx) => {
  const ELEMENT = useGlobalConfig();
  const { t } = useLocaleInject();
  const reference2 = ref(null);
  const input = ref(null);
  const popper2 = ref(null);
  const tags2 = ref(null);
  const selectWrapper = ref(null);
  const scrollbar = ref(null);
  const hoverOption = ref(-1);
  const queryChange = shallowRef({ query: "" });
  const groupQueryChange = shallowRef("");
  const elForm2 = inject(elFormKey, {});
  const elFormItem2 = inject(elFormItemKey, {});
  const readonly = computed(() => !props2.filterable || props2.multiple || !states.visible);
  const selectDisabled = computed(() => props2.disabled || elForm2.disabled);
  const showClose = computed(() => {
    const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    const criteria = props2.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconClass = computed(() => props2.remote && props2.filterable ? "" : states.visible ? "arrow-up is-reverse" : "arrow-up");
  const debounce2 = computed(() => props2.remote ? 300 : 0);
  const emptyText = computed(() => {
    if (props2.loading) {
      return props2.loadingText || t("el.select.loading");
    } else {
      if (props2.remote && states.query === "" && states.options.size === 0)
        return false;
      if (props2.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props2.noMatchText || t("el.select.noMatch");
      }
      if (states.options.size === 0) {
        return props2.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const optionsArray = computed(() => Array.from(states.options.values()));
  const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
  const showNewOption = computed(() => {
    const hasExistingOption = optionsArray.value.filter((option2) => {
      return !option2.created;
    }).some((option2) => {
      return option2.currentLabel === states.query;
    });
    return props2.filterable && props2.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = computed(() => props2.size || elFormItem2.size || ELEMENT.size);
  const collapseTagSize = computed(() => ["small", "mini"].indexOf(selectSize.value) > -1 ? "mini" : "small");
  const dropMenuVisible = computed(() => states.visible && emptyText.value !== false);
  watch(() => selectDisabled.value, () => {
    nextTick(() => {
      resetInputHeight();
    });
  });
  watch(() => props2.placeholder, (val) => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  watch(() => props2.modelValue, (val, oldVal) => {
    var _a;
    if (props2.multiple) {
      resetInputHeight();
      if (val && val.length > 0 || input.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
      if (props2.filterable && !props2.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }
    setSelected();
    if (props2.filterable && !props2.multiple) {
      states.inputLength = 20;
    }
    if (!isEqual_1(val, oldVal)) {
      (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
    }
  }, {
    flush: "post",
    deep: true
  });
  watch(() => states.visible, (val) => {
    var _a, _b;
    if (!val) {
      input.value && input.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      nextTick(() => {
        if (input.value && input.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });
      if (!props2.multiple) {
        if (states.selected) {
          if (props2.filterable && props2.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }
          if (props2.filterable)
            states.query = states.selectedLabel;
        }
        if (props2.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      if (props2.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props2.remote ? "" : states.selectedLabel;
        if (props2.multiple) {
          input.value.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = states.selectedLabel;
            states.selectedLabel = "";
          }
        }
        handleQueryChange(states.query);
        if (!props2.multiple && !props2.remote) {
          queryChange.value.query = "";
          triggerRef(queryChange);
          triggerRef(groupQueryChange);
        }
      }
    }
    ctx.emit("visible-change", val);
  });
  watch(() => states.options.entries(), () => {
    var _a, _b, _c;
    if (isServer)
      return;
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple) {
      resetInputHeight();
    }
    const inputs2 = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
    if ([].indexOf.call(inputs2, document.activeElement) === -1) {
      setSelected();
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  watch(() => states.hoverIndex, (val) => {
    if (typeof val === "number" && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }
    optionsArray.value.forEach((option2) => {
      option2.hover = hoverOption.value === option2;
    });
  });
  const resetInputHeight = () => {
    if (props2.collapseTags && !props2.filterable)
      return;
    nextTick(() => {
      var _a, _b;
      if (!reference2.value)
        return;
      const inputChildNodes = reference2.value.$el.childNodes;
      const input2 = [].filter.call(inputChildNodes, (item) => item.tagName === "INPUT")[0];
      const _tags = tags2.value;
      const sizeInMap = states.initialInputHeight || 40;
      input2.style.height = states.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
      states.tagInMultiLine = parseFloat(input2.style.height) > sizeInMap;
      if (states.visible && emptyText.value !== false) {
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      }
    });
  };
  const handleQueryChange = (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && (typeof props2.filterMethod === "function" || typeof props2.remoteMethod === "function")) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    nextTick(() => {
      var _a, _b;
      if (states.visible)
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    });
    states.hoverIndex = -1;
    if (props2.multiple && props2.filterable) {
      nextTick(() => {
        const length = input.value.length * 15 + 20;
        states.inputLength = props2.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }
    if (props2.remote && typeof props2.remoteMethod === "function") {
      states.hoverIndex = -1;
      props2.remoteMethod(val);
    } else if (typeof props2.filterMethod === "function") {
      props2.filterMethod(val);
      triggerRef(groupQueryChange);
    } else {
      states.filteredOptionsCount = states.optionsCount;
      queryChange.value.query = val;
      triggerRef(queryChange);
      triggerRef(groupQueryChange);
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };
  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
    }
  };
  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.groupDisabled);
    const userCreatedOption = optionsInDropdown.filter((n) => n.created)[0];
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };
  const setSelected = () => {
    var _a;
    if (!props2.multiple) {
      const option2 = getOption(props2.modelValue);
      if ((_a = option2.props) == null ? void 0 : _a.created) {
        states.createdLabel = option2.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }
      states.selectedLabel = option2.currentLabel;
      states.selected = option2;
      if (props2.filterable)
        states.query = states.selectedLabel;
      return;
    }
    const result = [];
    if (Array.isArray(props2.modelValue)) {
      props2.modelValue.forEach((value) => {
        result.push(getOption(value));
      });
    }
    states.selected = result;
    nextTick(() => {
      resetInputHeight();
    });
  };
  const getOption = (value) => {
    let option2;
    const isObjectValue = toRawType(value).toLowerCase() === "object";
    const isNull = toRawType(value).toLowerCase() === "null";
    const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
    for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
      const cachedOption = cachedOptionsArray.value[i];
      const isEqualValue = isObjectValue ? getValueByPath(cachedOption.value, props2.valueKey) === getValueByPath(value, props2.valueKey) : cachedOption.value === value;
      if (isEqualValue) {
        option2 = {
          value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }
    if (option2)
      return option2;
    const label2 = !isObjectValue && !isNull && !isUndefined2 ? value : "";
    const newOption = {
      value,
      currentLabel: label2
    };
    if (props2.multiple) {
      newOption.hitState = false;
    }
    return newOption;
  };
  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props2.valueKey;
      if (!props2.multiple) {
        states.hoverIndex = optionsArray.value.findIndex((item) => {
          return getValueByPath(item, valueKey) === getValueByPath(states.selected, valueKey);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
            return optionsArray.value.findIndex((item) => {
              return getValueByPath(item, valueKey) === getValueByPath(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };
  const handleResize = () => {
    var _a, _b;
    resetInputWidth();
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    var _a;
    states.inputWidth = (_a = reference2.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;
  };
  const onInputChange = () => {
    if (props2.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce_1(() => {
    onInputChange();
  }, debounce2.value);
  const debouncedQueryChange = debounce_1((e) => {
    handleQueryChange(e.target.value);
  }, debounce2.value);
  const emitChange = (val) => {
    if (!isEqual_1(props2.modelValue, val)) {
      ctx.emit(CHANGE_EVENT, val);
    }
  };
  const deletePrevTag = (e) => {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value = props2.modelValue.slice();
      value.pop();
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }
    if (e.target.value.length === 1 && props2.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };
  const deleteTag = (event, tag) => {
    const index2 = states.selected.indexOf(tag);
    if (index2 > -1 && !selectDisabled.value) {
      const value = props2.modelValue.slice();
      value.splice(index2, 1);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit("remove-tag", tag.value);
    }
    event.stopPropagation();
  };
  const deleteSelected = (event) => {
    event.stopPropagation();
    const value = props2.multiple ? [] : "";
    if (typeof value !== "string") {
      for (const item of states.selected) {
        if (item.isDisabled)
          value.push(item.value);
      }
    }
    ctx.emit(UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.visible = false;
    ctx.emit("clear");
  };
  const handleOptionSelect = (option2, byClick) => {
    if (props2.multiple) {
      const value = (props2.modelValue || []).slice();
      const optionIndex = getValueIndex(value, option2.value);
      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props2.multipleLimit <= 0 || value.length < props2.multipleLimit) {
        value.push(option2.value);
      }
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props2.filterable)
        input.value.focus();
    } else {
      ctx.emit(UPDATE_MODEL_EVENT, option2.value);
      emitChange(option2.value);
      states.visible = false;
    }
    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible)
      return;
    nextTick(() => {
      scrollToOption(option2);
    });
  };
  const getValueIndex = (arr = [], value) => {
    if (!isObject$a(value))
      return arr.indexOf(value);
    const valueKey = props2.valueKey;
    let index2 = -1;
    arr.some((item, i) => {
      if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {
        index2 = i;
        return true;
      }
      return false;
    });
    return index2;
  };
  const setSoftFocus = () => {
    states.softFocus = true;
    const _input = input.value || reference2.value;
    if (_input) {
      _input.focus();
    }
  };
  const scrollToOption = (option2) => {
    var _a, _b, _c, _d;
    const targetOption = Array.isArray(option2) ? option2[0] : option2;
    let target = null;
    if (targetOption == null ? void 0 : targetOption.value) {
      const options2 = optionsArray.value.filter((item) => item.value === targetOption.value);
      if (options2.length > 0) {
        target = options2[0].$el;
      }
    }
    if (popper2.value && target) {
      const menu = (_c = (_b = (_a = popper2.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, ".el-select-dropdown__wrap");
      if (menu) {
        scrollIntoView(menu, target);
      }
    }
    (_d = scrollbar.value) == null ? void 0 : _d.handleScroll();
  };
  const onOptionCreate = (vm) => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };
  const onOptionDestroy = (key2) => {
    states.optionsCount--;
    states.filteredOptionsCount--;
    states.options.delete(key2);
  };
  const resetInputState = (e) => {
    if (e.code !== EVENT_CODE.backspace)
      toggleLastOptionHitState(false);
    states.inputLength = input.value.length * 15 + 20;
    resetInputHeight();
  };
  const toggleLastOptionHitState = (hit) => {
    if (!Array.isArray(states.selected))
      return;
    const option2 = states.selected[states.selected.length - 1];
    if (!option2)
      return;
    if (hit === true || hit === false) {
      option2.hitState = hit;
      return hit;
    }
    option2.hitState = !option2.hitState;
    return option2.hitState;
  };
  const handleComposition = (event) => {
    const text = event.target.value;
    if (event.type === "compositionend") {
      states.isOnComposition = false;
      nextTick(() => handleQueryChange(text));
    } else {
      const lastCharacter = text[text.length - 1] || "";
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };
  const handleMenuEnter = () => {
    nextTick(() => scrollToOption(states.selected));
  };
  const handleFocus = (event) => {
    if (!states.softFocus) {
      if (props2.automaticDropdown || props2.filterable) {
        states.visible = true;
        if (props2.filterable) {
          states.menuVisibleOnFocus = true;
        }
      }
      ctx.emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };
  const blur = () => {
    states.visible = false;
    reference2.value.blur();
  };
  const handleBlur = (event) => {
    nextTick(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit("blur", event);
      }
    });
    states.softFocus = false;
  };
  const handleClearClick = (event) => {
    deleteSelected(event);
  };
  const handleClose = () => {
    states.visible = false;
  };
  const toggleMenu = () => {
    if (props2.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }
      if (states.visible) {
        (input.value || reference2.value).focus();
      }
    }
  };
  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };
  const getValueKey = (item) => {
    return isObject$a(item.value) ? getValueByPath(item.value, props2.valueKey) : item.value;
  };
  const optionsAllDisabled = computed(() => optionsArray.value.filter((option2) => option2.visible).every((option2) => option2.disabled));
  const navigateOptions = (direction) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (states.options.size === 0 || states.filteredOptionsCount === 0)
      return;
    if (states.isOnComposition)
      return;
    if (!optionsAllDisabled.value) {
      if (direction === "next") {
        states.hoverIndex++;
        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction === "prev") {
        states.hoverIndex--;
        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }
      const option2 = optionsArray.value[states.hoverIndex];
      if (option2.disabled === true || option2.groupDisabled === true || !option2.visible) {
        navigateOptions(direction);
      }
      nextTick(() => scrollToOption(hoverOption.value));
    }
  };
  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly,
    resetInputHeight,
    showClose,
    iconClass,
    showNewOption,
    collapseTagSize,
    setSelected,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    queryChange,
    groupQueryChange,
    reference: reference2,
    input,
    popper: popper2,
    tags: tags2,
    selectWrapper,
    scrollbar
  };
};
var script$1$5 = defineComponent({
  name: "ElSelect",
  componentName: "ElSelect",
  components: {
    ElInput: _Input,
    ElSelectMenu: script$2$3,
    ElOption: script$3$1,
    ElTag,
    ElScrollbar: _Scrollbar,
    ElPopper: _Popper
  },
  directives: { ClickOutside: ClickOutside$1 },
  props: {
    name: String,
    id: String,
    modelValue: [Array, String, Number, Boolean, Object],
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: String,
      default: "el-icon-circle-close"
    }
  },
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(props2, ctx) {
    const { t } = useLocaleInject();
    const states = useSelectStates(props2);
    const {
      optionsArray,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      setSelected,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconClass,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      reference: reference2,
      input,
      popper: popper2,
      tags: tags2,
      selectWrapper,
      scrollbar,
      queryChange,
      groupQueryChange
    } = useSelect(props2, states, ctx);
    const { focus } = useFocus(reference2);
    const {
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query: query2,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options: options2,
      cachedOptions,
      optionsCount,
      prefixWidth,
      tagInMultiLine
    } = toRefs(states);
    provide(selectKey, reactive({
      props: props2,
      options: options2,
      optionsArray,
      cachedOptions,
      optionsCount,
      filteredOptionsCount,
      hoverIndex,
      handleOptionSelect,
      onOptionCreate,
      onOptionDestroy,
      selectWrapper,
      selected,
      setSelected,
      queryChange,
      groupQueryChange
    }));
    onMounted(() => {
      states.cachedPlaceHolder = currentPlaceholder.value = props2.placeholder || t("el.select.placeholder");
      if (props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
        currentPlaceholder.value = "";
      }
      addResizeListener(selectWrapper.value, handleResize);
      if (reference2.value && reference2.value.$el) {
        const sizeMap = {
          medium: 36,
          small: 32,
          mini: 28
        };
        const input2 = reference2.value.input;
        states.initialInputHeight = input2.getBoundingClientRect().height || sizeMap[selectSize.value];
      }
      if (props2.remote && props2.multiple) {
        resetInputHeight();
      }
      nextTick(() => {
        if (reference2.value.$el) {
          inputWidth.value = reference2.value.$el.getBoundingClientRect().width;
        }
        if (ctx.slots.prefix) {
          const inputChildNodes = reference2.value.$el.childNodes;
          const input2 = [].filter.call(inputChildNodes, (item) => item.tagName === "INPUT")[0];
          const prefix = reference2.value.$el.querySelector(".el-input__prefix");
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
          if (states.prefixWidth) {
            input2.style.paddingLeft = `${Math.max(states.prefixWidth, 30)}px`;
          }
        }
      });
      setSelected();
    });
    onBeforeUnmount(() => {
      removeResizeListener(selectWrapper.value, handleResize);
    });
    if (props2.multiple && !Array.isArray(props2.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, []);
    }
    if (!props2.multiple && Array.isArray(props2.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, "");
    }
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = popper2.value) == null ? void 0 : _a.popperRef;
    });
    return {
      Effect,
      tagInMultiLine,
      prefixWidth,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query: query2,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options: options2,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconClass,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      focus,
      reference: reference2,
      input,
      popper: popper2,
      popperPaneRef,
      tags: tags2,
      selectWrapper,
      scrollbar
    };
  }
});
const _hoisted_1$1$3 = { class: "select-trigger" };
const _hoisted_2$1$2 = { key: 0 };
const _hoisted_3$1$2 = { class: "el-select__tags-text" };
const _hoisted_4$g = ["disabled", "autocomplete"];
const _hoisted_5$c = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
const _hoisted_6$a = {
  key: 1,
  class: "el-select-dropdown__empty"
};
function render$1$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_option = resolveComponent("el-option");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_select_menu = resolveComponent("el-select-menu");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "selectWrapper",
    class: normalizeClass(["el-select", [_ctx.selectSize ? "el-select--" + _ctx.selectSize : ""]]),
    onClick: _cache[25] || (_cache[25] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [
    createVNode(_component_el_popper, {
      ref: "popper",
      visible: _ctx.dropMenuVisible,
      "onUpdate:visible": _cache[24] || (_cache[24] = ($event) => _ctx.dropMenuVisible = $event),
      placement: "bottom-start",
      "append-to-body": _ctx.popperAppendToBody,
      "popper-class": `el-select__popper ${_ctx.popperClass}`,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      "manual-mode": "",
      effect: _ctx.Effect.LIGHT,
      pure: "",
      trigger: "click",
      transition: "el-zoom-in-top",
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      onBeforeEnter: _ctx.handleMenuEnter
    }, {
      trigger: withCtx(() => [
        createElementVNode("div", _hoisted_1$1$3, [
          _ctx.multiple ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref: "tags",
            class: "el-select__tags",
            style: normalizeStyle({ maxWidth: _ctx.inputWidth - 32 + "px", width: "100%" })
          }, [
            _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createElementBlock("span", _hoisted_2$1$2, [
              createVNode(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                size: _ctx.collapseTagSize,
                hit: _ctx.selected[0].hitState,
                type: "info",
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
              }, {
                default: withCtx(() => [
                  createElementVNode("span", {
                    class: "el-select__tags-text",
                    style: normalizeStyle({ maxWidth: _ctx.inputWidth - 123 + "px" })
                  }, toDisplayString(_ctx.selected[0].currentLabel), 5)
                ]),
                _: 1
              }, 8, ["closable", "size", "hit"]),
              _ctx.selected.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: "info",
                "disable-transitions": ""
              }, {
                default: withCtx(() => [
                  createElementVNode("span", _hoisted_3$1$2, "+ " + toDisplayString(_ctx.selected.length - 1), 1)
                ]),
                _: 1
              }, 8, ["size"])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            createCommentVNode(" <div> "),
            !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
              key: 1,
              onAfterLeave: _ctx.resetInputHeight
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  style: normalizeStyle({
                    marginLeft: _ctx.prefixWidth && _ctx.selected.length ? `${_ctx.prefixWidth}px` : null
                  })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                    return openBlock(), createBlock(_component_el_tag, {
                      key: _ctx.getValueKey(item),
                      closable: !_ctx.selectDisabled && !item.isDisabled,
                      size: _ctx.collapseTagSize,
                      hit: item.hitState,
                      type: "info",
                      "disable-transitions": "",
                      onClose: ($event) => _ctx.deleteTag($event, item)
                    }, {
                      default: withCtx(() => [
                        createElementVNode("span", {
                          class: "el-select__tags-text",
                          style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                        }, toDisplayString(item.currentLabel), 5)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "onClose"]);
                  }), 128))
                ], 4)
              ]),
              _: 1
            }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
            createCommentVNode(" </div> "),
            _ctx.filterable ? withDirectives((openBlock(), createElementBlock("input", {
              key: 2,
              ref: "input",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
              type: "text",
              class: normalizeClass(["el-select__input", [_ctx.selectSize ? `is-${_ctx.selectSize}` : ""]]),
              disabled: _ctx.selectDisabled,
              autocomplete: _ctx.autocomplete,
              style: normalizeStyle({
                marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : null,
                flexGrow: "1",
                width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                maxWidth: `${_ctx.inputWidth - 42}px`
              }),
              onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
              onKeydown: [
                _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
                _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                _cache[10] || (_cache[10] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                _cache[11] || (_cache[11] = withKeys(($event) => _ctx.visible = false, ["tab"]))
              ],
              onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
            }, null, 46, _hoisted_4$g)), [
              [vModelText, _ctx.query]
            ]) : createCommentVNode("v-if", true)
          ], 4)) : createCommentVNode("v-if", true),
          createVNode(_component_el_input, {
            id: _ctx.id,
            ref: "reference",
            modelValue: _ctx.selectedLabel,
            "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => _ctx.selectedLabel = $event),
            type: "text",
            placeholder: _ctx.currentPlaceholder,
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            size: _ctx.selectSize,
            disabled: _ctx.selectDisabled,
            readonly: _ctx.readonly,
            "validate-event": false,
            class: normalizeClass({ "is-focus": _ctx.visible }),
            tabindex: _ctx.multiple && _ctx.filterable ? "-1" : null,
            onFocus: _ctx.handleFocus,
            onBlur: _ctx.handleBlur,
            onInput: _ctx.debouncedOnInputChange,
            onPaste: _ctx.debouncedOnInputChange,
            onCompositionstart: _ctx.handleComposition,
            onCompositionupdate: _ctx.handleComposition,
            onCompositionend: _ctx.handleComposition,
            onKeydown: [
              _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
              _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
              withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
              _cache[20] || (_cache[20] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
              _cache[21] || (_cache[21] = withKeys(($event) => _ctx.visible = false, ["tab"]))
            ],
            onMouseenter: _cache[22] || (_cache[22] = ($event) => _ctx.inputHovering = true),
            onMouseleave: _cache[23] || (_cache[23] = ($event) => _ctx.inputHovering = false)
          }, createSlots({
            suffix: withCtx(() => [
              withDirectives(createElementVNode("i", {
                class: normalizeClass([
                  "el-select__caret",
                  "el-input__icon",
                  "el-icon-" + _ctx.iconClass
                ])
              }, null, 2), [
                [vShow, !_ctx.showClose]
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("i", {
                key: 0,
                class: normalizeClass(`el-select__caret el-input__icon ${_ctx.clearIcon}`),
                onClick: _cache[16] || (_cache[16] = (...args) => _ctx.handleClearClick && _ctx.handleClearClick(...args))
              }, null, 2)) : createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: withCtx(() => [
                createElementVNode("div", _hoisted_5$c, [
                  renderSlot(_ctx.$slots, "prefix")
                ])
              ])
            } : void 0
          ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
        ])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_select_menu, null, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_scrollbar, {
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": "el-select-dropdown__wrap",
              "view-class": "el-select-dropdown__list",
              class: normalizeClass({
                "is-empty": !_ctx.allowCreate && _ctx.query && _ctx.filteredOptionsCount === 0
              })
            }, {
              default: withCtx(() => [
                _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                  key: 0,
                  value: _ctx.query,
                  created: true
                }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]), [
              [vShow, _ctx.options.size > 0 && !_ctx.loading]
            ]),
            _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_6$a, toDisplayString(_ctx.emptyText), 1))
            ], 2112)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "append-to-body", "popper-class", "effect", "onBeforeEnter"])
  ], 2)), [
    [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
  ]);
}
script$1$5.render = render$1$5;
script$1$5.__file = "packages/components/select/src/select.vue";
var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key2, value) => key2 in obj ? __defProp$8(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$8.call(b2, prop))
      __defNormalProp$8(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b2)) {
      if (__propIsEnum$8.call(b2, prop))
        __defNormalProp$8(a2, prop, b2[prop]);
    }
  return a2;
};
var script$b = defineComponent({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const visible = ref(true);
    const instance = getCurrentInstance();
    const children = ref([]);
    provide(selectGroupKey, reactive(__spreadValues$8({}, toRefs(props2))));
    const select = inject(selectKey);
    onMounted(() => {
      children.value = flattedChildren(instance.subTree);
    });
    const flattedChildren = (node) => {
      const children2 = [];
      if (Array.isArray(node.children)) {
        node.children.forEach((child) => {
          var _a;
          if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
            children2.push(child.component.proxy);
          } else if ((_a = child.children) == null ? void 0 : _a.length) {
            children2.push(...flattedChildren(child));
          }
        });
      }
      return children2;
    };
    const { groupQueryChange } = toRaw(select);
    watch(groupQueryChange, () => {
      visible.value = children.value.some((option2) => option2.visible === true);
    });
    return {
      visible
    };
  }
});
const _hoisted_1$B = { class: "el-select-group__wrap" };
const _hoisted_2$t = { class: "el-select-group__title" };
const _hoisted_3$o = { class: "el-select-group" };
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("ul", _hoisted_1$B, [
    createElementVNode("li", _hoisted_2$t, toDisplayString(_ctx.label), 1),
    createElementVNode("li", null, [
      createElementVNode("ul", _hoisted_3$o, [
        renderSlot(_ctx.$slots, "default")
      ])
    ])
  ], 512)), [
    [vShow, _ctx.visible]
  ]);
}
script$b.render = render$b;
script$b.__file = "packages/components/select/src/option-group.vue";
const ElSelect = withInstall(script$1$5, {
  Option: script$3$1,
  OptionGroup: script$b
});
const ElOption = withNoopInstall(script$3$1);
withNoopInstall(script$b);
var script$a = defineComponent({
  name: "ElProgress",
  props: {
    type: {
      type: String,
      default: "line",
      validator: (val) => ["line", "circle", "dashboard"].indexOf(val) > -1
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: (val) => val >= 0 && val <= 100
    },
    status: {
      type: String,
      default: "",
      validator: (val) => ["", "success", "exception", "warning"].indexOf(val) > -1
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 3
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: String,
      default: "round"
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    },
    color: {
      type: [String, Array, Function],
      default: ""
    },
    format: {
      type: Function,
      default: (percentage) => `${percentage}%`
    }
  },
  setup(props2) {
    const barStyle = computed(() => {
      return {
        width: `${props2.percentage}%`,
        animationDuration: `${props2.duration}s`,
        backgroundColor: getCurrentColor(props2.percentage)
      };
    });
    const relativeStrokeWidth = computed(() => {
      return (props2.strokeWidth / props2.width * 100).toFixed(1);
    });
    const radius = computed(() => {
      if (props2.type === "circle" || props2.type === "dashboard") {
        return parseInt(`${50 - parseFloat(relativeStrokeWidth.value) / 2}`, 10);
      } else {
        return 0;
      }
    });
    const trackPath = computed(() => {
      const r = radius.value;
      const isDashboard = props2.type === "dashboard";
      return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
    });
    const perimeter = computed(() => {
      return 2 * Math.PI * radius.value;
    });
    const rate = computed(() => {
      return props2.type === "dashboard" ? 0.75 : 1;
    });
    const strokeDashoffset = computed(() => {
      const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
      return `${offset2}px`;
    });
    const trailPathStyle = computed(() => {
      return {
        strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value
      };
    });
    const circlePathStyle = computed(() => {
      return {
        strokeDasharray: `${perimeter.value * rate.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value,
        transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease"
      };
    });
    const stroke = computed(() => {
      let ret;
      if (props2.color) {
        ret = getCurrentColor(props2.percentage);
      } else {
        switch (props2.status) {
          case "success":
            ret = "#13ce66";
            break;
          case "exception":
            ret = "#ff4949";
            break;
          case "warning":
            ret = "#e6a23c";
            break;
          default:
            ret = "#20a0ff";
        }
      }
      return ret;
    });
    const iconClass = computed(() => {
      if (props2.status === "warning") {
        return "el-icon-warning";
      }
      if (props2.type === "line") {
        return props2.status === "success" ? "el-icon-circle-check" : "el-icon-circle-close";
      } else {
        return props2.status === "success" ? "el-icon-check" : "el-icon-close";
      }
    });
    const progressTextSize = computed(() => {
      return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
    });
    const content = computed(() => {
      return props2.format(props2.percentage);
    });
    const getCurrentColor = (percentage) => {
      var _a;
      const { color } = props2;
      if (typeof color === "function") {
        return color(percentage);
      } else if (typeof color === "string") {
        return color;
      } else {
        const span = 100 / color.length;
        const seriesColors = color.map((seriesColor, index2) => {
          if (typeof seriesColor === "string") {
            return {
              color: seriesColor,
              percentage: (index2 + 1) * span
            };
          }
          return seriesColor;
        });
        const colorArray = seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
        for (let i = 0; i < colorArray.length; i++) {
          if (colorArray[i].percentage > percentage) {
            return colorArray[i].color;
          }
        }
        return (_a = colorArray[colorArray.length - 1]) == null ? void 0 : _a.color;
      }
    };
    const slotData = computed(() => {
      return {
        percentage: props2.percentage
      };
    });
    return {
      barStyle,
      relativeStrokeWidth,
      radius,
      trackPath,
      perimeter,
      rate,
      strokeDashoffset,
      trailPathStyle,
      circlePathStyle,
      stroke,
      iconClass,
      progressTextSize,
      content,
      getCurrentColor,
      slotData
    };
  }
});
const _hoisted_1$A = ["aria-valuenow"];
const _hoisted_2$s = {
  key: 0,
  class: "el-progress-bar"
};
const _hoisted_3$n = {
  key: 0,
  class: "el-progress-bar__innerText"
};
const _hoisted_4$f = { viewBox: "0 0 100 100" };
const _hoisted_5$b = ["d", "stroke-width"];
const _hoisted_6$9 = ["d", "stroke", "stroke-linecap", "stroke-width"];
const _hoisted_7$7 = { key: 0 };
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-progress", [
      `el-progress--${_ctx.type}`,
      _ctx.status ? `is-${_ctx.status}` : "",
      {
        "el-progress--without-text": !_ctx.showText,
        "el-progress--text-inside": _ctx.textInside
      }
    ]]),
    role: "progressbar",
    "aria-valuenow": _ctx.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    _ctx.type === "line" ? (openBlock(), createElementBlock("div", _hoisted_2$s, [
      createElementVNode("div", {
        class: "el-progress-bar__outer",
        style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
      }, [
        createElementVNode("div", {
          class: normalizeClass([
            "el-progress-bar__inner",
            { "el-progress-bar__inner--indeterminate": _ctx.indeterminate }
          ]),
          style: normalizeStyle(_ctx.barStyle)
        }, [
          (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
              createElementVNode("span", null, toDisplayString(_ctx.content), 1)
            ])
          ])) : createCommentVNode("v-if", true)
        ], 6)
      ], 4)
    ])) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: "el-progress-circle",
      style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
    }, [
      (openBlock(), createElementBlock("svg", _hoisted_4$f, [
        createElementVNode("path", {
          class: "el-progress-circle__track",
          d: _ctx.trackPath,
          stroke: "#e5e9f2",
          "stroke-width": _ctx.relativeStrokeWidth,
          fill: "none",
          style: normalizeStyle(_ctx.trailPathStyle)
        }, null, 12, _hoisted_5$b),
        createElementVNode("path", {
          class: "el-progress-circle__path",
          d: _ctx.trackPath,
          stroke: _ctx.stroke,
          fill: "none",
          "stroke-linecap": _ctx.strokeLinecap,
          "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
          style: normalizeStyle(_ctx.circlePathStyle)
        }, null, 12, _hoisted_6$9)
      ]))
    ], 4)),
    (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "el-progress__text",
      style: normalizeStyle({ fontSize: `${_ctx.progressTextSize}px` })
    }, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
        !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_7$7, toDisplayString(_ctx.content), 1)) : (openBlock(), createElementBlock("i", {
          key: 1,
          class: normalizeClass(_ctx.iconClass)
        }, null, 2))
      ])
    ], 4)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$A);
}
script$a.render = render$a;
script$a.__file = "packages/components/progress/src/index.vue";
script$a.install = (app) => {
  app.component(script$a.name, script$a);
};
const _Progress = script$a;
var script$9 = defineComponent({
  name: "ElRate",
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: [Array, Object],
      default: () => ["#F7BA2A", "#F7BA2A", "#F7BA2A"]
    },
    voidColor: {
      type: String,
      default: "#C6D1DE"
    },
    disabledVoidColor: {
      type: String,
      default: "#EFF2F7"
    },
    iconClasses: {
      type: [Array, Object],
      default: () => ["el-icon-star-on", "el-icon-star-on", "el-icon-star-on"]
    },
    voidIconClass: {
      type: String,
      default: "el-icon-star-off"
    },
    disabledVoidIconClass: {
      type: String,
      default: "el-icon-star-on"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: false
    },
    showScore: {
      type: Boolean,
      default: false
    },
    textColor: {
      type: String,
      default: "#1f2d3d"
    },
    texts: {
      type: Array,
      default: () => [
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
      ]
    },
    scoreTemplate: {
      type: String,
      default: "{value}"
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, { emit: emit2 }) {
    const elForm2 = inject(elFormKey, {});
    const currentValue = ref(props2.modelValue);
    const rateDisabled = computed(() => props2.disabled || elForm2.disabled);
    const text = computed(() => {
      let result = "";
      if (props2.showScore) {
        result = props2.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props2.modelValue}` : `${currentValue.value}`);
      } else if (props2.showText) {
        result = props2.texts[Math.ceil(currentValue.value) - 1];
      }
      return result;
    });
    function getValueFromMap(value, map) {
      const matchedKeys = Object.keys(map).filter((key2) => {
        const val = map[key2];
        const excluded = isObject$a(val) ? val.excluded : false;
        return excluded ? value < key2 : value <= key2;
      }).sort((a2, b2) => a2 - b2);
      const matchedValue = map[matchedKeys[0]];
      return isObject$a(matchedValue) ? matchedValue.value : matchedValue || "";
    }
    const valueDecimal = computed(() => props2.modelValue * 100 - Math.floor(props2.modelValue) * 100);
    const colorMap = computed(() => isArray$6(props2.colors) ? {
      [props2.lowThreshold]: props2.colors[0],
      [props2.highThreshold]: { value: props2.colors[1], excluded: true },
      [props2.max]: props2.colors[2]
    } : props2.colors);
    const activeColor2 = computed(() => getValueFromMap(currentValue.value, colorMap.value));
    const decimalStyle = computed(() => {
      let width2 = "";
      if (rateDisabled.value) {
        width2 = `${valueDecimal.value}%`;
      } else if (props2.allowHalf) {
        width2 = "50%";
      }
      return {
        color: activeColor2.value,
        width: width2
      };
    });
    const classMap = computed(() => isArray$6(props2.iconClasses) ? {
      [props2.lowThreshold]: props2.iconClasses[0],
      [props2.highThreshold]: {
        value: props2.iconClasses[1],
        excluded: true
      },
      [props2.max]: props2.iconClasses[2]
    } : props2.iconClasses);
    const decimalIconClass = computed(() => getValueFromMap(props2.modelValue, classMap.value));
    const voidClass = computed(() => rateDisabled.value ? props2.disabledVoidIconClass : props2.voidIconClass);
    const activeClass = computed(() => getValueFromMap(currentValue.value, classMap.value));
    const classes = computed(() => {
      const result = Array(props2.max);
      const threshold = currentValue.value;
      result.fill(activeClass.value, 0, threshold);
      result.fill(voidClass.value, threshold, props2.max);
      return result;
    });
    const pointerAtLeftHalf = ref(true);
    watch(() => props2.modelValue, (val) => {
      currentValue.value = val;
      pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
    });
    function showDecimalIcon(item) {
      const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props2.modelValue && item > props2.modelValue;
      const showWhenAllowHalf = props2.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
      return showWhenDisabled || showWhenAllowHalf;
    }
    function getIconStyle(item) {
      const voidColor = rateDisabled.value ? props2.disabledVoidColor : props2.voidColor;
      return {
        color: item <= currentValue.value ? activeColor2.value : voidColor
      };
    }
    function selectValue(value) {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf && pointerAtLeftHalf.value) {
        emit2(UPDATE_MODEL_EVENT, currentValue.value);
        if (props2.modelValue !== currentValue.value) {
          emit2("change", currentValue.value);
        }
      } else {
        emit2(UPDATE_MODEL_EVENT, value);
        if (props2.modelValue !== value) {
          emit2("change", value);
        }
      }
    }
    function handleKey(e) {
      if (rateDisabled.value) {
        return;
      }
      let _currentValue = currentValue.value;
      const code = e.code;
      if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
        if (props2.allowHalf) {
          _currentValue += 0.5;
        } else {
          _currentValue += 1;
        }
        e.stopPropagation();
        e.preventDefault();
      } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
        if (props2.allowHalf) {
          _currentValue -= 0.5;
        } else {
          _currentValue -= 1;
        }
        e.stopPropagation();
        e.preventDefault();
      }
      _currentValue = _currentValue < 0 ? 0 : _currentValue;
      _currentValue = _currentValue > props2.max ? props2.max : _currentValue;
      emit2(UPDATE_MODEL_EVENT, _currentValue);
      emit2("change", _currentValue);
      return _currentValue;
    }
    const hoverIndex = ref(-1);
    function setCurrentValue(value, event) {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf) {
        let target = event.target;
        if (hasClass(target, "el-rate__item")) {
          target = target.querySelector(".el-rate__icon");
        }
        if (hasClass(target, "el-rate__decimal")) {
          target = target.parentNode;
        }
        pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
        currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
      } else {
        currentValue.value = value;
      }
      hoverIndex.value = value;
    }
    function resetCurrentValue() {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf) {
        pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
      }
      currentValue.value = props2.modelValue;
      hoverIndex.value = -1;
    }
    if (!props2.modelValue) {
      emit2(UPDATE_MODEL_EVENT, 0);
    }
    return {
      hoverIndex,
      currentValue,
      rateDisabled,
      text,
      decimalStyle,
      decimalIconClass,
      classes,
      showDecimalIcon,
      getIconStyle,
      selectValue,
      handleKey,
      setCurrentValue,
      resetCurrentValue
    };
  }
});
const _hoisted_1$z = ["aria-valuenow", "aria-valuetext", "aria-valuemax"];
const _hoisted_2$r = ["onMousemove", "onClick"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "el-rate",
    role: "slider",
    "aria-valuenow": _ctx.currentValue,
    "aria-valuetext": _ctx.text,
    "aria-valuemin": "0",
    "aria-valuemax": _ctx.max,
    tabindex: "0",
    onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleKey && _ctx.handleKey(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.max, (item, key2) => {
      return openBlock(), createElementBlock("span", {
        key: key2,
        class: "el-rate__item",
        style: normalizeStyle({ cursor: _ctx.rateDisabled ? "auto" : "pointer" }),
        onMousemove: ($event) => _ctx.setCurrentValue(item, $event),
        onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.resetCurrentValue && _ctx.resetCurrentValue(...args)),
        onClick: ($event) => _ctx.selectValue(item)
      }, [
        createElementVNode("i", {
          class: normalizeClass([[_ctx.classes[item - 1], { hover: _ctx.hoverIndex === item }], "el-rate__icon"]),
          style: normalizeStyle(_ctx.getIconStyle(item))
        }, [
          _ctx.showDecimalIcon(item) ? (openBlock(), createElementBlock("i", {
            key: 0,
            class: normalizeClass([_ctx.decimalIconClass, "el-rate__decimal"]),
            style: normalizeStyle(_ctx.decimalStyle)
          }, null, 6)) : createCommentVNode("v-if", true)
        ], 6)
      ], 44, _hoisted_2$r);
    }), 128)),
    _ctx.showText || _ctx.showScore ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "el-rate__text",
      style: normalizeStyle({ color: _ctx.textColor })
    }, toDisplayString(_ctx.text), 5)) : createCommentVNode("v-if", true)
  ], 40, _hoisted_1$z);
}
script$9.render = render$9;
script$9.__file = "packages/components/rate/src/index.vue";
script$9.install = (app) => {
  app.component(script$9.name, script$9);
};
const _Rate = script$9;
const ElRate = _Rate;
var Row = defineComponent({
  name: "ElRow",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      default: "start"
    },
    align: {
      type: String,
      default: "top"
    }
  },
  setup(props2, { slots }) {
    const gutter2 = computed(() => props2.gutter);
    provide("ElRow", {
      gutter: gutter2
    });
    const style = computed(() => {
      const ret = {
        marginLeft: "",
        marginRight: ""
      };
      if (props2.gutter) {
        ret.marginLeft = `-${props2.gutter / 2}px`;
        ret.marginRight = ret.marginLeft;
      }
      return ret;
    });
    return () => {
      var _a;
      return h$1(props2.tag, {
        class: [
          "el-row",
          props2.justify !== "start" ? `is-justify-${props2.justify}` : "",
          props2.align !== "top" ? `is-align-${props2.align}` : ""
        ],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const _Row = Row;
_Row.install = (app) => {
  app.component(_Row.name, _Row);
};
const ElRow = _Row;
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const useTooltip = (props2, formatTooltip, showTooltip2) => {
  const tooltip = ref(null);
  const tooltipVisible = ref(false);
  const enableFormat = computed(() => {
    return formatTooltip.value instanceof Function;
  });
  const formatValue = computed(() => {
    return enableFormat.value && formatTooltip.value(props2.modelValue) || props2.modelValue;
  });
  const displayTooltip = debounce_1(() => {
    showTooltip2.value && (tooltipVisible.value = true);
  }, 50);
  const hideTooltip = debounce_1(() => {
    showTooltip2.value && (tooltipVisible.value = false);
  }, 50);
  return {
    tooltip,
    tooltipVisible,
    formatValue,
    displayTooltip,
    hideTooltip
  };
};
const useSliderButton = (props2, initData, emit2) => {
  const {
    disabled: disabled2,
    min: min2,
    max: max2,
    step,
    showTooltip: showTooltip2,
    precision,
    sliderSize,
    formatTooltip,
    emitChange,
    resetSize,
    updateDragging
  } = inject("SliderProvider");
  const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props2, formatTooltip, showTooltip2);
  const currentPosition = computed(() => {
    return `${(props2.modelValue - min2.value) / (max2.value - min2.value) * 100}%`;
  });
  const wrapperStyle = computed(() => {
    return props2.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
  });
  const handleMouseEnter = () => {
    initData.hovering = true;
    displayTooltip();
  };
  const handleMouseLeave = () => {
    initData.hovering = false;
    if (!initData.dragging) {
      hideTooltip();
    }
  };
  const onButtonDown = (event) => {
    if (disabled2.value)
      return;
    event.preventDefault();
    onDragStart(event);
    on(window, "mousemove", onDragging);
    on(window, "touchmove", onDragging);
    on(window, "mouseup", onDragEnd);
    on(window, "touchend", onDragEnd);
    on(window, "contextmenu", onDragEnd);
  };
  const onLeftKeyDown = () => {
    if (disabled2.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const onRightKeyDown = () => {
    if (disabled2.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const getClientXY = (event) => {
    let clientX;
    let clientY;
    if (event.type.startsWith("touch")) {
      clientY = event.touches[0].clientY;
      clientX = event.touches[0].clientX;
    } else {
      clientY = event.clientY;
      clientX = event.clientX;
    }
    return {
      clientX,
      clientY
    };
  };
  const onDragStart = (event) => {
    initData.dragging = true;
    initData.isClick = true;
    const { clientX, clientY } = getClientXY(event);
    if (props2.vertical) {
      initData.startY = clientY;
    } else {
      initData.startX = clientX;
    }
    initData.startPosition = parseFloat(currentPosition.value);
    initData.newPosition = initData.startPosition;
  };
  const onDragging = (event) => {
    if (initData.dragging) {
      initData.isClick = false;
      displayTooltip();
      resetSize();
      let diff;
      const { clientX, clientY } = getClientXY(event);
      if (props2.vertical) {
        initData.currentY = clientY;
        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
      } else {
        initData.currentX = clientX;
        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
      }
      initData.newPosition = initData.startPosition + diff;
      setPosition(initData.newPosition);
    }
  };
  const onDragEnd = () => {
    if (initData.dragging) {
      setTimeout(() => {
        initData.dragging = false;
        if (!initData.hovering) {
          hideTooltip();
        }
        if (!initData.isClick) {
          setPosition(initData.newPosition);
          emitChange();
        }
      }, 0);
      off(window, "mousemove", onDragging);
      off(window, "touchmove", onDragging);
      off(window, "mouseup", onDragEnd);
      off(window, "touchend", onDragEnd);
      off(window, "contextmenu", onDragEnd);
    }
  };
  const setPosition = (newPosition) => __async$2(void 0, null, function* () {
    if (newPosition === null || isNaN(newPosition))
      return;
    if (newPosition < 0) {
      newPosition = 0;
    } else if (newPosition > 100) {
      newPosition = 100;
    }
    const lengthPerStep = 100 / ((max2.value - min2.value) / step.value);
    const steps = Math.round(newPosition / lengthPerStep);
    let value = steps * lengthPerStep * (max2.value - min2.value) * 0.01 + min2.value;
    value = parseFloat(value.toFixed(precision.value));
    emit2(UPDATE_MODEL_EVENT, value);
    if (!initData.dragging && props2.modelValue !== initData.oldValue) {
      initData.oldValue = props2.modelValue;
    }
    yield nextTick();
    initData.dragging && displayTooltip();
    tooltip.value.updatePopper();
  });
  watch(() => initData.dragging, (val) => {
    updateDragging(val);
  });
  return {
    tooltip,
    tooltipVisible,
    showTooltip: showTooltip2,
    wrapperStyle,
    formatValue,
    handleMouseEnter,
    handleMouseLeave,
    onButtonDown,
    onLeftKeyDown,
    onRightKeyDown,
    setPosition
  };
};
var script$2$2 = defineComponent({
  name: "ElSliderButton",
  components: {
    ElTooltip: _Tooltip
  },
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    tooltipClass: {
      type: String,
      default: ""
    }
  },
  emits: [UPDATE_MODEL_EVENT],
  setup(props2, { emit: emit2 }) {
    const initData = reactive({
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: props2.modelValue
    });
    const {
      tooltip,
      showTooltip: showTooltip2,
      tooltipVisible,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition
    } = useSliderButton(props2, initData, emit2);
    const { hovering, dragging } = toRefs(initData);
    return {
      tooltip,
      tooltipVisible,
      showTooltip: showTooltip2,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition,
      hovering,
      dragging
    };
  }
});
function render$1$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("div", {
    ref: "button",
    class: normalizeClass(["el-slider__button-wrapper", { hover: _ctx.hovering, dragging: _ctx.dragging }]),
    style: normalizeStyle(_ctx.wrapperStyle),
    tabindex: "0",
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onBlur: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onKeydown: [
      _cache[7] || (_cache[7] = withKeys((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["left"])),
      _cache[8] || (_cache[8] = withKeys((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["right"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["prevent"]), ["down"])),
      _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["prevent"]), ["up"]))
    ]
  }, [
    createVNode(_component_el_tooltip, {
      ref: "tooltip",
      modelValue: _ctx.tooltipVisible,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tooltipVisible = $event),
      placement: "top",
      "stop-popper-mouse-event": false,
      "popper-class": _ctx.tooltipClass,
      disabled: !_ctx.showTooltip,
      manual: ""
    }, {
      content: withCtx(() => [
        createElementVNode("span", null, toDisplayString(_ctx.formatValue), 1)
      ]),
      default: withCtx(() => [
        createElementVNode("div", {
          class: normalizeClass(["el-slider__button", { hover: _ctx.hovering, dragging: _ctx.dragging }])
        }, null, 2)
      ]),
      _: 1
    }, 8, ["modelValue", "popper-class", "disabled"])
  ], 38);
}
script$2$2.render = render$1$4;
script$2$2.__file = "packages/components/slider/src/button.vue";
var script$1$4 = defineComponent({
  name: "ElMarker",
  props: {
    mark: {
      type: [String, Object],
      default: () => void 0
    }
  },
  setup(props2) {
    const label2 = computed(() => {
      return typeof props2.mark === "string" ? props2.mark : props2.mark.label;
    });
    return {
      label: label2
    };
  },
  render() {
    var _a;
    return h$1("div", {
      class: "el-slider__marks-text",
      style: (_a = this.mark) == null ? void 0 : _a.style
    }, this.label);
  }
});
script$1$4.__file = "packages/components/slider/src/marker.vue";
const useMarks = (props2) => {
  return computed(() => {
    if (!props2.marks) {
      return [];
    }
    const marksKeys = Object.keys(props2.marks);
    return marksKeys.map(parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props2.max && point >= props2.min).map((point) => ({
      point,
      position: (point - props2.min) * 100 / (props2.max - props2.min),
      mark: props2.marks[point]
    }));
  });
};
var __async$1$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const useSlide = (props2, initData, emit2) => {
  const elForm2 = inject(elFormKey, {});
  const elFormItem2 = inject(elFormItemKey, {});
  const slider = shallowRef(null);
  const firstButton = ref(null);
  const secondButton = ref(null);
  const buttonRefs = {
    firstButton,
    secondButton
  };
  const sliderDisabled = computed(() => {
    return props2.disabled || elForm2.disabled || false;
  });
  const minValue = computed(() => {
    return Math.min(initData.firstValue, initData.secondValue);
  });
  const maxValue = computed(() => {
    return Math.max(initData.firstValue, initData.secondValue);
  });
  const barSize = computed(() => {
    return props2.range ? `${100 * (maxValue.value - minValue.value) / (props2.max - props2.min)}%` : `${100 * (initData.firstValue - props2.min) / (props2.max - props2.min)}%`;
  });
  const barStart = computed(() => {
    return props2.range ? `${100 * (minValue.value - props2.min) / (props2.max - props2.min)}%` : "0%";
  });
  const runwayStyle = computed(() => {
    return props2.vertical ? { height: props2.height } : {};
  });
  const barStyle = computed(() => {
    return props2.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    };
  });
  const resetSize = () => {
    if (slider.value) {
      initData.sliderSize = slider.value[`client${props2.vertical ? "Height" : "Width"}`];
    }
  };
  const setPosition = (percent) => {
    const targetValue = props2.min + percent * (props2.max - props2.min) / 100;
    if (!props2.range) {
      firstButton.value.setPosition(percent);
      return;
    }
    let buttonRefName;
    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
      buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
    } else {
      buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
    }
    buttonRefs[buttonRefName].value.setPosition(percent);
  };
  const setFirstValue = (firstValue) => {
    initData.firstValue = firstValue;
    _emit(props2.range ? [minValue.value, maxValue.value] : firstValue);
  };
  const setSecondValue = (secondValue) => {
    initData.secondValue = secondValue;
    if (props2.range) {
      _emit([minValue.value, maxValue.value]);
    }
  };
  const _emit = (val) => {
    emit2(UPDATE_MODEL_EVENT, val);
    emit2(INPUT_EVENT, val);
  };
  const emitChange = () => __async$1$1(void 0, null, function* () {
    yield nextTick();
    emit2(CHANGE_EVENT, props2.range ? [minValue.value, maxValue.value] : props2.modelValue);
  });
  const onSliderClick = (event) => {
    if (sliderDisabled.value || initData.dragging)
      return;
    resetSize();
    if (props2.vertical) {
      const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
      setPosition((sliderOffsetBottom - event.clientY) / initData.sliderSize * 100);
    } else {
      const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
      setPosition((event.clientX - sliderOffsetLeft) / initData.sliderSize * 100);
    }
    emitChange();
  };
  return {
    elFormItem: elFormItem2,
    slider,
    firstButton,
    secondButton,
    sliderDisabled,
    minValue,
    maxValue,
    runwayStyle,
    barStyle,
    resetSize,
    setPosition,
    emitChange,
    onSliderClick,
    setFirstValue,
    setSecondValue
  };
};
const useStops = (props2, initData, minValue, maxValue) => {
  const stops = computed(() => {
    if (!props2.showStops || props2.min > props2.max)
      return [];
    if (props2.step === 0) {
      return [];
    }
    const stopCount = (props2.max - props2.min) / props2.step;
    const stepWidth = 100 * props2.step / (props2.max - props2.min);
    const result = Array.from({ length: stopCount - 1 }).map((_2, index2) => (index2 + 1) * stepWidth);
    if (props2.range) {
      return result.filter((step) => {
        return step < 100 * (minValue.value - props2.min) / (props2.max - props2.min) || step > 100 * (maxValue.value - props2.min) / (props2.max - props2.min);
      });
    } else {
      return result.filter((step) => step > 100 * (initData.firstValue - props2.min) / (props2.max - props2.min));
    }
  });
  const getStopStyle = (position) => {
    return props2.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
  };
  return {
    stops,
    getStopStyle
  };
};
var __defProp$7 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key2, value) => key2 in obj ? __defProp$7(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$7.call(b2, prop))
      __defNormalProp$7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b2)) {
      if (__propIsEnum$7.call(b2, prop))
        __defNormalProp$7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$4 = (a2, b2) => __defProps$4(a2, __getOwnPropDescs$4(b2));
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var script$8 = defineComponent({
  name: "ElSlider",
  components: {
    ElInputNumber: _InputNumber,
    SliderButton: script$2$2,
    SliderMarker: script$1$4
  },
  props: {
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    inputSize: {
      type: String,
      default: "small"
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: {
      type: Function,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: ""
    },
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String,
      default: void 0
    },
    tooltipClass: {
      type: String,
      default: void 0
    },
    marks: Object
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, INPUT_EVENT],
  setup(props2, { emit: emit2 }) {
    const initData = reactive({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: false,
      sliderSize: 1
    });
    const {
      elFormItem: elFormItem2,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      minValue,
      maxValue,
      runwayStyle,
      barStyle,
      resetSize,
      emitChange,
      onSliderClick,
      setFirstValue,
      setSecondValue
    } = useSlide(props2, initData, emit2);
    const { stops, getStopStyle } = useStops(props2, initData, minValue, maxValue);
    const markList = useMarks(props2);
    useWatch(props2, initData, minValue, maxValue, emit2, elFormItem2);
    const precision = computed(() => {
      const precisions = [props2.min, props2.max, props2.step].map((item) => {
        const decimal = `${item}`.split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    });
    const { sliderWrapper } = useLifecycle(props2, initData, resetSize);
    const { firstValue, secondValue, oldValue, dragging, sliderSize } = toRefs(initData);
    const updateDragging = (val) => {
      initData.dragging = val;
    };
    provide("SliderProvider", __spreadProps$4(__spreadValues$7({}, toRefs(props2)), {
      sliderSize,
      disabled: sliderDisabled,
      precision,
      emitChange,
      resetSize,
      updateDragging
    }));
    return {
      firstValue,
      secondValue,
      oldValue,
      dragging,
      sliderSize,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      runwayStyle,
      barStyle,
      emitChange,
      onSliderClick,
      getStopStyle,
      setFirstValue,
      setSecondValue,
      stops,
      markList,
      sliderWrapper
    };
  }
});
const useWatch = (props2, initData, minValue, maxValue, emit2, elFormItem2) => {
  const _emit = (val) => {
    emit2(UPDATE_MODEL_EVENT, val);
    emit2(INPUT_EVENT, val);
  };
  const valueChanged = () => {
    if (props2.range) {
      return ![minValue.value, maxValue.value].every((item, index2) => item === initData.oldValue[index2]);
    } else {
      return props2.modelValue !== initData.oldValue;
    }
  };
  const setValues = () => {
    var _a, _b;
    if (props2.min > props2.max) {
      throwError("Slider", "min should not be greater than max.");
      return;
    }
    const val = props2.modelValue;
    if (props2.range && Array.isArray(val)) {
      if (val[1] < props2.min) {
        _emit([props2.min, props2.min]);
      } else if (val[0] > props2.max) {
        _emit([props2.max, props2.max]);
      } else if (val[0] < props2.min) {
        _emit([props2.min, val[1]]);
      } else if (val[1] > props2.max) {
        _emit([val[0], props2.max]);
      } else {
        initData.firstValue = val[0];
        initData.secondValue = val[1];
        if (valueChanged()) {
          (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
          initData.oldValue = val.slice();
        }
      }
    } else if (!props2.range && typeof val === "number" && !isNaN(val)) {
      if (val < props2.min) {
        _emit(props2.min);
      } else if (val > props2.max) {
        _emit(props2.max);
      } else {
        initData.firstValue = val;
        if (valueChanged()) {
          (_b = elFormItem2.validate) == null ? void 0 : _b.call(elFormItem2, "change");
          initData.oldValue = val;
        }
      }
    }
  };
  setValues();
  watch(() => initData.dragging, (val) => {
    if (!val) {
      setValues();
    }
  });
  watch(() => props2.modelValue, (val, oldVal) => {
    if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index2) => item === oldVal[index2])) {
      return;
    }
    setValues();
  });
  watch(() => [props2.min, props2.max], () => {
    setValues();
  });
};
const useLifecycle = (props2, initData, resetSize) => {
  const sliderWrapper = ref(null);
  onMounted(() => __async$3(void 0, null, function* () {
    let valuetext;
    if (props2.range) {
      if (Array.isArray(props2.modelValue)) {
        initData.firstValue = Math.max(props2.min, props2.modelValue[0]);
        initData.secondValue = Math.min(props2.max, props2.modelValue[1]);
      } else {
        initData.firstValue = props2.min;
        initData.secondValue = props2.max;
      }
      initData.oldValue = [initData.firstValue, initData.secondValue];
      valuetext = `${initData.firstValue}-${initData.secondValue}`;
    } else {
      if (typeof props2.modelValue !== "number" || isNaN(props2.modelValue)) {
        initData.firstValue = props2.min;
      } else {
        initData.firstValue = Math.min(props2.max, Math.max(props2.min, props2.modelValue));
      }
      initData.oldValue = initData.firstValue;
      valuetext = initData.firstValue;
    }
    sliderWrapper.value.setAttribute("aria-valuetext", valuetext);
    sliderWrapper.value.setAttribute("aria-label", props2.label ? props2.label : `slider between ${props2.min} and ${props2.max}`);
    on(window, "resize", resetSize);
    yield nextTick();
    resetSize();
  }));
  onBeforeUnmount(() => {
    off(window, "resize", resetSize);
  });
  return {
    sliderWrapper
  };
};
const _hoisted_1$y = ["aria-valuemin", "aria-valuemax", "aria-orientation", "aria-disabled"];
const _hoisted_2$q = { key: 1 };
const _hoisted_3$m = { class: "el-slider__marks" };
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = resolveComponent("el-input-number");
  const _component_slider_button = resolveComponent("slider-button");
  const _component_slider_marker = resolveComponent("slider-marker");
  return openBlock(), createElementBlock("div", {
    ref: "sliderWrapper",
    class: normalizeClass(["el-slider", { "is-vertical": _ctx.vertical, "el-slider--with-input": _ctx.showInput }]),
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
    "aria-disabled": _ctx.sliderDisabled
  }, [
    _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(_component_el_input_number, {
      key: 0,
      ref: "input",
      "model-value": _ctx.firstValue,
      class: "el-slider__input",
      step: _ctx.step,
      disabled: _ctx.sliderDisabled,
      controls: _ctx.showInputControls,
      min: _ctx.min,
      max: _ctx.max,
      debounce: _ctx.debounce,
      size: _ctx.inputSize,
      "onUpdate:modelValue": _ctx.setFirstValue,
      onChange: _ctx.emitChange
    }, null, 8, ["model-value", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref: "slider",
      class: normalizeClass(["el-slider__runway", { "show-input": _ctx.showInput && !_ctx.range, disabled: _ctx.sliderDisabled }]),
      style: normalizeStyle(_ctx.runwayStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onSliderClick && _ctx.onSliderClick(...args))
    }, [
      createElementVNode("div", {
        class: "el-slider__bar",
        style: normalizeStyle(_ctx.barStyle)
      }, null, 4),
      createVNode(_component_slider_button, {
        ref: "firstButton",
        "model-value": _ctx.firstValue,
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass,
        "onUpdate:modelValue": _ctx.setFirstValue
      }, null, 8, ["model-value", "vertical", "tooltip-class", "onUpdate:modelValue"]),
      _ctx.range ? (openBlock(), createBlock(_component_slider_button, {
        key: 0,
        ref: "secondButton",
        "model-value": _ctx.secondValue,
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass,
        "onUpdate:modelValue": _ctx.setSecondValue
      }, null, 8, ["model-value", "vertical", "tooltip-class", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
      _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$q, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stops, (item, key2) => {
          return openBlock(), createElementBlock("div", {
            key: key2,
            class: "el-slider__stop",
            style: normalizeStyle(_ctx.getStopStyle(item))
          }, null, 4);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      _ctx.markList.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createElementVNode("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markList, (item, key2) => {
            return openBlock(), createElementBlock("div", {
              key: key2,
              style: normalizeStyle(_ctx.getStopStyle(item.position)),
              class: "el-slider__stop el-slider__marks-stop"
            }, null, 4);
          }), 128))
        ]),
        createElementVNode("div", _hoisted_3$m, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markList, (item, key2) => {
            return openBlock(), createBlock(_component_slider_marker, {
              key: key2,
              mark: item.mark,
              style: normalizeStyle(_ctx.getStopStyle(item.position))
            }, null, 8, ["mark", "style"]);
          }), 128))
        ])
      ], 64)) : createCommentVNode("v-if", true)
    ], 6)
  ], 10, _hoisted_1$y);
}
script$8.render = render$8;
script$8.__file = "packages/components/slider/src/index.vue";
script$8.install = (app) => {
  app.component(script$8.name, script$8);
};
const _Slider = script$8;
const ElSlider = _Slider;
var script$7 = defineComponent({
  name: "ElSwitch",
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: false
    },
    value: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 40
    },
    activeIconClass: {
      type: String,
      default: ""
    },
    inactiveIconClass: {
      type: String,
      default: ""
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeColor: {
      type: String,
      default: ""
    },
    inactiveColor: {
      type: String,
      default: ""
    },
    borderColor: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    name: {
      type: String,
      default: ""
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    id: String,
    loading: {
      type: Boolean,
      default: false
    },
    beforeChange: Function
  },
  emits: ["update:modelValue", "change", "input"],
  setup(props2, ctx) {
    const elForm2 = inject(elFormKey, {});
    const elFormItem2 = inject(elFormItemKey, {});
    const isModelValue = ref(props2.modelValue !== false);
    const input = ref(null);
    const core = ref(null);
    const scope = "ElSwitch";
    watch(() => props2.modelValue, () => {
      isModelValue.value = true;
    });
    watch(() => props2.value, () => {
      isModelValue.value = false;
    });
    const actualValue = computed(() => {
      return isModelValue.value ? props2.modelValue : props2.value;
    });
    const checked = computed(() => {
      return actualValue.value === props2.activeValue;
    });
    if (!~[props2.activeValue, props2.inactiveValue].indexOf(actualValue.value)) {
      ctx.emit("update:modelValue", props2.inactiveValue);
      ctx.emit("change", props2.inactiveValue);
      ctx.emit("input", props2.inactiveValue);
    }
    watch(checked, () => {
      var _a;
      input.value.checked = checked.value;
      if (props2.activeColor || props2.inactiveColor) {
        setBackgroundColor();
      }
      if (props2.validateEvent) {
        (_a = elFormItem2.validate) == null ? void 0 : _a.call(elFormItem2, "change");
      }
    });
    const switchDisabled = computed(() => {
      return props2.disabled || props2.loading || (elForm2 || {}).disabled;
    });
    const handleChange = () => {
      const val = checked.value ? props2.inactiveValue : props2.activeValue;
      ctx.emit("update:modelValue", val);
      ctx.emit("change", val);
      ctx.emit("input", val);
      nextTick(() => {
        input.value.checked = checked.value;
      });
    };
    const switchValue = () => {
      if (switchDisabled.value)
        return;
      const { beforeChange } = props2;
      if (!beforeChange) {
        handleChange();
        return;
      }
      const shouldChange = beforeChange();
      const isExpectType = [isPromise(shouldChange), isBool(shouldChange)].some((i) => i);
      if (!isExpectType) {
        throwError(scope, "beforeChange must return type `Promise<boolean>` or `boolean`");
      }
      if (isPromise(shouldChange)) {
        shouldChange.then((result) => {
          if (result) {
            handleChange();
          }
        }).catch((e) => {
        });
      } else if (shouldChange) {
        handleChange();
      }
    };
    const setBackgroundColor = () => {
      const newColor = checked.value ? props2.activeColor : props2.inactiveColor;
      const coreEl = core.value;
      if (props2.borderColor)
        coreEl.style.borderColor = props2.borderColor;
      else if (!props2.borderColor)
        coreEl.style.borderColor = newColor;
      coreEl.style.backgroundColor = newColor;
      coreEl.children[0].style.color = newColor;
    };
    const focus = () => {
      var _a, _b;
      (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    };
    onMounted(() => {
      if (props2.activeColor || props2.inactiveColor || props2.borderColor) {
        setBackgroundColor();
      }
      input.value.checked = checked.value;
    });
    return {
      input,
      core,
      switchDisabled,
      checked,
      handleChange,
      switchValue,
      focus
    };
  }
});
const _hoisted_1$x = ["aria-checked", "aria-disabled"];
const _hoisted_2$p = ["id", "name", "true-value", "false-value", "disabled"];
const _hoisted_3$l = ["aria-hidden"];
const _hoisted_4$e = { class: "el-switch__action" };
const _hoisted_5$a = {
  key: 0,
  class: "el-icon-loading"
};
const _hoisted_6$8 = ["aria-hidden"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-switch", { "is-disabled": _ctx.switchDisabled, "is-checked": _ctx.checked }]),
    role: "switch",
    "aria-checked": _ctx.checked,
    "aria-disabled": _ctx.switchDisabled,
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["prevent"]))
  }, [
    createElementVNode("input", {
      id: _ctx.id,
      ref: "input",
      class: "el-switch__input",
      type: "checkbox",
      name: _ctx.name,
      "true-value": _ctx.activeValue,
      "false-value": _ctx.inactiveValue,
      disabled: _ctx.switchDisabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["enter"]))
    }, null, 40, _hoisted_2$p),
    _ctx.inactiveIconClass || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass([
        "el-switch__label",
        "el-switch__label--left",
        !_ctx.checked ? "is-active" : ""
      ])
    }, [
      _ctx.inactiveIconClass ? (openBlock(), createElementBlock("i", {
        key: 0,
        class: normalizeClass([_ctx.inactiveIconClass])
      }, null, 2)) : createCommentVNode("v-if", true),
      !_ctx.inactiveIconClass && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": _ctx.checked
      }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$l)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    createElementVNode("span", {
      ref: "core",
      class: "el-switch__core",
      style: normalizeStyle({ width: (_ctx.width || 40) + "px" })
    }, [
      createElementVNode("div", _hoisted_4$e, [
        _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_5$a)) : createCommentVNode("v-if", true)
      ])
    ], 4),
    _ctx.activeIconClass || _ctx.activeText ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass([
        "el-switch__label",
        "el-switch__label--right",
        _ctx.checked ? "is-active" : ""
      ])
    }, [
      _ctx.activeIconClass ? (openBlock(), createElementBlock("i", {
        key: 0,
        class: normalizeClass([_ctx.activeIconClass])
      }, null, 2)) : createCommentVNode("v-if", true),
      !_ctx.activeIconClass && _ctx.activeText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": !_ctx.checked
      }, toDisplayString(_ctx.activeText), 9, _hoisted_6$8)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$x);
}
script$7.render = render$7;
script$7.__file = "packages/components/switch/src/index.vue";
script$7.install = (app) => {
  app.component(script$7.name, script$7);
};
const _Switch = script$7;
const ElSwitch = _Switch;
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key2, value) => key2 in obj ? __defProp$5(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$5.call(b2, prop))
      __defNormalProp$5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b2)) {
      if (__propIsEnum$5.call(b2, prop))
        __defNormalProp$5(a2, prop, b2[prop]);
    }
  return a2;
};
const getCell = function(event) {
  let cell = event.target;
  while (cell && cell.tagName.toUpperCase() !== "HTML") {
    if (cell.tagName.toUpperCase() === "TD") {
      return cell;
    }
    cell = cell.parentNode;
  }
  return null;
};
const isObject$3 = function(obj) {
  return obj !== null && typeof obj === "object";
};
const orderBy = function(array4, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array4;
  }
  if (typeof reverse === "string") {
    reverse = reverse === "descending" ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }
  const getKey = sortMethod ? null : function(value, index2) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }
      return sortBy.map(function(by) {
        if (typeof by === "string") {
          return getValueByPath(value, by);
        } else {
          return by(value, index2, array4);
        }
      });
    }
    if (sortKey !== "$key") {
      if (isObject$3(value) && "$value" in value)
        value = value.$value;
    }
    return [isObject$3(value) ? getValueByPath(value, sortKey) : value];
  };
  const compare = function(a2, b2) {
    if (sortMethod) {
      return sortMethod(a2.value, b2.value);
    }
    for (let i = 0, len = a2.key.length; i < len; i++) {
      if (a2.key[i] < b2.key[i]) {
        return -1;
      }
      if (a2.key[i] > b2.key[i]) {
        return 1;
      }
    }
    return 0;
  };
  return array4.map(function(value, index2) {
    return {
      value,
      index: index2,
      key: getKey ? getKey(value, index2) : null
    };
  }).sort(function(a2, b2) {
    let order2 = compare(a2, b2);
    if (!order2) {
      order2 = a2.index - b2.index;
    }
    return order2 * +reverse;
  }).map((item) => item.value);
};
const getColumnById = function(table, columnId) {
  let column = null;
  table.columns.forEach(function(item) {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};
const getColumnByKey = function(table, columnKey) {
  let column = null;
  for (let i = 0; i < table.columns.length; i++) {
    const item = table.columns[i];
    if (item.columnKey === columnKey) {
      column = item;
      break;
    }
  }
  return column;
};
const getColumnByCell = function(table, cell) {
  const matches2 = (cell.className || "").match(/el-table_[^\s]+/gm);
  if (matches2) {
    return getColumnById(table, matches2[0]);
  }
  return null;
};
const getRowIdentity = (row, rowKey) => {
  if (!row)
    throw new Error("row is required when get row identity");
  if (typeof rowKey === "string") {
    if (rowKey.indexOf(".") < 0) {
      return `${row[rowKey]}`;
    }
    const key2 = rowKey.split(".");
    let current = row;
    for (let i = 0; i < key2.length; i++) {
      current = current[key2[i]];
    }
    return `${current}`;
  } else if (typeof rowKey === "function") {
    return rowKey.call(null, row);
  }
};
const getKeysMap = function(array4, rowKey) {
  const arrayMap = {};
  (array4 || []).forEach((row, index2) => {
    arrayMap[getRowIdentity(row, rowKey)] = { row, index: index2 };
  });
  return arrayMap;
};
function mergeOptions(defaults2, config) {
  const options2 = {};
  let key2;
  for (key2 in defaults2) {
    options2[key2] = defaults2[key2];
  }
  for (key2 in config) {
    if (hasOwn(config, key2)) {
      const value = config[key2];
      if (typeof value !== "undefined") {
        options2[key2] = value;
      }
    }
  }
  return options2;
}
function parseWidth(width2) {
  if (width2 !== void 0) {
    width2 = parseInt(width2, 10);
    if (isNaN(width2)) {
      width2 = null;
    }
  }
  return +width2;
}
function parseMinWidth(minWidth) {
  if (typeof minWidth !== "undefined") {
    minWidth = parseWidth(minWidth);
    if (isNaN(minWidth)) {
      minWidth = 80;
    }
  }
  return minWidth;
}
function parseHeight(height2) {
  if (typeof height2 === "number") {
    return height2;
  }
  if (typeof height2 === "string") {
    if (/^\d+(?:px)?$/.test(height2)) {
      return parseInt(height2, 10);
    } else {
      return height2;
    }
  }
  return null;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index2 = statusArr.indexOf(row);
  const included = index2 !== -1;
  const addRow = () => {
    statusArr.push(row);
    changed = true;
  };
  const removeRow = () => {
    statusArr.splice(index2, 1);
    changed = true;
  };
  if (typeof newVal === "boolean") {
    if (newVal && !included) {
      addRow();
    } else if (!newVal && included) {
      removeRow();
    }
  } else {
    if (included) {
      removeRow();
    } else {
      addRow();
    }
  }
  return changed;
}
function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
  const isNil = (array4) => !(Array.isArray(array4) && array4.length);
  function _walker(parent, children, level) {
    cb(parent, children, level);
    children.forEach((item) => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }
      const children2 = item[childrenKey];
      if (!isNil(children2)) {
        _walker(item, children2, level + 1);
      }
    });
  }
  root2.forEach((item) => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }
    const children = item[childrenKey];
    if (!isNil(children)) {
      _walker(item, children, 0);
    }
  });
}
let removePopper;
function createTablePopper(trigger, popperContent, popperOptions2, tooltipEffect) {
  function renderContent() {
    const isLight = tooltipEffect === "light";
    const content2 = document.createElement("div");
    content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
    content2.innerHTML = popperContent;
    content2.style.zIndex = String(PopupManager$1.nextZIndex());
    document.body.appendChild(content2);
    return content2;
  }
  function renderArrow2() {
    const arrow22 = document.createElement("div");
    arrow22.className = "el-popper__arrow";
    arrow22.style.bottom = "-4px";
    return arrow22;
  }
  function showPopper() {
    popperInstance && popperInstance.update();
  }
  removePopper = function removePopper2() {
    try {
      popperInstance && popperInstance.destroy();
      content && document.body.removeChild(content);
      off(trigger, "mouseenter", showPopper);
      off(trigger, "mouseleave", removePopper2);
    } catch (e) {
    }
  };
  let popperInstance = null;
  const content = renderContent();
  const arrow2 = renderArrow2();
  content.appendChild(arrow2);
  popperInstance = createPopper(trigger, content, __spreadValues$5({
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 8]
        }
      },
      {
        name: "arrow",
        options: {
          element: arrow2,
          padding: 10
        }
      }
    ]
  }, popperOptions2));
  on(trigger, "mouseenter", showPopper);
  on(trigger, "mouseleave", removePopper);
  return popperInstance;
}
function useExpand(watcherData) {
  const instance = getCurrentInstance();
  const defaultExpandAll = ref(false);
  const expandRows = ref([]);
  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey) {
      const expandRowsMap = getKeysMap(expandRows.value, rowKey);
      expandRows.value = data.reduce((prev, row) => {
        const rowId = getRowIdentity(row, rowKey);
        const rowInfo = expandRowsMap[rowId];
        if (rowInfo) {
          prev.push(row);
        }
        return prev;
      }, []);
    } else {
      expandRows.value = [];
    }
  };
  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);
    if (changed) {
      instance.emit("expand-change", row, expandRows.value.slice());
      instance.store.scheduleLayout();
    }
  };
  const setExpandRowKeys = (rowKeys) => {
    instance.store.assertRowKey();
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey);
    expandRows.value = rowKeys.reduce((prev, cur) => {
      const info = keysMap[cur];
      if (info) {
        prev.push(info.row);
      }
      return prev;
    }, []);
  };
  const isRowExpanded = (row) => {
    const rowKey = watcherData.rowKey.value;
    if (rowKey) {
      const expandMap = getKeysMap(expandRows.value, rowKey);
      return !!expandMap[getRowIdentity(row, rowKey)];
    }
    return expandRows.value.indexOf(row) !== -1;
  };
  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}
function useCurrent(watcherData) {
  const instance = getCurrentInstance();
  const _currentRowKey = ref(null);
  const currentRow = ref(null);
  const setCurrentRowKey = (key2) => {
    instance.store.assertRowKey();
    _currentRowKey.value = key2;
    setCurrentRowByKey(key2);
  };
  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };
  const setCurrentRowByKey = (key2) => {
    const { data, rowKey } = watcherData;
    let _currentRow = null;
    if (rowKey.value) {
      _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key2);
    }
    currentRow.value = _currentRow;
  };
  const updateCurrentRow = (_currentRow) => {
    const oldCurrentRow = currentRow.value;
    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit("current-change", currentRow.value, oldCurrentRow);
      return;
    }
    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit("current-change", null, oldCurrentRow);
    }
  };
  const updateCurrentRowData = () => {
    const rowKey = watcherData.rowKey.value;
    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value;
    if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
      if (rowKey) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }
      if (currentRow.value === null) {
        instance.emit("current-change", null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };
  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}
var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key2, value) => key2 in obj ? __defProp$4(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$4.call(b2, prop))
      __defNormalProp$4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b2)) {
      if (__propIsEnum$4.call(b2, prop))
        __defNormalProp$4(a2, prop, b2[prop]);
    }
  return a2;
};
function useTree(watcherData) {
  const expandRowKeys = ref([]);
  const treeData = ref({});
  const indent = ref(16);
  const lazy = ref(false);
  const lazyTreeNodeMap = ref({});
  const lazyColumnIdentifier = ref("hasChildren");
  const childrenColumnName = ref("children");
  const instance = getCurrentInstance();
  const normalizedData = computed(() => {
    if (!watcherData.rowKey.value)
      return {};
    const data = watcherData.data.value || [];
    return normalize(data);
  });
  const normalizedLazyNode = computed(() => {
    const rowKey = watcherData.rowKey.value;
    const keys2 = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys2.length)
      return res;
    keys2.forEach((key2) => {
      if (lazyTreeNodeMap.value[key2].length) {
        const item = { children: [] };
        lazyTreeNodeMap.value[key2].forEach((row) => {
          const currentRowKey = getRowIdentity(row, rowKey);
          item.children.push(currentRowKey);
          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = { children: [] };
          }
        });
        res[key2] = item;
      }
    });
    return res;
  });
  const normalize = (data) => {
    const rowKey = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent, children, level) => {
      const parentId = getRowIdentity(parent, rowKey);
      if (Array.isArray(children)) {
        res[parentId] = {
          children: children.map((row) => getRowIdentity(row, rowKey)),
          level
        };
      } else if (lazy.value) {
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };
  const updateTreeData = (ifExpandAll = ((_a) => (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value)()) => {
    var _a2;
    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys2 = Object.keys(nested);
    const newTreeData = {};
    if (keys2.length) {
      const oldTreeData = unref(treeData);
      const rootLazyRowKeys = [];
      const getExpanded = (oldValue, key2) => {
        if (expandRowKeys.value) {
          return ifExpandAll || expandRowKeys.value.includes(key2);
        } else {
          return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
        }
      };
      keys2.forEach((key2) => {
        const oldValue = oldTreeData[key2];
        const newValue = __spreadValues$4({}, nested[key2]);
        newValue.expanded = getExpanded(oldValue, key2);
        if (newValue.lazy) {
          const { loaded = false, loading = false } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading;
          rootLazyRowKeys.push(key2);
        }
        newTreeData[key2] = newValue;
      });
      const lazyKeys = Object.keys(normalizedLazyNode_);
      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach((key2) => {
          const oldValue = oldTreeData[key2];
          const lazyNodeChildren = normalizedLazyNode_[key2].children;
          if (rootLazyRowKeys.indexOf(key2) !== -1) {
            if (newTreeData[key2].children.length !== 0) {
              throw new Error("[ElTable]children must be an empty array.");
            }
            newTreeData[key2].children = lazyNodeChildren;
          } else {
            const { loaded = false, loading = false } = oldValue || {};
            newTreeData[key2] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading,
              expanded: getExpanded(oldValue, key2),
              children: lazyNodeChildren,
              level: ""
            };
          }
        });
      }
    }
    treeData.value = newTreeData;
    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
  };
  watch(() => normalizedData.value, () => {
    updateTreeData();
  });
  watch(() => normalizedLazyNode.value, () => {
    updateTreeData();
  });
  const updateTreeExpandKeys = (value) => {
    expandRowKeys.value = value;
    updateTreeData();
  };
  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey);
    const data = id2 && treeData.value[id2];
    if (id2 && data && "expanded" in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
      treeData.value[id2].expanded = expanded;
      if (oldExpanded !== expanded) {
        instance.emit("expand-change", row, expanded);
      }
      instance.store.updateTableScrollY();
    }
  };
  const loadOrToggle = (row) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey);
    const data = treeData.value[id2];
    if (lazy.value && data && "loaded" in data && !data.loaded) {
      loadData(row, id2, data);
    } else {
      toggleTreeExpansion(row, void 0);
    }
  };
  const loadData = (row, key2, treeNode) => {
    const { load } = instance.props;
    if (load && !treeData.value[key2].loaded) {
      treeData.value[key2].loading = true;
      load(row, treeNode, (data) => {
        if (!Array.isArray(data)) {
          throw new Error("[ElTable] data must be an array");
        }
        treeData.value[key2].loading = false;
        treeData.value[key2].loaded = true;
        treeData.value[key2].expanded = true;
        if (data.length) {
          lazyTreeNodeMap.value[key2] = data;
        }
        instance.emit("expand-change", row, true);
      });
    }
  };
  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key2, value) => key2 in obj ? __defProp$3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$3.call(b2, prop))
      __defNormalProp$3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b2)) {
      if (__propIsEnum$3.call(b2, prop))
        __defNormalProp$3(a2, prop, b2[prop]);
    }
  return a2;
};
const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === "string") {
    return data;
  }
  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};
const doFlattenColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
function useWatcher$1() {
  const instance = getCurrentInstance();
  const rowKey = ref(null);
  const data = ref([]);
  const _data = ref([]);
  const isComplex = ref(false);
  const _columns = ref([]);
  const originColumns = ref([]);
  const columns = ref([]);
  const fixedColumns = ref([]);
  const rightFixedColumns = ref([]);
  const leafColumns = ref([]);
  const fixedLeafColumns = ref([]);
  const rightFixedLeafColumns = ref([]);
  const leafColumnsLength = ref(0);
  const fixedLeafColumnsLength = ref(0);
  const rightFixedLeafColumnsLength = ref(0);
  const isAllSelected = ref(false);
  const selection = ref([]);
  const reserveSelection = ref(false);
  const selectOnIndeterminate = ref(false);
  const selectable = ref(null);
  const filters = ref({});
  const filteredData = ref(null);
  const sortingColumn = ref(null);
  const sortProp = ref(null);
  const sortOrder = ref(null);
  const hoverRow = ref(null);
  watch(data, () => instance.state && scheduleLayout(false), {
    deep: true
  });
  const assertRowKey = () => {
    if (!rowKey.value)
      throw new Error("[ElTable] prop row-key is required");
  };
  const updateColumns = () => {
    fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
    rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }
    const notFixedColumns = _columns.value.filter((column) => !column.fixed);
    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns2 = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns2.length;
    fixedLeafColumnsLength.value = fixedLeafColumns2.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
    columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  };
  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }
    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  };
  const isSelected = (row) => {
    return selection.value.indexOf(row) > -1;
  };
  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;
    if (oldSelection.length) {
      selection.value = [];
      instance.emit("selection-change", []);
    }
  };
  const cleanSelection = () => {
    let deleted;
    if (rowKey.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      const dataMap = getKeysMap(data.value, rowKey.value);
      for (const key2 in selectedMap) {
        if (hasOwn(selectedMap, key2) && !dataMap[key2]) {
          deleted.push(selectedMap[key2].row);
        }
      }
    } else {
      deleted = selection.value.filter((item) => data.value.indexOf(item) === -1);
    }
    if (deleted.length) {
      const newSelection = selection.value.filter((item) => deleted.indexOf(item) === -1);
      selection.value = newSelection;
      instance.emit("selection-change", newSelection.slice());
    }
  };
  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);
    if (changed) {
      const newSelection = (selection.value || []).slice();
      if (emitChange) {
        instance.emit("select", newSelection, row);
      }
      instance.emit("selection-change", newSelection);
    }
  };
  const _toggleAllSelection = () => {
    var _a, _b;
    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value;
    let selectionChanged = false;
    let childrenCount = 0;
    const rowKey2 = (_b = (_a = instance == null ? void 0 : instance.store) == null ? void 0 : _a.states) == null ? void 0 : _b.rowKey.value;
    data.value.forEach((row, index2) => {
      const rowIndex = index2 + childrenCount;
      if (selectable.value) {
        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      }
      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
    });
    if (selectionChanged) {
      instance.emit("selection-change", selection.value ? selection.value.slice() : []);
    }
    instance.emit("select-all", selection.value);
  };
  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey.value);
    data.value.forEach((row) => {
      const rowId = getRowIdentity(row, rowKey.value);
      const rowInfo = selectedMap[rowId];
      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };
  const updateAllSelected = () => {
    var _a, _b, _c;
    if (((_a = data.value) == null ? void 0 : _a.length) === 0) {
      isAllSelected.value = false;
      return;
    }
    let selectedMap;
    if (rowKey.value) {
      selectedMap = getKeysMap(selection.value, rowKey.value);
    }
    const isSelected2 = function(row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey.value)];
      } else {
        return selection.value.indexOf(row) !== -1;
      }
    };
    let isAllSelected_ = true;
    let selectedCount = 0;
    let childrenCount = 0;
    for (let i = 0, j = (data.value || []).length; i < j; i++) {
      const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
      const rowIndex = i + childrenCount;
      const item = data.value[i];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
      if (!isSelected2(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }
      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
    }
    if (selectedCount === 0)
      isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  };
  const getChildrenCount = (rowKey2) => {
    var _a;
    if (!instance || !instance.store)
      return 0;
    const { treeData } = instance.store.states;
    let count = 0;
    const children = (_a = treeData.value[rowKey2]) == null ? void 0 : _a.children;
    if (children) {
      count += children.length;
      children.forEach((childKey) => {
        count += getChildrenCount(childKey);
      });
    }
    return count;
  };
  const updateFilters = (columns2, values) => {
    if (!Array.isArray(columns2)) {
      columns2 = [columns2];
    }
    const filters_ = {};
    columns2.forEach((col) => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };
  const updateSort = (column, prop, order2) => {
    if (sortingColumn.value && sortingColumn.value !== column) {
      sortingColumn.value.order = null;
    }
    sortingColumn.value = column;
    sortProp.value = prop;
    sortOrder.value = order2;
  };
  const execFilter = () => {
    let sourceData = unref(_data);
    Object.keys(filters.value).forEach((columnId) => {
      const values = filters.value[columnId];
      if (!values || values.length === 0)
        return;
      const column = getColumnById({
        columns: columns.value
      }, columnId);
      if (column && column.filterMethod) {
        sourceData = sourceData.filter((row) => {
          return values.some((value) => column.filterMethod.call(null, value, row, column));
        });
      }
    });
    filteredData.value = sourceData;
  };
  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  };
  const execQuery = (ignore = void 0) => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }
    execSort();
  };
  const clearFilter = (columnKeys) => {
    const { tableHeader, fixedTableHeader, rightFixedTableHeader } = instance.refs;
    let panels = {};
    if (tableHeader)
      panels = Object.assign(panels, tableHeader.filterPanels);
    if (fixedTableHeader)
      panels = Object.assign(panels, fixedTableHeader.filterPanels);
    if (rightFixedTableHeader)
      panels = Object.assign(panels, rightFixedTableHeader.filterPanels);
    const keys2 = Object.keys(panels);
    if (!keys2.length)
      return;
    if (typeof columnKeys === "string") {
      columnKeys = [columnKeys];
    }
    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map((key2) => getColumnByKey({
        columns: columns.value
      }, key2));
      keys2.forEach((key2) => {
        const column = columns_.find((col) => col.id === key2);
        if (column) {
          column.filteredValue = [];
        }
      });
      instance.store.commit("filterChange", {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys2.forEach((key2) => {
        const column = columns.value.find((col) => col.id === key2);
        if (column) {
          column.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit("filterChange", {
        column: {},
        values: [],
        silent: true
      });
    }
  };
  const clearSort = () => {
    if (!sortingColumn.value)
      return;
    updateSort(null, null, null);
    instance.store.commit("changeSortCondition", {
      silent: true
    });
  };
  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    updateTreeData,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey
  });
  const setExpandRowKeysAdapter = (val) => {
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  };
  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns.value.some(({ type: type4 }) => type4 === "expand");
    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };
  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    toggleRowSelection,
    _toggleAllSelection,
    toggleAllSelection: null,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    updateTreeData,
    states: __spreadValues$3(__spreadValues$3(__spreadValues$3({
      rowKey,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow
    }, expandStates), treeStates), currentData)
  };
}
var __defProp$2$1 = Object.defineProperty;
var __defProps$2$1 = Object.defineProperties;
var __getOwnPropDescs$2$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$1 = (obj, key2, value) => key2 in obj ? __defProp$2$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$2$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2$1.call(b2, prop))
      __defNormalProp$2$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2$1)
    for (var prop of __getOwnPropSymbols$2$1(b2)) {
      if (__propIsEnum$2$1.call(b2, prop))
        __defNormalProp$2$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2$1 = (a2, b2) => __defProps$2$1(a2, __getOwnPropDescs$2$1(b2));
function replaceColumn(array4, column) {
  return array4.map((item) => {
    var _a;
    if (item.id === column.id) {
      return column;
    } else if ((_a = item.children) == null ? void 0 : _a.length) {
      item.children = replaceColumn(item.children, column);
    }
    return item;
  });
}
function sortColumn(array4) {
  array4.forEach((item) => {
    var _a, _b;
    item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
    if ((_b = item.children) == null ? void 0 : _b.length) {
      sortColumn(item.children);
    }
  });
  array4.sort((cur, pre) => cur.no - pre.no);
}
function useStore() {
  const instance = getCurrentInstance();
  const watcher = useWatcher$1();
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = unref(states.data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery();
      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();
      instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
      if (unref(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }
      instance.store.updateAllSelected();
      if (instance.$ready) {
        instance.store.scheduleLayout();
      }
    },
    insertColumn(states, column, parent) {
      const array4 = unref(states._columns);
      let newColumns = [];
      if (!parent) {
        array4.push(column);
        newColumns = array4;
      } else {
        if (parent && !parent.children) {
          parent.children = [];
        }
        parent.children.push(column);
        newColumns = replaceColumn(array4, parent);
      }
      sortColumn(newColumns);
      states._columns.value = newColumns;
      if (column.type === "selection") {
        states.selectable.value = column.selectable;
        states.reserveSelection.value = column.reserveSelection;
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    removeColumn(states, column, parent) {
      const array4 = unref(states._columns) || [];
      if (parent) {
        parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
        if (parent.children.length === 0) {
          delete parent.children;
        }
        states._columns.value = replaceColumn(array4, parent);
      } else {
        const index2 = array4.indexOf(column);
        if (index2 > -1) {
          array4.splice(index2, 1);
          states._columns.value = array4;
        }
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    sort(states, options2) {
      const { prop, order: order2, init } = options2;
      if (prop) {
        const column = unref(states.columns).find((column2) => column2.property === prop);
        if (column) {
          column.order = order2;
          instance.store.updateSort(column, prop, order2);
          instance.store.commit("changeSortCondition", { init });
        }
      }
    },
    changeSortCondition(states, options2) {
      const { sortingColumn: column, sortProp: prop, sortOrder: order2 } = states;
      if (unref(order2) === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }
      const ingore = { filter: true };
      instance.store.execQuery(ingore);
      if (!options2 || !(options2.silent || options2.init)) {
        instance.emit("sort-change", {
          column: unref(column),
          prop: unref(prop),
          order: unref(order2)
        });
      }
      instance.store.updateTableScrollY();
    },
    filterChange(_states, options2) {
      const { column, values, silent } = options2;
      const newFilters = instance.store.updateFilters(column, values);
      instance.store.execQuery();
      if (!silent) {
        instance.emit("filter-change", newFilters);
      }
      instance.store.updateTableScrollY();
    },
    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },
    rowSelectedChanged(_states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },
    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },
    setCurrentRow(_states, row) {
      instance.store.updateCurrentRow(row);
    }
  };
  const commit = function(name, ...args) {
    const mutations2 = instance.store.mutations;
    if (mutations2[name]) {
      mutations2[name].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name}`);
    }
  };
  const updateTableScrollY = function() {
    nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
  };
  return __spreadProps$2$1(__spreadValues$2$1({}, watcher), {
    mutations,
    commit,
    updateTableScrollY
  });
}
const InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function createStore(table, props2) {
  if (!table) {
    throw new Error("Table is required.");
  }
  const store = useStore();
  store.toggleAllSelection = debounce_1(store._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach((key2) => {
    handleValue(getArrKeysValue(props2, key2), key2, store);
  });
  proxyTableProps(store, props2);
  return store;
}
function proxyTableProps(store, props2) {
  Object.keys(InitialStateMap).forEach((key2) => {
    watch(() => getArrKeysValue(props2, key2), (value) => {
      handleValue(value, key2, store);
    });
  });
}
function handleValue(value, propsKey, store) {
  let newVal = value;
  let storeKey = InitialStateMap[propsKey];
  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey = storeKey.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }
  store.states[storeKey].value = newVal;
}
function getArrKeysValue(props2, keys2) {
  if (keys2.includes(".")) {
    const keyList = keys2.split(".");
    let value = props2;
    keyList.forEach((key2) => {
      value = value[key2];
    });
    return value;
  } else {
    return props2[keys2];
  }
}
class TableLayout {
  constructor(options2) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = ref(null);
    this.scrollX = ref(false);
    this.scrollY = ref(false);
    this.bodyWidth = ref(null);
    this.fixedWidth = ref(null);
    this.rightFixedWidth = ref(null);
    this.tableHeight = ref(null);
    this.headerHeight = ref(44);
    this.appendHeight = ref(0);
    this.footerHeight = ref(44);
    this.viewportHeight = ref(null);
    this.bodyHeight = ref(null);
    this.fixedBodyHeight = ref(null);
    this.gutterWidth = scrollbarWidth();
    for (const name in options2) {
      if (hasOwn(options2, name)) {
        if (isRef(this[name])) {
          this[name].value = options2[name];
        } else {
          this[name] = options2[name];
        }
      }
    }
    if (!this.table) {
      throw new Error("table is required for Table Layout");
    }
    if (!this.store) {
      throw new Error("store is required for Table Layout");
    }
  }
  updateScrollY() {
    const height2 = this.height.value;
    if (height2 === null)
      return false;
    const bodyWrapper = this.table.refs.bodyWrapper;
    if (this.table.vnode.el && bodyWrapper) {
      let scrollY = true;
      const prevScrollY = this.scrollY.value;
      if (this.bodyHeight.value === null) {
        scrollY = false;
      } else {
        const body = bodyWrapper.querySelector(".el-table__body");
        scrollY = body.offsetHeight > this.bodyHeight.value;
      }
      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }
    return false;
  }
  setHeight(value, prop = "height") {
    if (isServer)
      return;
    const el = this.table.vnode.el;
    value = parseHeight(value);
    this.height.value = Number(value);
    if (!el && (value || value === 0))
      return nextTick(() => this.setHeight(value, prop));
    if (typeof value === "number") {
      el.style[prop] = `${value}px`;
      this.updateElsHeight();
    } else if (typeof value === "string") {
      el.style[prop] = value;
      this.updateElsHeight();
    }
  }
  setMaxHeight(value) {
    this.setHeight(value, "max-height");
  }
  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.store.states.columns.value;
    columns.forEach((column) => {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }
  updateElsHeight() {
    if (!this.table.$ready)
      return nextTick(() => this.updateElsHeight());
    const { headerWrapper, appendWrapper, footerWrapper } = this.table.refs;
    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper)
      return;
    const headerTrElm = headerWrapper ? headerWrapper.querySelector(".el-table__header tr") : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;
    if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
      return nextTick(() => this.updateElsHeight());
    }
    const tableHeight = this.tableHeight.value = this.table.vnode.el.clientHeight;
    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;
    if (this.height.value !== null) {
      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
    }
    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
    this.updateScrollY();
    this.notifyObservers("scrollable");
  }
  headerDisplayNone(elm) {
    if (!elm)
      return true;
    let headerChild = elm;
    while (headerChild.tagName !== "DIV") {
      if (getComputedStyle(headerChild).display === "none") {
        return true;
      }
      headerChild = headerChild.parentElement;
    }
    return false;
  }
  updateColumnsWidth() {
    if (isServer)
      return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
    flattenColumns.forEach((column) => {
      if (typeof column.width === "number" && column.realWidth)
        column.realWidth = null;
    });
    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach((column) => {
        bodyMinWidth += Number(column.width || column.minWidth || 80);
      });
      const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;
      if (bodyMinWidth <= bodyWidth - scrollYWidth) {
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column, index2) => {
            if (index2 === 0)
              return;
            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column.realWidth = Number(column.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        this.scrollX.value = true;
        flexColumns.forEach(function(column) {
          column.realWidth = Number(column.minWidth);
        });
      }
      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach((column) => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = Number(column.width || column.minWidth);
        }
        bodyMinWidth += column.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }
    const fixedColumns = this.store.states.fixedColumns.value;
    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach(function(column) {
        fixedWidth += Number(column.realWidth || column.width);
      });
      this.fixedWidth.value = fixedWidth;
    }
    const rightFixedColumns = this.store.states.rightFixedColumns.value;
    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach(function(column) {
        rightFixedWidth += Number(column.realWidth || column.width);
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }
    this.notifyObservers("columns");
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index2 = this.observers.indexOf(observer);
    if (index2 !== -1) {
      this.observers.splice(index2, 1);
    }
  }
  notifyObservers(event) {
    const observers2 = this.observers;
    observers2.forEach((observer) => {
      var _a, _b;
      switch (event) {
        case "columns":
          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
          break;
        case "scrollable":
          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${event}.`);
      }
    });
  }
}
var TableLayout$1 = TableLayout;
const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
var script$1$3 = defineComponent({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox,
    ElCheckboxGroup,
    ElScrollbar: _Scrollbar,
    ElPopper: _Popper
  },
  directives: { ClickOutside: ClickOutside$1 },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { t } = useLocaleInject();
    const parent = instance.parent;
    if (!parent.filterPanels.value[props2.column.id]) {
      parent.filterPanels.value[props2.column.id] = instance;
    }
    const tooltipVisible = ref(false);
    const tooltip = ref(null);
    const filters = computed(() => {
      return props2.column && props2.column.filters;
    });
    const filterValue = computed({
      get: () => (props2.column.filteredValue || [])[0],
      set: (value) => {
        if (filteredValue.value) {
          if (typeof value !== "undefined" && value !== null) {
            filteredValue.value.splice(0, 1, value);
          } else {
            filteredValue.value.splice(0, 1);
          }
        }
      }
    });
    const filteredValue = computed({
      get() {
        if (props2.column) {
          return props2.column.filteredValue || [];
        }
        return [];
      },
      set(value) {
        if (props2.column) {
          props2.upDataColumn("filteredValue", value);
        }
      }
    });
    const multiple2 = computed(() => {
      if (props2.column) {
        return props2.column.filterMultiple;
      }
      return true;
    });
    const isActive = (filter) => {
      return filter.value === filterValue.value;
    };
    const hidden2 = () => {
      tooltipVisible.value = false;
    };
    const showFilterPanel = (e) => {
      e.stopPropagation();
      tooltipVisible.value = !tooltipVisible.value;
    };
    const hideFilterPanel = () => {
      tooltipVisible.value = false;
    };
    const handleConfirm = () => {
      confirmFilter(filteredValue.value);
      hidden2();
    };
    const handleReset = () => {
      filteredValue.value = [];
      confirmFilter(filteredValue.value);
      hidden2();
    };
    const handleSelect = (_filterValue) => {
      filterValue.value = _filterValue;
      if (typeof _filterValue !== "undefined" && _filterValue !== null) {
        confirmFilter(filteredValue.value);
      } else {
        confirmFilter([]);
      }
      hidden2();
    };
    const confirmFilter = (filteredValue2) => {
      props2.store.commit("filterChange", {
        column: props2.column,
        values: filteredValue2
      });
      props2.store.updateAllSelected();
    };
    watch(tooltipVisible, (value) => {
      if (props2.column) {
        props2.upDataColumn("filterOpened", value);
      }
    }, {
      immediate: true
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = tooltip.value) == null ? void 0 : _a.popperRef;
    });
    return {
      tooltipVisible,
      multiple: multiple2,
      filteredValue,
      filterValue,
      filters,
      handleConfirm,
      handleReset,
      handleSelect,
      isActive,
      t,
      showFilterPanel,
      hideFilterPanel,
      popperPaneRef,
      tooltip,
      Effect
    };
  }
});
const _hoisted_1$1$2 = { key: 0 };
const _hoisted_2$1$1 = { class: "el-table-filter__content" };
const _hoisted_3$1$1 = { class: "el-table-filter__bottom" };
const _hoisted_4$1$1 = ["disabled"];
const _hoisted_5$1$1 = {
  key: 1,
  class: "el-table-filter__list"
};
const _hoisted_6$1$1 = ["label", "onClick"];
function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    "onUpdate:visible": _cache[5] || (_cache[5] = ($event) => _ctx.tooltipVisible = $event),
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    effect: _ctx.Effect.LIGHT,
    pure: "",
    "manual-mode": "",
    "popper-class": "el-table-filter",
    "append-to-body": ""
  }, {
    default: withCtx(() => [
      _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$1$2, [
        createElementVNode("div", _hoisted_2$1$1, [
          createVNode(_component_el_scrollbar, { "wrap-class": "el-table-filter__wrap" }, {
            default: withCtx(() => [
              createVNode(_component_el_checkbox_group, {
                modelValue: _ctx.filteredValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                class: "el-table-filter__checkbox-group"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                    return openBlock(), createBlock(_component_el_checkbox, {
                      key: filter.value,
                      label: filter.value
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(filter.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          })
        ]),
        createElementVNode("div", _hoisted_3$1$1, [
          createElementVNode("button", {
            class: normalizeClass({ "is-disabled": _ctx.filteredValue.length === 0 }),
            disabled: _ctx.filteredValue.length === 0,
            type: "button",
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
          }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_4$1$1),
          createElementVNode("button", {
            type: "button",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
          }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
        ])
      ])) : (openBlock(), createElementBlock("ul", _hoisted_5$1$1, [
        createElementVNode("li", {
          class: normalizeClass([{
            "is-active": _ctx.filterValue === void 0 || _ctx.filterValue === null
          }, "el-table-filter__list-item"]),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
        }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
          return openBlock(), createElementBlock("li", {
            key: filter.value,
            class: normalizeClass([{ "is-active": _ctx.isActive(filter) }, "el-table-filter__list-item"]),
            label: filter.value,
            onClick: ($event) => _ctx.handleSelect(filter.value)
          }, toDisplayString(filter.text), 11, _hoisted_6$1$1);
        }), 128))
      ]))
    ]),
    trigger: withCtx(() => [
      withDirectives(createElementVNode("span", {
        class: "el-table__column-filter-trigger el-none-outline",
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
      }, [
        createElementVNode("i", {
          class: normalizeClass([
            "el-icon-arrow-down",
            _ctx.column.filterOpened ? "el-icon-arrow-up" : ""
          ])
        }, null, 2)
      ], 512), [
        [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "effect"]);
}
script$1$3.render = render$1$3;
script$1$3.__file = "packages/components/table/src/filter-panel.vue";
function useLayoutObserver(root2) {
  const instance = getCurrentInstance();
  onBeforeMount(() => {
    tableLayout.value.addObserver(instance);
  });
  onMounted(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUpdated(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUnmounted(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = computed(() => {
    const layout = root2.layout;
    if (!layout) {
      throw new Error("Can not find table layout.");
    }
    return layout;
  });
  const onColumnsChange = (layout) => {
    var _a;
    const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
    if (!cols.length)
      return;
    const flattenColumns = layout.getFlattenColumns();
    const columnsMap = {};
    flattenColumns.forEach((column) => {
      columnsMap[column.id] = column;
    });
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      const name = col.getAttribute("name");
      const column = columnsMap[name];
      if (column) {
        col.setAttribute("width", column.realWidth || column.width);
      }
    }
  };
  const onScrollableChange = (layout) => {
    const cols = root2.vnode.el.querySelectorAll("colgroup > col[name=gutter]");
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
    }
    const ths = root2.vnode.el.querySelectorAll("th.gutter");
    for (let i = 0, j = ths.length; i < j; i++) {
      const th = ths[i];
      th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
      th.style.display = layout.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}
function hGutter() {
  return h$1("col", {
    name: "gutter"
  });
}
function hColgroup(columns, hasGutter = false) {
  return h$1("colgroup", {}, [
    ...columns.map((column) => h$1("col", {
      name: column.id,
      key: column.id
    })),
    hasGutter && hGutter()
  ]);
}
function useEvent(props2, emit2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const handleFilterClick = (event) => {
    event.stopPropagation();
    return;
  };
  const handleHeaderClick = (event, column) => {
    if (!column.filters && column.sortable) {
      handleSortClick(event, column, false);
    } else if (column.filterable && !column.sortable) {
      handleFilterClick(event);
    }
    parent.emit("header-click", column, event);
  };
  const handleHeaderContextMenu = (event, column) => {
    parent.emit("header-contextmenu", column, event);
  };
  const draggingColumn = ref(null);
  const dragging = ref(false);
  const dragState = ref({});
  const handleMouseDown = (event, column) => {
    if (isServer)
      return;
    if (column.children && column.children.length > 0)
      return;
    if (draggingColumn.value && props2.border) {
      dragging.value = true;
      const table = parent;
      emit2("set-drag-visible", true);
      const tableEl = table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass(columnEl, "noclick");
      dragState.value = {
        startMouseLeft: event.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table.refs.resizeProxy;
      resizeProxy.style.left = `${dragState.value.startLeft}px`;
      document.onselectstart = function() {
        return false;
      };
      document.ondragstart = function() {
        return false;
      };
      const handleMouseMove2 = (event2) => {
        const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
      };
      const handleMouseUp = () => {
        if (dragging.value) {
          const { startColumnLeft, startLeft } = dragState.value;
          const finalLeft = parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column.width = column.realWidth = columnWidth;
          table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
          props2.store.scheduleLayout(false, true);
          document.body.style.cursor = "";
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit2("set-drag-visible", false);
        }
        document.removeEventListener("mousemove", handleMouseMove2);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(function() {
          removeClass(columnEl, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", handleMouseMove2);
      document.addEventListener("mouseup", handleMouseUp);
    }
  };
  const handleMouseMove = (event, column) => {
    if (column.children && column.children.length > 0)
      return;
    let target = event.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (!column || !column.resizable)
      return;
    if (!dragging.value && props2.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;
      if (rect.width > 12 && rect.right - event.pageX < 8) {
        bodyStyle.cursor = "col-resize";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "col-resize";
        }
        draggingColumn.value = column;
      } else if (!dragging.value) {
        bodyStyle.cursor = "";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "pointer";
        }
        draggingColumn.value = null;
      }
    }
  };
  const handleMouseOut = () => {
    if (isServer)
      return;
    document.body.style.cursor = "";
  };
  const toggleOrder = ({ order: order2, sortOrders }) => {
    if (order2 === "")
      return sortOrders[0];
    const index2 = sortOrders.indexOf(order2 || null);
    return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
  };
  const handleSortClick = (event, column, givenOrder) => {
    event.stopPropagation();
    const order2 = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
    let target = event.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (target && target.tagName === "TH") {
      if (hasClass(target, "noclick")) {
        removeClass(target, "noclick");
        return;
      }
    }
    if (!column.sortable)
      return;
    const states = props2.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;
    if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }
      states.sortingColumn.value = column;
      sortProp = column.property;
    }
    if (!order2) {
      sortOrder = column.order = null;
    } else {
      sortOrder = column.order = order2;
    }
    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}
function useStyle$2(props2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const storeData = parent.store.states;
  const isCellHidden = (index2, columns) => {
    let start2 = 0;
    for (let i = 0; i < index2; i++) {
      start2 += columns[i].colSpan;
    }
    const after = start2 + columns[index2].colSpan - 1;
    if (props2.fixed === "left") {
      return after >= storeData.fixedLeafColumnsLength.value;
    } else if (props2.fixed === "right") {
      return start2 < storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    } else {
      return after < storeData.fixedLeafColumnsLength.value || start2 >= storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    }
  };
  const getHeaderRowStyle = (rowIndex) => {
    const headerRowStyle = parent.props.headerRowStyle;
    if (typeof headerRowStyle === "function") {
      return headerRowStyle.call(null, { rowIndex });
    }
    return headerRowStyle;
  };
  const getHeaderRowClass = (rowIndex) => {
    const classes = [];
    const headerRowClassName = parent.props.headerRowClassName;
    if (typeof headerRowClassName === "string") {
      classes.push(headerRowClassName);
    } else if (typeof headerRowClassName === "function") {
      classes.push(headerRowClassName.call(null, { rowIndex }));
    }
    return classes.join(" ");
  };
  const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
    const headerCellStyle = parent.props.headerCellStyle;
    if (typeof headerCellStyle === "function") {
      return headerCellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    return headerCellStyle;
  };
  const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [
      column.id,
      column.order,
      column.headerAlign,
      column.className,
      column.labelClassName
    ];
    if (rowIndex === 0 && isCellHidden(columnIndex, row)) {
      classes.push("is-hidden");
    }
    if (!column.children) {
      classes.push("is-leaf");
    }
    if (column.sortable) {
      classes.push("is-sortable");
    }
    const headerCellClassName = parent.props.headerCellClassName;
    if (typeof headerCellClassName === "string") {
      classes.push(headerCellClassName);
    } else if (typeof headerCellClassName === "function") {
      classes.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes.push("el-table__cell");
    return classes.join(" ");
  };
  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}
const getAllColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column, void 0);
  });
  const rows2 = [];
  for (let i = 0; i < maxLevel; i++) {
    rows2.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach((column) => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }
    rows2[column.level - 1].push(column);
  });
  return rows2;
};
function useUtils$1(props2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const columnRows = computed(() => {
    return convertToRows(props2.store.states.originColumns.value);
  });
  const isGroup = computed(() => {
    const result = columnRows.value.length > 1;
    if (result)
      parent.state.isGroup.value = true;
    return result;
  });
  const toggleAllSelection = (event) => {
    event.stopPropagation();
    parent.store.commit("toggleAllSelection");
  };
  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}
var TableHeader = defineComponent({
  name: "ElTableHeader",
  components: {
    ElCheckbox
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const instance = getCurrentInstance();
    const parent = instance.parent;
    const storeData = parent.store.states;
    const filterPanels = ref({});
    const { tableLayout, onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
    const hasGutter = computed(() => {
      return !props2.fixed && tableLayout.gutterWidth;
    });
    onMounted(() => {
      nextTick(() => {
        const { prop, order: order2 } = props2.defaultSort;
        const init = true;
        parent.store.commit("sort", { prop, order: order2, init });
      });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = useEvent(props2, emit2);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle$2(props2);
    const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props2);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    };
    instance.filterPanels = filterPanels;
    return {
      columns: storeData.columns,
      filterPanels,
      hasGutter,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },
  render() {
    return h$1("table", {
      border: "0",
      cellpadding: "0",
      cellspacing: "0",
      class: "el-table__header"
    }, [
      hColgroup(this.columns, this.hasGutter),
      h$1("thead", {
        class: { "is-group": this.isGroup, "has-gutter": this.hasGutter }
      }, this.columnRows.map((subColumns, rowIndex) => h$1("tr", {
        class: this.getHeaderRowClass(rowIndex),
        key: rowIndex,
        style: this.getHeaderRowStyle(rowIndex)
      }, subColumns.map((column, cellIndex) => h$1("th", {
        class: this.getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
        colspan: column.colSpan,
        key: `${column.id}-thead`,
        rowSpan: column.rowSpan,
        style: this.getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
        onClick: ($event) => this.handleHeaderClick($event, column),
        onContextmenu: ($event) => this.handleHeaderContextMenu($event, column),
        onMousedown: ($event) => this.handleMouseDown($event, column),
        onMousemove: ($event) => this.handleMouseMove($event, column),
        onMouseout: this.handleMouseOut
      }, [
        h$1("div", {
          class: [
            "cell",
            column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "",
            column.labelClassName
          ]
        }, [
          column.renderHeader ? column.renderHeader({
            column,
            $index: cellIndex,
            store: this.store,
            _self: this.$parent
          }) : column.label,
          column.sortable && h$1("span", {
            onClick: ($event) => this.handleSortClick($event, column),
            class: "caret-wrapper"
          }, [
            h$1("i", {
              onClick: ($event) => this.handleSortClick($event, column, "ascending"),
              class: "sort-caret ascending"
            }),
            h$1("i", {
              onClick: ($event) => this.handleSortClick($event, column, "descending"),
              class: "sort-caret descending"
            })
          ]),
          column.filterable && h$1(script$1$3, {
            store: this.$parent.store,
            placement: column.filterPlacement || "bottom-start",
            column,
            upDataColumn: (key2, value) => {
              column[key2] = value;
            }
          })
        ])
      ])))))
    ]);
  }
});
function useEvents(props2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const tooltipContent = ref("");
  const tooltipTrigger = ref(h$1("div"));
  const handleEvent2 = (event, row, name) => {
    const table = parent;
    const cell = getCell(event);
    let column;
    if (cell) {
      column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell);
      if (column) {
        table.emit(`cell-${name}`, row, column, cell, event);
      }
    }
    table.emit(`row-${name}`, row, column, event);
  };
  const handleDoubleClick = (event, row) => {
    handleEvent2(event, row, "dblclick");
  };
  const handleClick = (event, row) => {
    props2.store.commit("setCurrentRow", row);
    handleEvent2(event, row, "click");
  };
  const handleContextMenu = (event, row) => {
    handleEvent2(event, row, "contextmenu");
  };
  const handleMouseEnter = debounce_1(function(index2) {
    props2.store.commit("setHoverRow", index2);
  }, 30);
  const handleMouseLeave = debounce_1(function() {
    props2.store.commit("setHoverRow", null);
  }, 30);
  const handleCellMouseEnter = (event, row) => {
    const table = parent;
    const cell = getCell(event);
    if (cell) {
      const column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell);
      const hoverState = table.hoverState = { cell, column, row };
      table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
    }
    const cellChild = event.target.querySelector(".cell");
    if (!(hasClass(cellChild, "el-tooltip") && cellChild.childNodes.length)) {
      return;
    }
    const range3 = document.createRange();
    range3.setStart(cellChild, 0);
    range3.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = range3.getBoundingClientRect().width;
    const padding2 = (parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) + (parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
    if (rangeWidth + padding2 > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      createTablePopper(cell, cell.innerText || cell.textContent, {
        placement: "top",
        strategy: "fixed"
      }, row.tooltipEffect);
    }
  };
  const handleCellMouseLeave = (event) => {
    const cell = getCell(event);
    if (!cell)
      return;
    const oldHoverState = parent.hoverState;
    parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
  };
  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  };
}
function useStyles(props2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const isColumnHidden = (index2) => {
    if (props2.fixed === "left") {
      return index2 >= props2.store.states.fixedLeafColumnsLength.value;
    } else if (props2.fixed === "right") {
      return index2 < props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
    } else {
      return index2 < props2.store.states.fixedLeafColumnsLength.value || index2 >= props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
    }
  };
  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent.props.rowStyle;
    if (typeof rowStyle === "function") {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }
    return rowStyle || null;
  };
  const getRowClass = (row, rowIndex) => {
    const classes = ["el-table__row"];
    if (parent.props.highlightCurrentRow && row === props2.store.states.currentRow.value) {
      classes.push("current-row");
    }
    if (props2.stripe && rowIndex % 2 === 1) {
      classes.push("el-table__row--striped");
    }
    const rowClassName = parent.props.rowClassName;
    if (typeof rowClassName === "string") {
      classes.push(rowClassName);
    } else if (typeof rowClassName === "function") {
      classes.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }
    if (props2.store.states.expandRows.value.indexOf(row) > -1) {
      classes.push("expanded");
    }
    return classes;
  };
  const getCellStyle = (rowIndex, columnIndex, row, column) => {
    const cellStyle = parent.props.cellStyle;
    if (typeof cellStyle === "function") {
      return cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    return cellStyle;
  };
  const getCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [column.id, column.align, column.className];
    if (isColumnHidden(columnIndex)) {
      classes.push("is-hidden");
    }
    const cellClassName = parent.props.cellClassName;
    if (typeof cellClassName === "string") {
      classes.push(cellClassName);
    } else if (typeof cellClassName === "function") {
      classes.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes.push("el-table__cell");
    return classes.join(" ");
  };
  const getSpan = (row, column, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn2 = parent.props.spanMethod;
    if (typeof fn2 === "function") {
      const result = fn2({
        row,
        column,
        rowIndex,
        columnIndex
      });
      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === "object") {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }
    return { rowspan, colspan };
  };
  const getColspanRealWidth = (columns, colspan, index2) => {
    if (colspan < 1) {
      return columns[index2].realWidth;
    }
    const widthArr = columns.map(({ realWidth, width: width2 }) => realWidth || width2).slice(index2, index2 + colspan);
    return Number(widthArr.reduce((acc, width2) => Number(acc) + Number(width2), -1));
  };
  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth,
    isColumnHidden
  };
}
var __defProp$1$1 = Object.defineProperty;
var __defProps$1$1 = Object.defineProperties;
var __getOwnPropDescs$1$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$1 = (obj, key2, value) => key2 in obj ? __defProp$1$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1$1.call(b2, prop))
      __defNormalProp$1$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1$1)
    for (var prop of __getOwnPropSymbols$1$1(b2)) {
      if (__propIsEnum$1$1.call(b2, prop))
        __defNormalProp$1$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1$1 = (a2, b2) => __defProps$1$1(a2, __getOwnPropDescs$1$1(b2));
function useRender$1(props2) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props2);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props2);
  const firstDefaultColumnIndex = computed(() => {
    return props2.store.states.columns.value.findIndex(({ type: type4 }) => type4 === "default");
  });
  const getKeyOfRow = (row, index2) => {
    const rowKey = parent.props.rowKey;
    if (rowKey) {
      return getRowIdentity(row, rowKey);
    }
    return index2;
  };
  const rowRender = (row, $index, treeRowData) => {
    const { tooltipEffect, store } = props2;
    const { indent, columns } = store.states;
    const rowClasses = getRowClass(row, $index);
    let display = true;
    if (treeRowData) {
      rowClasses.push(`el-table__row--level-${treeRowData.level}`);
      display = treeRowData.display;
    }
    const displayStyle = display ? null : {
      display: "none"
    };
    return h$1("tr", {
      style: [displayStyle, getRowStyle(row, $index)],
      class: rowClasses,
      key: getKeyOfRow(row, $index),
      onDblclick: ($event) => handleDoubleClick($event, row),
      onClick: ($event) => handleClick($event, row),
      onContextmenu: ($event) => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter($index),
      onMouseleave: handleMouseLeave
    }, columns.value.map((column, cellIndex) => {
      const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
      if (!rowspan || !colspan) {
        return null;
      }
      const columnData = __spreadValues$1$1({}, column);
      columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
      const data = {
        store: props2.store,
        _self: props2.context || parent,
        column: columnData,
        row,
        $index
      };
      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };
        if (typeof treeRowData.expanded === "boolean") {
          data.treeNode.expanded = treeRowData.expanded;
          if ("loading" in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }
          if ("noLazyChildren" in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }
      const baseKey = `${$index},${cellIndex}`;
      const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
      return h$1("td", {
        style: getCellStyle($index, cellIndex, row, column),
        class: getCellClass($index, cellIndex, row, column),
        key: `${patchKey}${baseKey}`,
        rowspan,
        colspan,
        onMouseenter: ($event) => handleCellMouseEnter($event, __spreadProps$1$1(__spreadValues$1$1({}, row), { tooltipEffect })),
        onMouseleave: handleCellMouseLeave
      }, [column.renderCell(data)]);
    }));
  };
  const wrappedRowRender = (row, $index) => {
    const store = props2.store;
    const { isRowExpanded, assertRowKey } = store;
    const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
    const hasExpandColumn = store.states.columns.value.some(({ type: type4 }) => type4 === "expand");
    if (hasExpandColumn && isRowExpanded(row)) {
      const renderExpanded = parent.renderExpanded;
      const tr = rowRender(row, $index, void 0);
      if (!renderExpanded) {
        console.error("[Element Error]renderExpanded is required.");
        return tr;
      }
      return [
        [
          tr,
          h$1("tr", {
            key: `expanded-row__${tr.key}`
          }, [
            h$1("td", {
              colspan: store.states.columns.value.length,
              class: "el-table__cell el-table__expanded-cell"
            }, [renderExpanded({ row, $index, store })])
          ])
        ]
      ];
    } else if (Object.keys(treeData.value).length) {
      assertRowKey();
      const key2 = getRowIdentity(row, rowKey.value);
      let cur = treeData.value[key2];
      let treeRowData = null;
      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };
        if (typeof cur.lazy === "boolean") {
          if (typeof cur.loaded === "boolean" && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }
          treeRowData.loading = cur.loading;
        }
      }
      const tmp = [rowRender(row, $index, treeRowData)];
      if (cur) {
        let i = 0;
        const traverse = (children, parent2) => {
          if (!(children && children.length && parent2))
            return;
          children.forEach((node) => {
            const innerTreeRowData = {
              display: parent2.display && parent2.expanded,
              level: parent2.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey.value);
            if (childKey === void 0 || childKey === null) {
              throw new Error("for nested data item, row-key is required.");
            }
            cur = __spreadValues$1$1({}, treeData.value[childKey]);
            if (cur) {
              innerTreeRowData.expanded = cur.expanded;
              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                innerTreeRowData.loading = cur.loading;
              }
            }
            i++;
            tmp.push(rowRender(node, $index + i, innerTreeRowData));
            if (cur) {
              const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes2, cur);
            }
          });
        };
        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key2] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }
      return tmp;
    } else {
      return rowRender(row, $index, void 0);
    }
  };
  return {
    wrappedRowRender,
    tooltipContent,
    tooltipTrigger
  };
}
const defaultProps$2 = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var defaultProps$3 = defaultProps$2;
var TableBody = defineComponent({
  name: "ElTableBody",
  props: defaultProps$3,
  setup(props2) {
    const instance = getCurrentInstance();
    const parent = instance.parent;
    const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props2);
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
    watch(props2.store.states.hoverRow, (newVal, oldVal) => {
      if (!props2.store.states.isComplex.value || isServer)
        return;
      let raf = window.requestAnimationFrame;
      if (!raf) {
        raf = (fn2) => window.setTimeout(fn2, 16);
      }
      raf(() => {
        const rows2 = instance.vnode.el.querySelectorAll(".el-table__row");
        const oldRow = rows2[oldVal];
        const newRow = rows2[newVal];
        if (oldRow) {
          removeClass(oldRow, "hover-row");
        }
        if (newRow) {
          addClass(newRow, "hover-row");
        }
      });
    });
    onUnmounted(() => {
      var _a;
      (_a = removePopper) == null ? void 0 : _a();
    });
    onUpdated(() => {
      var _a;
      (_a = removePopper) == null ? void 0 : _a();
    });
    return {
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  },
  render() {
    const data = this.store.states.data.value || [];
    return h$1("table", {
      class: "el-table__body",
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup(this.store.states.columns.value),
      h$1("tbody", {}, [
        data.reduce((acc, row) => {
          return acc.concat(this.wrappedRowRender(row, acc.length));
        }, [])
      ])
    ]);
  }
});
function useMapState() {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const leftFixedLeafCount = computed(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = computed(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = computed(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}
function useStyle$1(props2) {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns
  } = useMapState();
  const hasGutter = computed(() => {
    return !props2.fixed && !table.layout.gutterWidth;
  });
  const isCellHidden = (index2, columns2, column) => {
    if (props2.fixed || props2.fixed === "left") {
      return index2 >= leftFixedLeafCount.value;
    } else if (props2.fixed === "right") {
      let before = 0;
      for (let i = 0; i < index2; i++) {
        before += columns2[i].colSpan;
      }
      return before < columnsCount.value - rightFixedLeafCount.value;
    } else if (!props2.fixed && column.fixed) {
      return true;
    } else {
      return index2 < leftFixedCount.value || index2 >= columnsCount.value - rightFixedCount.value;
    }
  };
  const getRowClasses = (column, cellIndex) => {
    const classes = [column.id, column.align, column.labelClassName];
    if (column.className) {
      classes.push(column.className);
    }
    if (isCellHidden(cellIndex, store.states.columns.value, column)) {
      classes.push("is-hidden");
    }
    if (!column.children) {
      classes.push("is-leaf");
    }
    return classes;
  };
  return {
    hasGutter,
    getRowClasses,
    columns
  };
}
var TableFooter = defineComponent({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2) {
    const { hasGutter, getRowClasses, columns } = useStyle$1(props2);
    return {
      getRowClasses,
      hasGutter,
      columns
    };
  },
  render() {
    let sums = [];
    if (this.summaryMethod) {
      sums = this.summaryMethod({
        columns: this.columns,
        data: this.store.states.data.value
      });
    } else {
      this.columns.forEach((column, index2) => {
        if (index2 === 0) {
          sums[index2] = this.sumText;
          return;
        }
        const values = this.store.states.data.value.map((item) => Number(item[column.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach((value) => {
          if (!isNaN(value)) {
            notNumber = false;
            const decimal = `${value}`.split(".")[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);
        if (!notNumber) {
          sums[index2] = values.reduce((prev, curr) => {
            const value = Number(curr);
            if (!isNaN(value)) {
              return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev;
            }
          }, 0);
        } else {
          sums[index2] = "";
        }
      });
    }
    return h$1("table", {
      class: "el-table__footer",
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup(this.columns, this.hasGutter),
      h$1("tbody", {
        class: [{ "has-gutter": this.hasGutter }]
      }, [
        h$1("tr", {}, [
          ...this.columns.map((column, cellIndex) => h$1("td", {
            key: cellIndex,
            colspan: column.colSpan,
            rowspan: column.rowSpan,
            class: [
              ...this.getRowClasses(column, cellIndex),
              "el-table__cell"
            ]
          }, [
            h$1("div", {
              class: ["cell", column.labelClassName]
            }, [sums[cellIndex]])
          ])),
          this.hasGutter && hGutter()
        ])
      ])
    ]);
  }
});
function useUtils(store) {
  const setCurrentRow = (row) => {
    store.commit("setCurrentRow", row);
  };
  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };
  const clearSelection = () => {
    store.clearSelection();
  };
  const clearFilter = (columnKeys) => {
    store.clearFilter(columnKeys);
  };
  const toggleAllSelection = () => {
    store.commit("toggleAllSelection");
  };
  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };
  const clearSort = () => {
    store.clearSort();
  };
  const sort2 = (prop, order2) => {
    store.commit("sort", { prop, order: order2 });
  };
  return {
    setCurrentRow,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    sort: sort2
  };
}
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function useStyle(props2, layout, store, table) {
  const $ELEMENT2 = useGlobalConfig();
  const isHidden = ref(false);
  const renderExpanded = ref(null);
  const resizeProxyVisible = ref(false);
  const setDragVisible = (visible) => {
    resizeProxyVisible.value = visible;
  };
  const resizeState = ref({
    width: null,
    height: null
  });
  const isGroup = ref(false);
  watchEffect(() => {
    layout.setHeight(props2.height);
  });
  watchEffect(() => {
    layout.setMaxHeight(props2.maxHeight);
  });
  watch(() => [props2.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
    if (!unref(rowKey))
      return;
    store.setCurrentRowKey(`${currentRowKey}`);
  }, {
    immediate: true
  });
  watch(() => props2.data, (data) => {
    table.store.commit("setData", data);
  }, {
    immediate: true,
    deep: true
  });
  watchEffect(() => {
    if (props2.expandRowKeys) {
      store.setExpandRowKeysAdapter(props2.expandRowKeys);
    }
  });
  const handleMouseLeave = () => {
    table.store.commit("setHoverRow", null);
    if (table.hoverState)
      table.hoverState = null;
  };
  const handleHeaderFooterMousewheel = (event, data) => {
    const { pixelX, pixelY } = data;
    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };
  const shouldUpdateHeight = computed(() => {
    return props2.height || props2.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout.updateElsHeight();
    }
    layout.updateColumnsWidth();
    syncPostion();
  };
  onMounted(() => __async$1(this, null, function* () {
    setScrollClass("is-scrolling-left");
    store.updateColumns();
    yield nextTick();
    bindEvents();
    doLayout();
    resizeState.value = {
      width: table.vnode.el.offsetWidth,
      height: table.vnode.el.offsetHeight
    };
    store.states.columns.value.forEach((column) => {
      if (column.filteredValue && column.filteredValue.length) {
        table.store.commit("filterChange", {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  }));
  const setScrollClassByEl = (el, className) => {
    if (!el)
      return;
    const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
    classList.push(layout.scrollX.value ? className : "is-scrolling-none");
    el.className = classList.join(" ");
  };
  const setScrollClass = (className) => {
    const { bodyWrapper } = table.refs;
    setScrollClassByEl(bodyWrapper, className);
  };
  const syncPostion = throttle_1(function() {
    if (!table.refs.bodyWrapper)
      return;
    const { scrollLeft, scrollTop, offsetWidth, scrollWidth } = table.refs.bodyWrapper;
    const {
      headerWrapper,
      footerWrapper,
      fixedBodyWrapper,
      rightFixedBodyWrapper
    } = table.refs;
    if (headerWrapper)
      headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper)
      footerWrapper.scrollLeft = scrollLeft;
    if (fixedBodyWrapper)
      fixedBodyWrapper.scrollTop = scrollTop;
    if (rightFixedBodyWrapper)
      rightFixedBodyWrapper.scrollTop = scrollTop;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
    if (scrollLeft >= maxScrollLeftPosition) {
      setScrollClass("is-scrolling-right");
    } else if (scrollLeft === 0) {
      setScrollClass("is-scrolling-left");
    } else {
      setScrollClass("is-scrolling-middle");
    }
  }, 10);
  const bindEvents = () => {
    table.refs.bodyWrapper.addEventListener("scroll", syncPostion, {
      passive: true
    });
    if (props2.fit) {
      addResizeListener(table.vnode.el, resizeListener);
    } else {
      on(window, "resize", doLayout);
    }
  };
  onUnmounted(() => {
    unbindEvents();
  });
  const unbindEvents = () => {
    var _a;
    (_a = table.refs.bodyWrapper) == null ? void 0 : _a.removeEventListener("scroll", syncPostion, true);
    if (props2.fit) {
      removeResizeListener(table.vnode.el, resizeListener);
    } else {
      off(window, "resize", doLayout);
    }
  };
  const resizeListener = () => {
    if (!table.$ready)
      return;
    let shouldUpdateLayout = false;
    const el = table.vnode.el;
    const { width: oldWidth, height: oldHeight } = resizeState.value;
    const width2 = el.offsetWidth;
    if (oldWidth !== width2) {
      shouldUpdateLayout = true;
    }
    const height2 = el.offsetHeight;
    if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height2) {
      shouldUpdateLayout = true;
    }
    if (shouldUpdateLayout) {
      resizeState.value = {
        width: width2,
        height: height2
      };
      doLayout();
    }
  };
  const tableSize = computed(() => {
    return props2.size || $ELEMENT2.size;
  });
  const bodyWidth = computed(() => {
    const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
    return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
  });
  const bodyHeight = computed(() => {
    const headerHeight = layout.headerHeight.value || 0;
    const bodyHeight2 = layout.bodyHeight.value;
    const footerHeight = layout.footerHeight.value || 0;
    if (props2.height) {
      return {
        height: bodyHeight2 ? `${bodyHeight2}px` : ""
      };
    } else if (props2.maxHeight) {
      const maxHeight = parseHeight(props2.maxHeight);
      if (typeof maxHeight === "number") {
        return {
          "max-height": `${maxHeight - footerHeight - (props2.showHeader ? headerHeight : 0)}px`
        };
      }
    }
    return {};
  });
  const emptyBlockStyle = computed(() => {
    if (props2.data && props2.data.length)
      return null;
    let height2 = "100%";
    if (layout.appendHeight.value) {
      height2 = `calc(100% - ${layout.appendHeight.value}px)`;
    }
    return {
      width: bodyWidth.value,
      height: height2
    };
  });
  const handleFixedMousewheel = (event, data) => {
    const bodyWrapper = table.refs.bodyWrapper;
    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;
      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event.preventDefault();
      }
      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event.preventDefault();
      }
      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };
  const fixedHeight = computed(() => {
    if (props2.maxHeight) {
      if (props2.showSummary) {
        return {
          bottom: 0
        };
      }
      return {
        bottom: layout.scrollX.value && props2.data.length ? `${layout.gutterWidth}px` : ""
      };
    } else {
      if (props2.showSummary) {
        return {
          height: layout.tableHeight.value ? `${layout.tableHeight.value}px` : ""
        };
      }
      return {
        height: layout.viewportHeight.value ? `${layout.viewportHeight.value}px` : ""
      };
    }
  });
  const fixedBodyHeight = computed(() => {
    if (props2.height) {
      return {
        height: layout.fixedBodyHeight.value ? `${layout.fixedBodyHeight.value}px` : ""
      };
    } else if (props2.maxHeight) {
      let maxHeight = parseHeight(props2.maxHeight);
      if (typeof maxHeight === "number") {
        maxHeight = layout.scrollX.value ? maxHeight - layout.gutterWidth : maxHeight;
        if (props2.showHeader) {
          maxHeight -= layout.headerHeight.value;
        }
        maxHeight -= layout.footerHeight.value;
        return {
          "max-height": `${maxHeight}px`
        };
      }
    }
    return {};
  });
  return {
    isHidden,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    bodyHeight,
    emptyBlockStyle,
    handleFixedMousewheel,
    fixedHeight,
    fixedBodyHeight,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    doLayout
  };
}
var defaultProps$1 = {
  data: {
    type: Array,
    default: () => {
      return [];
    }
  },
  size: String,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => {
      return {
        hasChildren: "hasChildren",
        children: "children"
      };
    }
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  }
};
let tableIdSeed = 1;
var script$6 = defineComponent({
  name: "ElTable",
  directives: {
    Mousewheel: Mousewheel$1
  },
  components: {
    TableHeader,
    TableBody,
    TableFooter
  },
  props: defaultProps$1,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(props2) {
    const { t } = useLocaleInject();
    const table = getCurrentInstance();
    const store = createStore(table, props2);
    table.store = store;
    const layout = new TableLayout$1({
      store: table.store,
      table,
      fit: props2.fit,
      showHeader: props2.showHeader
    });
    table.layout = layout;
    const isEmpty2 = computed(() => (store.states.data.value || []).length === 0);
    const {
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort: sort2
    } = useUtils(store);
    const {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout
    } = useStyle(props2, layout, store, table);
    const debouncedUpdateLayout = debounce_1(doLayout, 50);
    const tableId = `el-table_${tableIdSeed++}`;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    return {
      layout,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden,
      isEmpty: isEmpty2,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      bodyWidth,
      bodyHeight,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort: sort2,
      t,
      setDragVisible,
      context: table
    };
  }
});
const _hoisted_1$w = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
const _hoisted_2$o = {
  key: 0,
  ref: "headerWrapper",
  class: "el-table__header-wrapper"
};
const _hoisted_3$k = { class: "el-table__empty-text" };
const _hoisted_4$d = {
  key: 1,
  ref: "appendWrapper",
  class: "el-table__append-wrapper"
};
const _hoisted_5$9 = {
  key: 1,
  ref: "footerWrapper",
  class: "el-table__footer-wrapper"
};
const _hoisted_6$7 = {
  key: 0,
  ref: "fixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_7$6 = {
  key: 1,
  ref: "fixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_8$4 = {
  key: 0,
  ref: "rightFixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_9$3 = {
  key: 1,
  ref: "rightFixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_10$2 = {
  ref: "resizeProxy",
  class: "el-table__column-resize-proxy"
};
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_header = resolveComponent("table-header");
  const _component_table_body = resolveComponent("table-body");
  const _component_table_footer = resolveComponent("table-footer");
  const _directive_mousewheel = resolveDirective("mousewheel");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      {
        "el-table--fit": _ctx.fit,
        "el-table--striped": _ctx.stripe,
        "el-table--border": _ctx.border || _ctx.isGroup,
        "el-table--hidden": _ctx.isHidden,
        "el-table--group": _ctx.isGroup,
        "el-table--fluid-height": _ctx.maxHeight,
        "el-table--scrollable-x": _ctx.layout.scrollX.value,
        "el-table--scrollable-y": _ctx.layout.scrollY.value,
        "el-table--enable-row-hover": !_ctx.store.states.isComplex.value,
        "el-table--enable-row-transition": (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100
      },
      _ctx.tableSize ? `el-table--${_ctx.tableSize}` : "",
      _ctx.className,
      "el-table"
    ]),
    style: normalizeStyle(_ctx.style),
    onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
  }, [
    createElementVNode("div", _hoisted_1$w, [
      renderSlot(_ctx.$slots, "default")
    ], 512),
    _ctx.showHeader ? withDirectives((openBlock(), createElementBlock("div", _hoisted_2$o, [
      createVNode(_component_table_header, {
        ref: "tableHeader",
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        onSetDragVisible: _ctx.setDragVisible
      }, null, 8, ["border", "default-sort", "store", "style", "onSetDragVisible"])
    ], 512)), [
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref: "bodyWrapper",
      style: normalizeStyle([_ctx.bodyHeight]),
      class: "el-table__body-wrapper"
    }, [
      createVNode(_component_table_body, {
        context: _ctx.context,
        highlight: _ctx.highlightCurrentRow,
        "row-class-name": _ctx.rowClassName,
        "tooltip-effect": _ctx.tooltipEffect,
        "row-style": _ctx.rowStyle,
        store: _ctx.store,
        stripe: _ctx.stripe,
        style: normalizeStyle({
          width: _ctx.bodyWidth
        })
      }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
      _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "emptyBlock",
        style: normalizeStyle(_ctx.emptyBlockStyle),
        class: "el-table__empty-block"
      }, [
        createElementVNode("span", _hoisted_3$k, [
          renderSlot(_ctx.$slots, "empty", {}, () => [
            createTextVNode(toDisplayString(_ctx.emptyText || _ctx.t("el.table.emptyText")), 1)
          ])
        ])
      ], 4)) : createCommentVNode("v-if", true),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
        renderSlot(_ctx.$slots, "append")
      ], 512)) : createCommentVNode("v-if", true)
    ], 4),
    _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_5$9, [
      createVNode(_component_table_footer, {
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
        "summary-method": _ctx.summaryMethod
      }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
    ], 512)), [
      [vShow, !_ctx.isEmpty],
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.fixedColumns.value.length > 0 ? withDirectives((openBlock(), createElementBlock("div", {
      key: 2,
      ref: "fixedWrapper",
      style: normalizeStyle([
        {
          width: _ctx.layout.fixedWidth.value ? _ctx.layout.fixedWidth.value + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed"
    }, [
      _ctx.showHeader ? (openBlock(), createElementBlock("div", _hoisted_6$7, [
        createVNode(_component_table_header, {
          ref: "fixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "fixedBodyWrapper",
        style: normalizeStyle([
          {
            top: _ctx.layout.headerHeight.value + "px"
          },
          _ctx.fixedBodyHeight
        ]),
        class: "el-table__fixed-body-wrapper"
      }, [
        createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_7$6, [
        createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "left"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vShow, !_ctx.isEmpty]
      ]) : createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? withDirectives((openBlock(), createElementBlock("div", {
      key: 3,
      ref: "rightFixedWrapper",
      style: normalizeStyle([
        {
          width: _ctx.layout.rightFixedWidth.value ? _ctx.layout.rightFixedWidth.value + "px" : "",
          right: _ctx.layout.scrollY.value ? (_ctx.border ? _ctx.layout.gutterWidth : _ctx.layout.gutterWidth || 0) + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed-right"
    }, [
      _ctx.showHeader ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
        createVNode(_component_table_header, {
          ref: "rightFixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "rightFixedBodyWrapper",
        style: normalizeStyle([{ top: _ctx.layout.headerHeight.value + "px" }, _ctx.fixedBodyHeight]),
        class: "el-table__fixed-body-wrapper"
      }, [
        createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_9$3, [
        createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "right"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vShow, !_ctx.isEmpty]
      ]) : createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? (openBlock(), createElementBlock("div", {
      key: 4,
      ref: "rightFixedPatch",
      style: normalizeStyle({
        width: _ctx.layout.scrollY.value ? _ctx.layout.gutterWidth + "px" : "0",
        height: _ctx.layout.headerHeight.value + "px"
      }),
      class: "el-table__fixed-right-patch"
    }, null, 4)) : createCommentVNode("v-if", true),
    withDirectives(createElementVNode("div", _hoisted_10$2, null, 512), [
      [vShow, _ctx.resizeProxyVisible]
    ])
  ], 38);
}
script$6.render = render$6;
script$6.__file = "packages/components/table/src/table.vue";
const cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: "",
    className: "el-table-column--selection"
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};
const cellForced = {
  selection: {
    renderHeader({ store }) {
      function isDisabled() {
        return store.states.data.value && store.states.data.value.length === 0;
      }
      return h$1(ElCheckbox, {
        disabled: isDisabled(),
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        "onUpdate:modelValue": store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },
    renderCell({
      row,
      column,
      store,
      $index
    }) {
      return h$1(ElCheckbox, {
        disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
        onChange: () => {
          store.commit("rowSelectedChanged", row);
        },
        onClick: (event) => event.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({ column }) {
      return column.label || "#";
    },
    renderCell({
      column,
      $index
    }) {
      let i = $index + 1;
      const index2 = column.index;
      if (typeof index2 === "number") {
        i = $index + index2;
      } else if (typeof index2 === "function") {
        i = index2($index);
      }
      return h$1("div", {}, [i]);
    },
    sortable: false
  },
  expand: {
    renderHeader({ column }) {
      return column.label || "";
    },
    renderCell({ row, store }) {
      const classes = ["el-table__expand-icon"];
      if (store.states.expandRows.value.indexOf(row) > -1) {
        classes.push("el-table__expand-icon--expanded");
      }
      const callback = function(e) {
        e.stopPropagation();
        store.toggleRowExpansion(row);
      };
      return h$1("div", {
        class: classes,
        onClick: callback
      }, [
        h$1("i", {
          class: "el-icon el-icon-arrow-right"
        })
      ]);
    },
    sortable: false,
    resizable: false,
    className: "el-table__expand-column"
  }
};
function defaultRenderCell({
  row,
  column,
  $index
}) {
  var _a;
  const property = column.property;
  const value = property && getPropByPath(row, property, false).v;
  if (column && column.formatter) {
    return column.formatter(row, column, value, $index);
  }
  return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
}
function treeCellPrefix({
  row,
  treeNode,
  store
}) {
  if (!treeNode)
    return null;
  const ele = [];
  const callback = function(e) {
    e.stopPropagation();
    store.loadOrToggle(row);
  };
  if (treeNode.indent) {
    ele.push(h$1("span", {
      class: "el-table__indent",
      style: { "padding-left": `${treeNode.indent}px` }
    }));
  }
  if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
    const expandClasses = [
      "el-table__expand-icon",
      treeNode.expanded ? "el-table__expand-icon--expanded" : ""
    ];
    let iconClasses = ["el-icon-arrow-right"];
    if (treeNode.loading) {
      iconClasses = ["el-icon-loading"];
    }
    ele.push(h$1("div", {
      class: expandClasses,
      onClick: callback
    }, [
      h$1("i", {
        class: iconClasses
      })
    ]));
  } else {
    ele.push(h$1("span", {
      class: "el-table__placeholder"
    }));
  }
  return ele;
}
function useWatcher(owner, props_) {
  const instance = getCurrentInstance();
  const registerComplexWatchers = () => {
    const props2 = ["fixed"];
    const aliases = {
      realWidth: "width",
      realMinWidth: "minWidth"
    };
    const allAliases = props2.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach((key2) => {
      const columnKey = aliases[key2];
      if (hasOwn(props_, columnKey)) {
        watch(() => props_[columnKey], (newVal) => {
          let value = newVal;
          if (columnKey === "width" && key2 === "realWidth") {
            value = parseWidth(newVal);
          }
          if (columnKey === "minWidth" && key2 === "realMinWidth") {
            value = parseMinWidth(newVal);
          }
          instance.columnConfig.value[columnKey] = value;
          instance.columnConfig.value[key2] = value;
          const updateColumns = columnKey === "fixed";
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };
  const registerNormalWatchers = () => {
    const props2 = [
      "label",
      "filters",
      "filterMultiple",
      "sortable",
      "index",
      "formatter",
      "className",
      "labelClassName",
      "showOverflowTooltip"
    ];
    const aliases = {
      property: "prop",
      align: "realAlign",
      headerAlign: "realHeaderAlign"
    };
    const allAliases = props2.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach((key2) => {
      const columnKey = aliases[key2];
      if (hasOwn(props_, columnKey)) {
        watch(() => props_[columnKey], (newVal) => {
          instance.columnConfig.value[key2] = newVal;
        });
      }
    });
  };
  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}
function useRender(props2, slots, owner) {
  const instance = getCurrentInstance();
  const columnId = ref("");
  const isSubColumn = ref(false);
  const realAlign = ref();
  const realHeaderAlign = ref();
  watchEffect(() => {
    realAlign.value = props2.align ? `is-${props2.align}` : null;
    realAlign.value;
  });
  watchEffect(() => {
    realHeaderAlign.value = props2.headerAlign ? `is-${props2.headerAlign}` : realAlign.value;
    realHeaderAlign.value;
  });
  const columnOrTableParent = computed(() => {
    let parent = instance.vnode.vParent || instance.parent;
    while (parent && !parent.tableId && !parent.columnId) {
      parent = parent.vnode.vParent || parent.parent;
    }
    return parent;
  });
  const realWidth = ref(parseWidth(props2.width));
  const realMinWidth = ref(parseMinWidth(props2.minWidth));
  const setColumnWidth = (column) => {
    if (realWidth.value)
      column.width = realWidth.value;
    if (realMinWidth.value) {
      column.minWidth = realMinWidth.value;
    }
    if (!column.minWidth) {
      column.minWidth = 80;
    }
    column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
    return column;
  };
  const setColumnForcedProps = (column) => {
    const type4 = column.type;
    const source = cellForced[type4] || {};
    Object.keys(source).forEach((prop) => {
      const value = source[prop];
      if (value !== void 0) {
        column[prop] = prop === "className" ? `${column[prop]} ${value}` : value;
      }
    });
    return column;
  };
  const checkSubColumn = (children) => {
    if (children instanceof Array) {
      children.forEach((child) => check(child));
    } else {
      check(children);
    }
    function check(item) {
      var _a;
      if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
        item.vParent = instance;
      }
    }
  };
  const setColumnRenders = (column) => {
    if (props2.renderHeader)
      ;
    else if (column.type !== "selection") {
      column.renderHeader = (scope) => {
        instance.columnConfig.value["label"];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column.label;
      };
    }
    let originRenderCell = column.renderCell;
    if (column.type === "expand") {
      column.renderCell = (data) => h$1("div", {
        class: "cell"
      }, [originRenderCell(data)]);
      owner.value.renderExpanded = (data) => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell;
      column.renderCell = (data) => {
        let children = null;
        if (slots.default) {
          children = slots.default(data);
        } else {
          children = originRenderCell(data);
        }
        const prefix = treeCellPrefix(data);
        const props22 = {
          class: "cell",
          style: {}
        };
        if (column.showOverflowTooltip) {
          props22.class += " el-tooltip";
          props22.style = {
            width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
          };
        }
        checkSubColumn(children);
        return h$1("div", props22, [prefix, children]);
      };
    }
    return column;
  };
  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach((key2) => {
          prev[key2] = props2[key2];
        });
      }
      return prev;
    }, {});
  };
  const getColumnElIndex = (children, child) => {
    return [].indexOf.call(children, child);
  };
  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}
var defaultProps = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showTooltipWhenOverflow: Boolean,
  showOverflowTooltip: Boolean,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => {
      return ["ascending", "descending", null];
    },
    validator: (val) => {
      return val.every((order2) => ["ascending", "descending", null].indexOf(order2) > -1);
    }
  }
};
var __defProp$6 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key2, value) => key2 in obj ? __defProp$6(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$6.call(b2, prop))
      __defNormalProp$6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b2)) {
      if (__propIsEnum$6.call(b2, prop))
        __defNormalProp$6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$3 = (a2, b2) => __defProps$3(a2, __getOwnPropDescs$3(b2));
let columnIdSeed = 1;
var ElTableColumn$1 = defineComponent({
  name: "ElTableColumn",
  components: {
    ElCheckbox
  },
  props: defaultProps,
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const columnConfig = ref({});
    const owner = computed(() => {
      let parent2 = instance.parent;
      while (parent2 && !parent2.tableId) {
        parent2 = parent2.parent;
      }
      return parent2;
    });
    const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props2);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = useRender(props2, slots, owner);
    const parent = columnOrTableParent.value;
    columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
    onBeforeMount(() => {
      isSubColumn.value = owner.value !== parent;
      const type4 = props2.type || "default";
      const sortable = props2.sortable === "" ? true : props2.sortable;
      const defaults2 = __spreadProps$3(__spreadValues$6({}, cellStarts[type4]), {
        id: columnId.value,
        type: type4,
        property: props2.prop || props2.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props2.showOverflowTooltip || props2.showTooltipWhenOverflow,
        filterable: props2.filters || props2.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: false,
        filterOpened: false,
        sortable,
        index: props2.index,
        rawColumnKey: instance.vnode.key
      });
      const basicProps = [
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ];
      const sortProps = ["sortMethod", "sortBy", "sortOrders"];
      const selectProps = ["selectable", "reserveSelection"];
      const filterProps = [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ];
      let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column = mergeOptions(defaults2, column);
      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column = chains(column);
      columnConfig.value = column;
      registerNormalWatchers();
      registerComplexWatchers();
    });
    onMounted(() => {
      var _a;
      const parent2 = columnOrTableParent.value;
      const children = isSubColumn.value ? parent2.vnode.el.children : (_a = parent2.refs.hiddenColumns) == null ? void 0 : _a.children;
      const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
      columnConfig.value.getColumnIndex = getColumnIndex;
      const columnIndex = getColumnIndex();
      columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
    });
    onBeforeUnmount(() => {
      owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
    });
    instance.columnId = columnId.value;
    instance.columnConfig = columnConfig;
    return;
  },
  render() {
    var _a, _b, _c;
    let children = [];
    try {
      const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
        row: {},
        column: {},
        $index: -1
      });
      if (renderDefault instanceof Array) {
        for (const childNode of renderDefault) {
          if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn") {
            children.push(childNode);
          } else if (childNode.type === Fragment && childNode.children instanceof Array) {
            children.push(...childNode.children);
          }
        }
      }
    } catch (e) {
      children = [];
    }
    return h$1("div", children);
  }
});
const ElTable = withInstall(script$6, {
  TableColumn: ElTableColumn$1
});
const ElTableColumn = withNoopInstall(ElTableColumn$1);
var script$2$1 = defineComponent({
  name: "ElTabBar",
  directives: {
    Resize: Resize$1
  },
  props: {
    tabs: {
      type: Array,
      default: () => []
    }
  },
  setup(props2) {
    const rootTabs = inject("rootTabs");
    if (!rootTabs) {
      throw new Error(`ElTabBar must use with ElTabs`);
    }
    const instance = getCurrentInstance();
    const getBarStyle = () => {
      const style = {};
      let offset2 = 0;
      let tabSize = 0;
      const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
      const sizeDir = sizeName === "width" ? "x" : "y";
      props2.tabs.every((tab) => {
        var _a;
        const $el = (_a = instance.parent.refs) == null ? void 0 : _a[`tab-${tab.paneName}`];
        if (!$el) {
          return false;
        }
        if (!tab.active) {
          return true;
        } else {
          tabSize = $el[`client${capitalize(sizeName)}`];
          const position = sizeDir === "x" ? "left" : "top";
          offset2 = $el.getBoundingClientRect()[position] - $el.parentElement.getBoundingClientRect()[position];
          const tabStyles = window.getComputedStyle($el);
          if (sizeName === "width") {
            if (props2.tabs.length > 1) {
              tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
            }
            offset2 += parseFloat(tabStyles.paddingLeft);
          }
          return false;
        }
      });
      const transform = `translate${capitalize(sizeDir)}(${offset2}px)`;
      style[sizeName] = `${tabSize}px`;
      style.transform = transform;
      style.msTransform = transform;
      style.webkitTransform = transform;
      return style;
    };
    const barStyle = ref(getBarStyle());
    const update = () => {
      barStyle.value = getBarStyle();
    };
    watch(() => props2.tabs, () => {
      nextTick(() => {
        update();
      });
    });
    return {
      rootTabs,
      barStyle,
      update
    };
  }
});
function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_resize = resolveDirective("resize");
  return withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-tabs__active-bar", `is-${_ctx.rootTabs.props.tabPosition}`]),
    style: normalizeStyle(_ctx.barStyle)
  }, null, 6)), [
    [_directive_resize, _ctx.update]
  ]);
}
script$2$1.render = render$1$2;
script$2$1.__file = "packages/components/tabs/src/tab-bar.vue";
var script$1$2 = defineComponent({
  name: "ElTabNav",
  components: {
    TabBar: script$2$1
  },
  props: {
    panes: {
      type: Array,
      default: () => []
    },
    currentName: {
      type: String,
      default: ""
    },
    editable: Boolean,
    onTabClick: {
      type: Function,
      default: NOOP
    },
    onTabRemove: {
      type: Function,
      default: NOOP
    },
    type: {
      type: String,
      default: ""
    },
    stretch: Boolean
  },
  setup() {
    const rootTabs = inject("rootTabs");
    if (!rootTabs) {
      throwError("[ElTabNav]", `ElTabNav must be nested inside ElTabs`);
    }
    const scrollable = ref(false);
    const navOffset = ref(0);
    const isFocus = ref(false);
    const focusable = ref(true);
    const navScroll$ = ref(null);
    const nav$ = ref(null);
    const el$ = ref(null);
    const sizeName = computed(() => {
      return ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
    });
    const navStyle = computed(() => {
      const dir = sizeName.value === "width" ? "X" : "Y";
      return {
        transform: `translate${dir}(-${navOffset.value}px)`
      };
    });
    const scrollPrev = () => {
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (!currentOffset)
        return;
      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
      navOffset.value = newOffset;
    };
    const scrollNext = () => {
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (navSize - currentOffset <= containerSize)
        return;
      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
      navOffset.value = newOffset;
    };
    const scrollToActiveTab = () => {
      if (!scrollable.value)
        return;
      const nav = nav$.value;
      const activeTab = el$.value.querySelector(".is-active");
      if (!activeTab)
        return;
      const navScroll = navScroll$.value;
      const isHorizontal = ["top", "bottom"].includes(rootTabs.props.tabPosition);
      const activeTabBounding = activeTab.getBoundingClientRect();
      const navScrollBounding = navScroll.getBoundingClientRect();
      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
      const currentOffset = navOffset.value;
      let newOffset = currentOffset;
      if (isHorizontal) {
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
      } else {
        if (activeTabBounding.top < navScrollBounding.top) {
          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
        }
        if (activeTabBounding.bottom > navScrollBounding.bottom) {
          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
        }
      }
      newOffset = Math.max(newOffset, 0);
      navOffset.value = Math.min(newOffset, maxOffset);
    };
    const update = () => {
      if (!nav$.value)
        return;
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (containerSize < navSize) {
        const currentOffset2 = navOffset.value;
        scrollable.value = scrollable.value || {};
        scrollable.value.prev = currentOffset2;
        scrollable.value.next = currentOffset2 + containerSize < navSize;
        if (navSize - currentOffset2 < containerSize) {
          navOffset.value = navSize - containerSize;
        }
      } else {
        scrollable.value = false;
        if (currentOffset > 0) {
          navOffset.value = 0;
        }
      }
    };
    const changeTab = (e) => {
      const code = e.code;
      let nextIndex;
      let currentIndex, tabList;
      const { up, down, left: left2, right: right2 } = EVENT_CODE;
      if ([up, down, left2, right2].indexOf(code) !== -1) {
        tabList = e.currentTarget.querySelectorAll("[role=tab]");
        currentIndex = Array.prototype.indexOf.call(tabList, e.target);
      } else {
        return;
      }
      if (code === left2 || code === up) {
        if (currentIndex === 0) {
          nextIndex = tabList.length - 1;
        } else {
          nextIndex = currentIndex - 1;
        }
      } else {
        if (currentIndex < tabList.length - 1) {
          nextIndex = currentIndex + 1;
        } else {
          nextIndex = 0;
        }
      }
      tabList[nextIndex].focus();
      tabList[nextIndex].click();
      setFocus();
    };
    const setFocus = () => {
      if (focusable.value) {
        isFocus.value = true;
      }
    };
    const removeFocus = () => {
      isFocus.value = false;
    };
    const visibilityChangeHandler = () => {
      const visibility = document.visibilityState;
      if (visibility === "hidden") {
        focusable.value = false;
      } else if (visibility === "visible") {
        setTimeout(() => {
          focusable.value = true;
        }, 50);
      }
    };
    const windowBlurHandler = () => {
      focusable.value = false;
    };
    const windowFocusHandler = () => {
      setTimeout(() => {
        focusable.value = true;
      }, 50);
    };
    onUpdated(() => {
      update();
    });
    onMounted(() => {
      addResizeListener(el$.value, update);
      on(document, "visibilitychange", visibilityChangeHandler);
      on(window, "blur", windowBlurHandler);
      on(window, "focus", windowFocusHandler);
      setTimeout(() => {
        scrollToActiveTab();
      }, 0);
    });
    onBeforeUnmount(() => {
      if (el$.value) {
        removeResizeListener(el$.value, update);
      }
      off(document, "visibilitychange", visibilityChangeHandler);
      off(window, "blur", windowBlurHandler);
      off(window, "focus", windowFocusHandler);
    });
    return {
      rootTabs,
      scrollable,
      navOffset,
      isFocus,
      focusable,
      navScroll$,
      nav$,
      el$,
      sizeName,
      navStyle,
      scrollPrev,
      scrollNext,
      scrollToActiveTab,
      update,
      changeTab,
      setFocus,
      removeFocus,
      visibilityChangeHandler,
      windowBlurHandler,
      windowFocusHandler
    };
  },
  render() {
    const {
      type: type4,
      panes,
      editable,
      stretch,
      onTabClick,
      onTabRemove,
      navStyle,
      scrollable,
      scrollNext,
      scrollPrev,
      changeTab,
      setFocus,
      removeFocus,
      rootTabs,
      isFocus
    } = this;
    const scrollBtn = scrollable ? [
      h$1("span", {
        class: [
          "el-tabs__nav-prev",
          scrollable.prev ? "" : "is-disabled"
        ],
        onClick: scrollPrev
      }, [h$1("i", { class: "el-icon-arrow-left" })]),
      h$1("span", {
        class: [
          "el-tabs__nav-next",
          scrollable.next ? "" : "is-disabled"
        ],
        onClick: scrollNext
      }, [h$1("i", { class: "el-icon-arrow-right" })])
    ] : null;
    const tabs = panes.map((pane, index2) => {
      var _a, _b;
      const tabName = pane.props.name || pane.index || `${index2}`;
      const closable = pane.isClosable || editable;
      pane.index = `${index2}`;
      const btnClose = closable ? h$1("span", {
        class: "el-icon-close",
        onClick: (ev) => {
          onTabRemove(pane, ev);
        }
      }) : null;
      const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;
      const tabindex = pane.active ? 0 : -1;
      return h$1("div", {
        class: {
          "el-tabs__item": true,
          [`is-${rootTabs.props.tabPosition}`]: true,
          "is-active": pane.active,
          "is-disabled": pane.props.disabled,
          "is-closable": closable,
          "is-focus": isFocus
        },
        id: `tab-${tabName}`,
        key: `tab-${tabName}`,
        "aria-controls": `pane-${tabName}`,
        role: "tab",
        "aria-selected": pane.active,
        ref: `tab-${tabName}`,
        tabindex,
        onFocus: () => {
          setFocus();
        },
        onBlur: () => {
          removeFocus();
        },
        onClick: (ev) => {
          removeFocus();
          onTabClick(pane, tabName, ev);
        },
        onKeydown: (ev) => {
          if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
            onTabRemove(pane, ev);
          }
        }
      }, [tabLabelContent, btnClose]);
    });
    return h$1("div", {
      ref: "el$",
      class: [
        "el-tabs__nav-wrap",
        scrollable ? "is-scrollable" : "",
        `is-${rootTabs.props.tabPosition}`
      ]
    }, [
      scrollBtn,
      h$1("div", {
        class: "el-tabs__nav-scroll",
        ref: "navScroll$"
      }, [
        h$1("div", {
          class: [
            "el-tabs__nav",
            `is-${rootTabs.props.tabPosition}`,
            stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "is-stretch" : ""
          ],
          ref: "nav$",
          style: navStyle,
          role: "tablist",
          onKeydown: changeTab
        }, [
          !type4 ? h$1(script$2$1, {
            tabs: [...panes]
          }) : null,
          tabs
        ])
      ])
    ]);
  }
});
script$1$2.__file = "packages/components/tabs/src/tab-nav.vue";
var Tabs = defineComponent({
  name: "ElTabs",
  components: { TabNav: script$1$2 },
  props: {
    type: {
      type: String,
      default: ""
    },
    activeName: {
      type: String,
      default: ""
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
      type: String,
      default: ""
    },
    editable: Boolean,
    tabPosition: {
      type: String,
      default: "top"
    },
    beforeLeave: {
      type: Function,
      default: null
    },
    stretch: Boolean
  },
  emits: [
    "tab-click",
    "edit",
    "tab-remove",
    "tab-add",
    "input",
    "update:modelValue"
  ],
  setup(props2, ctx) {
    const nav$ = ref(null);
    const currentName = ref(props2.modelValue || props2.activeName || "0");
    const panes = ref([]);
    const instance = getCurrentInstance();
    const paneStatesMap = {};
    provide("rootTabs", {
      props: props2,
      currentName
    });
    provide("updatePaneState", (pane) => {
      paneStatesMap[pane.uid] = pane;
    });
    watch(() => props2.activeName, (modelValue) => {
      setCurrentName(modelValue);
    });
    watch(() => props2.modelValue, (modelValue) => {
      setCurrentName(modelValue);
    });
    watch(currentName, () => {
      nextTick(() => {
        nav$.value && nav$.value.$nextTick(() => {
          nav$.value && nav$.value.scrollToActiveTab();
        });
      });
      setPaneInstances(true);
    });
    const getPaneInstanceFromSlot = (vnode, paneInstanceList = []) => {
      Array.from(vnode.children || []).forEach((node) => {
        let type4 = node.type;
        type4 = type4.name || type4;
        if (type4 === "ElTabPane" && node.component) {
          paneInstanceList.push(node.component);
        } else if (type4 === Fragment || type4 === "template") {
          getPaneInstanceFromSlot(node, paneInstanceList);
        }
      });
      return paneInstanceList;
    };
    const setPaneInstances = (isForceUpdate = false) => {
      if (ctx.slots.default) {
        const children = instance.subTree.children;
        const content = Array.from(children).find(({ props: props22 }) => {
          return props22.class === "el-tabs__content";
        });
        if (!content)
          return;
        const paneInstanceList = getPaneInstanceFromSlot(content).map((paneComponent) => {
          return paneStatesMap[paneComponent.uid];
        });
        const panesChanged = !(paneInstanceList.length === panes.value.length && paneInstanceList.every((pane, index2) => pane.uid === panes.value[index2].uid));
        if (isForceUpdate || panesChanged) {
          panes.value = paneInstanceList;
        }
      } else if (panes.value.length !== 0) {
        panes.value = [];
      }
    };
    const changeCurrentName = (value) => {
      currentName.value = value;
      ctx.emit("input", value);
      ctx.emit("update:modelValue", value);
    };
    const setCurrentName = (value) => {
      if (currentName.value === value)
        return;
      const beforeLeave = props2.beforeLeave;
      const before = beforeLeave && beforeLeave(value, currentName.value);
      if (before && isPromise(before)) {
        before.then(() => {
          var _a, _b;
          changeCurrentName(value);
          (_b = (_a = nav$.value).removeFocus) == null ? void 0 : _b.call(_a);
        }, () => {
        });
      } else if (before !== false) {
        changeCurrentName(value);
      }
    };
    const handleTabClick = (tab, tabName, event) => {
      if (tab.props.disabled)
        return;
      setCurrentName(tabName);
      ctx.emit("tab-click", tab, event);
    };
    const handleTabRemove = (pane, ev) => {
      if (pane.props.disabled)
        return;
      ev.stopPropagation();
      ctx.emit("edit", pane.props.name, "remove");
      ctx.emit("tab-remove", pane.props.name);
    };
    const handleTabAdd = () => {
      ctx.emit("edit", null, "add");
      ctx.emit("tab-add");
    };
    onUpdated(() => {
      setPaneInstances();
    });
    onMounted(() => {
      setPaneInstances();
    });
    return {
      nav$,
      handleTabClick,
      handleTabRemove,
      handleTabAdd,
      currentName,
      panes
    };
  },
  render() {
    var _a;
    const {
      type: type4,
      handleTabClick,
      handleTabRemove,
      handleTabAdd,
      currentName,
      panes,
      editable,
      addable,
      tabPosition: tabPosition2,
      stretch
    } = this;
    const newButton = editable || addable ? h$1("span", {
      class: "el-tabs__new-tab",
      tabindex: "0",
      onClick: handleTabAdd,
      onKeydown: (ev) => {
        if (ev.code === EVENT_CODE.enter) {
          handleTabAdd();
        }
      }
    }, [h$1("i", { class: "el-icon-plus" })]) : null;
    const header = h$1("div", {
      class: ["el-tabs__header", `is-${tabPosition2}`]
    }, [
      newButton,
      h$1(script$1$2, {
        currentName,
        editable,
        type: type4,
        panes,
        stretch,
        ref: "nav$",
        onTabClick: handleTabClick,
        onTabRemove: handleTabRemove
      })
    ]);
    const panels = h$1("div", {
      class: "el-tabs__content"
    }, (_a = this.$slots) == null ? void 0 : _a.default());
    return h$1("div", {
      class: {
        "el-tabs": true,
        "el-tabs--card": type4 === "card",
        [`el-tabs--${tabPosition2}`]: true,
        "el-tabs--border-card": type4 === "border-card"
      }
    }, tabPosition2 !== "bottom" ? [header, panels] : [panels, header]);
  }
});
var script$5 = defineComponent({
  name: "ElTabPane",
  props: {
    label: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    closable: Boolean,
    disabled: Boolean,
    lazy: Boolean
  },
  setup(props2) {
    const index2 = ref(null);
    const loaded = ref(false);
    const rootTabs = inject("rootTabs");
    const updatePaneState = inject("updatePaneState");
    if (!rootTabs || !updatePaneState) {
      throw new Error(`ElTabPane must use with ElTabs`);
    }
    const isClosable = computed(() => {
      return props2.closable || rootTabs.props.closable;
    });
    const active = computed(() => {
      return rootTabs.currentName.value === (props2.name || index2.value);
    });
    const paneName = computed(() => {
      return props2.name || index2.value;
    });
    const shouldBeRender = computed(() => {
      return !props2.lazy || loaded.value || active.value;
    });
    watch(active, (val) => {
      if (val)
        loaded.value = true;
    });
    const instance = getCurrentInstance();
    updatePaneState({
      uid: instance.uid,
      instance,
      props: props2,
      paneName,
      active,
      index: index2,
      isClosable
    });
    return {
      index: index2,
      loaded,
      isClosable,
      active,
      paneName,
      shouldBeRender
    };
  }
});
const _hoisted_1$v = ["id", "aria-hidden", "aria-labelledby"];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.shouldBeRender ? withDirectives((openBlock(), createElementBlock("div", {
    key: 0,
    id: `pane-${_ctx.paneName}`,
    class: "el-tab-pane",
    role: "tabpanel",
    "aria-hidden": !_ctx.active,
    "aria-labelledby": `tab-${_ctx.paneName}`
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$v)), [
    [vShow, _ctx.active]
  ]) : createCommentVNode("v-if", true);
}
script$5.render = render$5;
script$5.__file = "packages/components/tabs/src/tab-pane.vue";
const ElTabs = withInstall(Tabs, {
  TabPane: script$5
});
const ElTabPane = withNoopInstall(script$5);
function arrayEach$1(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
var _arrayEach = arrayEach$1;
var baseAssignValue$1 = _baseAssignValue, eq = eq_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue$2(object4, key2, value) {
  var objValue = object4[key2];
  if (!(hasOwnProperty$2.call(object4, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object4)) {
    baseAssignValue$1(object4, key2, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source, props2, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key2 = props2[index2];
    var newValue = customizer ? customizer(object4[key2], source[key2], key2, object4, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object4, key2, newValue);
    } else {
      assignValue$1(object4, key2, newValue);
    }
  }
  return object4;
}
var _copyObject = copyObject$4;
var copyObject$3 = _copyObject, keys$1 = keys_1;
function baseAssign$1(object4, source) {
  return object4 && copyObject$3(source, keys$1(source), object4);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object4) {
  var result = [];
  if (object4 != null) {
    for (var key2 in Object(object4)) {
      result.push(key2);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseKeysIn$1(object4) {
  if (!isObject$2(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype$1(object4), result = [];
  for (var key2 in object4) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$1.call(object4, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object4, source) {
  return object4 && copyObject$2(source, keysIn$2(source), object4);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$1(source, array4) {
  var index2 = -1, length = source.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source[index2];
  }
  return array4;
}
var _copyArray = copyArray$1;
var copyObject$1 = _copyObject, getSymbols$1 = _getSymbols;
function copySymbols$1(source, object4) {
  return copyObject$1(source, getSymbols$1(source), object4);
}
var _copySymbols = copySymbols$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush = _arrayPush, getPrototype$1 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object4) {
  var result = [];
  while (object4) {
    arrayPush(result, getSymbols(object4));
    object4 = getPrototype$1(object4);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object4) {
  return copyObject(source, getSymbolsIn$1(source), object4);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object4) {
  return baseGetAllKeys(object4, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(array4) {
  var length = array4.length, result = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array2 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp4) {
  var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result.lastIndex = regexp4.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object4, tag, isDeep) {
  var Ctor = object4.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object4);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object4);
    case dataViewTag$1:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object4);
    case regexpTag$1:
      return cloneRegExp(object4);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object4);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$1 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result = new object4();
    object4.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBuffer$3.exports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key2, object4, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object4 ? customizer(value, key2, object4, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object4) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object4 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key3) {
      result.set(key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props2 = isArr ? void 0 : keysFunc(value);
  arrayEach(props2 || value, function(subValue, key3) {
    if (props2) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result, key3, baseClone$1(subValue, bitmask, customizer, key3, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
function getError(action, option2, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to ${option2.method} ${action} ${xhr.status}`;
  }
  const err = new Error(msg);
  err.status = xhr.status;
  err.method = option2.method;
  err.url = action;
  return err;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
function upload(option2) {
  if (typeof XMLHttpRequest === "undefined") {
    return;
  }
  const xhr = new XMLHttpRequest();
  const action = option2.action;
  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option2.onProgress(e);
    };
  }
  const formData = new FormData();
  if (option2.data) {
    Object.keys(option2.data).forEach((key2) => {
      formData.append(key2, option2.data[key2]);
    });
  }
  formData.append(option2.filename, option2.file, option2.file.name);
  xhr.onerror = function error() {
    option2.onError(getError(action, option2, xhr));
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option2.onError(getError(action, option2, xhr));
    }
    option2.onSuccess(getBody(xhr));
  };
  xhr.open(option2.method, action, true);
  if (option2.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option2.headers || {};
  for (const item in headers) {
    if (hasOwn(headers, item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  }
  xhr.send(formData);
  return xhr;
}
var script$3 = defineComponent({
  name: "ElUploadList",
  components: { ElProgress: _Progress },
  props: {
    files: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    handlePreview: {
      type: Function,
      default: () => NOOP
    },
    listType: {
      type: String,
      default: "text"
    }
  },
  emits: ["remove"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const handleClick = (file) => {
      props2.handlePreview(file);
    };
    const onFileClicked = (e) => {
      e.target.focus();
    };
    const handleRemove = (e, file) => {
      emit2("remove", file);
    };
    return {
      focusing: ref(false),
      handleClick,
      handleRemove,
      onFileClicked,
      t
    };
  }
});
const _hoisted_1$1$1 = ["onKeydown"];
const _hoisted_2$n = ["src"];
const _hoisted_3$j = ["onClick"];
const _hoisted_4$c = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-document" }, null, -1);
const _hoisted_5$8 = { class: "el-upload-list__item-status-label" };
const _hoisted_6$6 = ["onClick"];
const _hoisted_7$5 = {
  key: 2,
  class: "el-icon-close-tip"
};
const _hoisted_8$3 = {
  key: 4,
  class: "el-upload-list__item-actions"
};
const _hoisted_9$2 = ["onClick"];
const _hoisted_10$1 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-zoom-in" }, null, -1);
const _hoisted_11$1 = [
  _hoisted_10$1
];
const _hoisted_12$1 = ["onClick"];
const _hoisted_13 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-delete" }, null, -1);
const _hoisted_14 = [
  _hoisted_13
];
function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_progress = resolveComponent("el-progress");
  return openBlock(), createBlock(TransitionGroup, {
    tag: "ul",
    class: normalizeClass([
      "el-upload-list",
      "el-upload-list--" + _ctx.listType,
      { "is-disabled": _ctx.disabled }
    ]),
    name: "el-list"
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
        return openBlock(), createElementBlock("li", {
          key: file.uid || file,
          class: normalizeClass([
            "el-upload-list__item",
            "is-" + file.status,
            _ctx.focusing ? "focusing" : ""
          ]),
          tabindex: "0",
          onKeydown: withKeys(($event) => !_ctx.disabled && _ctx.handleRemove($event, file), ["delete"]),
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusing = true),
          onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusing = false),
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onFileClicked && _ctx.onFileClicked(...args))
        }, [
          renderSlot(_ctx.$slots, "default", { file }, () => [
            file.status !== "uploading" && ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createElementBlock("img", {
              key: 0,
              class: "el-upload-list__item-thumbnail",
              src: file.url,
              alt: ""
            }, null, 8, _hoisted_2$n)) : createCommentVNode("v-if", true),
            createElementVNode("a", {
              class: "el-upload-list__item-name",
              onClick: ($event) => _ctx.handleClick(file)
            }, [
              _hoisted_4$c,
              createTextVNode(toDisplayString(file.name), 1)
            ], 8, _hoisted_3$j),
            createElementVNode("label", _hoisted_5$8, [
              createElementVNode("i", {
                class: normalizeClass({
                  "el-icon-upload-success": true,
                  "el-icon-circle-check": _ctx.listType === "text",
                  "el-icon-check": ["picture-card", "picture"].includes(_ctx.listType)
                })
              }, null, 2)
            ]),
            !_ctx.disabled ? (openBlock(), createElementBlock("i", {
              key: 1,
              class: "el-icon-close",
              onClick: ($event) => _ctx.handleRemove($event, file)
            }, null, 8, _hoisted_6$6)) : createCommentVNode("v-if", true),
            createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            createCommentVNode(" This is a bug which needs to be fixed "),
            createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
            !_ctx.disabled ? (openBlock(), createElementBlock("i", _hoisted_7$5, toDisplayString(_ctx.t("el.upload.deleteTip")), 1)) : createCommentVNode("v-if", true),
            file.status === "uploading" ? (openBlock(), createBlock(_component_el_progress, {
              key: 3,
              type: _ctx.listType === "picture-card" ? "circle" : "line",
              "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
              percentage: +file.percentage
            }, null, 8, ["type", "stroke-width", "percentage"])) : createCommentVNode("v-if", true),
            _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", _hoisted_8$3, [
              createElementVNode("span", {
                class: "el-upload-list__item-preview",
                onClick: ($event) => _ctx.handlePreview(file)
              }, _hoisted_11$1, 8, _hoisted_9$2),
              !_ctx.disabled ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: "el-upload-list__item-delete",
                onClick: ($event) => _ctx.handleRemove($event, file)
              }, _hoisted_14, 8, _hoisted_12$1)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ])
        ], 42, _hoisted_1$1$1);
      }), 128))
    ]),
    _: 3
  }, 8, ["class"]);
}
script$3.render = render$2$1;
script$3.__file = "packages/components/upload/src/upload-list.vue";
var script$2 = defineComponent({
  name: "ElUploadDrag",
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["file"],
  setup(props2, { emit: emit2 }) {
    const uploader = inject("uploader", {});
    const dragover = ref(false);
    function onDrop(e) {
      if (props2.disabled || !uploader)
        return;
      const accept = uploader.accept;
      dragover.value = false;
      if (!accept) {
        emit2("file", e.dataTransfer.files);
        return;
      }
      emit2("file", Array.from(e.dataTransfer.files).filter((file) => {
        const { type: type4, name } = file;
        const extension = name.indexOf(".") > -1 ? `.${name.split(".").pop()}` : "";
        const baseType = type4.replace(/\/.*$/, "");
        return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
          if (acceptedType.startsWith(".")) {
            return extension === acceptedType;
          }
          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, "");
          }
          if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
            return type4 === acceptedType;
          }
          return false;
        });
      }));
    }
    function onDragover() {
      if (!props2.disabled)
        dragover.value = true;
    }
    return {
      dragover,
      onDrop,
      onDragover
    };
  }
});
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass({
      "el-upload-dragger": true,
      "is-dragover": _ctx.dragover
    }),
    onDrop: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.onDrop && _ctx.onDrop(...args), ["prevent"])),
    onDragover: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.onDragover && _ctx.onDragover(...args), ["prevent"])),
    onDragleave: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.dragover = false, ["prevent"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
script$2.render = render$1$1;
script$2.__file = "packages/components/upload/src/upload-dragger.vue";
var script$1$1 = defineComponent({
  components: {
    UploadDragger: script$2
  },
  props: {
    type: {
      type: String,
      default: ""
    },
    action: {
      type: String,
      required: true
    },
    name: {
      type: String,
      default: "file"
    },
    data: {
      type: Object,
      default: () => null
    },
    headers: {
      type: Object,
      default: () => null
    },
    method: {
      type: String,
      default: "post"
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: null
    },
    accept: {
      type: String,
      default: ""
    },
    onStart: {
      type: Function,
      default: NOOP
    },
    onProgress: {
      type: Function,
      default: NOOP
    },
    onSuccess: {
      type: Function,
      default: NOOP
    },
    onError: {
      type: Function,
      default: NOOP
    },
    beforeUpload: {
      type: Function,
      default: NOOP
    },
    drag: {
      type: Boolean,
      default: false
    },
    onPreview: {
      type: Function,
      default: NOOP
    },
    onRemove: {
      type: Function,
      default: NOOP
    },
    fileList: {
      type: Array,
      default: () => []
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: "text"
    },
    httpRequest: {
      type: Function,
      default: () => upload
    },
    disabled: Boolean,
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: NOOP
    }
  },
  setup(props2) {
    const reqs = ref({});
    const mouseover = ref(false);
    const inputRef = ref(null);
    function uploadFiles(files) {
      if (props2.limit && props2.fileList.length + files.length > props2.limit) {
        props2.onExceed(files, props2.fileList);
        return;
      }
      let postFiles = Array.from(files);
      if (!props2.multiple) {
        postFiles = postFiles.slice(0, 1);
      }
      if (postFiles.length === 0) {
        return;
      }
      postFiles.forEach((rawFile) => {
        props2.onStart(rawFile);
        if (props2.autoUpload)
          upload2(rawFile);
      });
    }
    function upload2(rawFile) {
      inputRef.value.value = null;
      if (!props2.beforeUpload) {
        return post(rawFile);
      }
      const before = props2.beforeUpload(rawFile);
      if (before instanceof Promise) {
        before.then((processedFile) => {
          const fileType = Object.prototype.toString.call(processedFile);
          if (fileType === "[object File]" || fileType === "[object Blob]") {
            if (fileType === "[object Blob]") {
              processedFile = new File([processedFile], rawFile.name, {
                type: rawFile.type
              });
            }
            for (const p2 in rawFile) {
              if (hasOwn(rawFile, p2)) {
                processedFile[p2] = rawFile[p2];
              }
            }
            post(processedFile);
          } else {
            post(rawFile);
          }
        }).catch(() => {
          props2.onRemove(null, rawFile);
        });
      } else if (before !== false) {
        post(rawFile);
      } else {
        props2.onRemove(null, rawFile);
      }
    }
    function abort(file) {
      const _reqs = reqs.value;
      if (file) {
        let uid2 = file;
        if (file.uid)
          uid2 = file.uid;
        if (_reqs[uid2]) {
          _reqs[uid2].abort();
        }
      } else {
        Object.keys(_reqs).forEach((uid2) => {
          if (_reqs[uid2])
            _reqs[uid2].abort();
          delete _reqs[uid2];
        });
      }
    }
    function post(rawFile) {
      const { uid: uid2 } = rawFile;
      const options2 = {
        headers: props2.headers,
        withCredentials: props2.withCredentials,
        file: rawFile,
        data: props2.data,
        method: props2.method,
        filename: props2.name,
        action: props2.action,
        onProgress: (e) => {
          props2.onProgress(e, rawFile);
        },
        onSuccess: (res) => {
          props2.onSuccess(res, rawFile);
          delete reqs.value[uid2];
        },
        onError: (err) => {
          props2.onError(err, rawFile);
          delete reqs.value[uid2];
        }
      };
      const req = props2.httpRequest(options2);
      reqs.value[uid2] = req;
      if (req instanceof Promise) {
        req.then(options2.onSuccess, options2.onError);
      }
    }
    function handleChange(e) {
      const files = e.target.files;
      if (!files)
        return;
      uploadFiles(files);
    }
    function handleClick() {
      if (!props2.disabled) {
        inputRef.value.value = null;
        inputRef.value.click();
      }
    }
    function handleKeydown() {
      handleClick();
    }
    return {
      reqs,
      mouseover,
      inputRef,
      abort,
      post,
      handleChange,
      handleClick,
      handleKeydown,
      upload: upload2,
      uploadFiles
    };
  }
});
const _hoisted_1$u = ["name", "multiple", "accept"];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_upload_dragger = resolveComponent("upload-dragger");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-upload", `el-upload--${_ctx.listType}`]),
    tabindex: "0",
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"]), ["enter", "space"]))
  }, [
    _ctx.drag ? (openBlock(), createBlock(_component_upload_dragger, {
      key: 0,
      disabled: _ctx.disabled,
      onFile: _ctx.uploadFiles
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["disabled", "onFile"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
    createElementVNode("input", {
      ref: "inputRef",
      class: "el-upload__input",
      type: "file",
      name: _ctx.name,
      multiple: _ctx.multiple,
      accept: _ctx.accept,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 40, _hoisted_1$u)
  ], 34);
}
script$1$1.render = render$4;
script$1$1.__file = "packages/components/upload/src/upload.vue";
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key2, value) => key2 in obj ? __defProp$2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
function getFile(rawFile, uploadFiles) {
  return uploadFiles.find((file) => file.uid === rawFile.uid);
}
function genUid(seed2) {
  return Date.now() + seed2;
}
var useHandlers = (props2) => {
  const uploadFiles = ref([]);
  const uploadRef = ref(null);
  let tempIndex = 1;
  function abort(file) {
    uploadRef.value.abort(file);
  }
  function clearFiles(status = ["success", "fail"]) {
    uploadFiles.value = uploadFiles.value.filter((row) => {
      return status.indexOf(row.status) === -1;
    });
  }
  function handleError(err, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    file.status = "fail";
    uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
    props2.onError(err, file, uploadFiles.value);
    props2.onChange(file, uploadFiles.value);
  }
  function handleProgress(ev, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    props2.onProgress(ev, file, uploadFiles.value);
    file.status = "uploading";
    file.percentage = ev.percent || 0;
  }
  function handleSuccess(res, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    if (file) {
      file.status = "success";
      file.response = res;
      props2.onSuccess(res, file, uploadFiles.value);
      props2.onChange(file, uploadFiles.value);
    }
  }
  function handleStart(rawFile) {
    const uid2 = genUid(tempIndex++);
    rawFile.uid = uid2;
    const file = {
      name: rawFile.name,
      percentage: 0,
      status: "ready",
      size: rawFile.size,
      raw: rawFile,
      uid: uid2
    };
    if (props2.listType === "picture-card" || props2.listType === "picture") {
      try {
        file.url = URL.createObjectURL(rawFile);
      } catch (err) {
        console.error("[Element Error][Upload]", err);
        props2.onError(err, file, uploadFiles.value);
      }
    }
    uploadFiles.value.push(file);
    props2.onChange(file, uploadFiles.value);
  }
  function handleRemove(file, raw) {
    if (raw) {
      file = getFile(raw, uploadFiles.value);
    }
    const revokeObjectURL = () => {
      if (file.url && file.url.indexOf("blob:") === 0) {
        URL.revokeObjectURL(file.url);
      }
    };
    const doRemove = () => {
      abort(file);
      const fileList = uploadFiles.value;
      fileList.splice(fileList.indexOf(file), 1);
      props2.onRemove(file, fileList);
      revokeObjectURL();
    };
    if (!props2.beforeRemove) {
      doRemove();
    } else if (typeof props2.beforeRemove === "function") {
      const before = props2.beforeRemove(file, uploadFiles.value);
      if (before instanceof Promise) {
        before.then(() => {
          doRemove();
        }).catch(NOOP);
      } else if (before !== false) {
        doRemove();
      }
    }
  }
  function submit() {
    uploadFiles.value.filter((file) => file.status === "ready").forEach((file) => {
      uploadRef.value.upload(file.raw);
    });
  }
  watch(() => props2.listType, (val) => {
    if (val === "picture-card" || val === "picture") {
      uploadFiles.value = uploadFiles.value.map((file) => {
        if (!file.url && file.raw) {
          try {
            file.url = URL.createObjectURL(file.raw);
          } catch (err) {
            props2.onError(err, file, uploadFiles.value);
          }
        }
        return file;
      });
    }
  });
  watch(() => props2.fileList, (fileList) => {
    uploadFiles.value = fileList.map((file) => {
      const cloneFile = cloneDeep_1(file);
      return __spreadProps$2(__spreadValues$2({}, cloneFile), {
        uid: file.uid || genUid(tempIndex++),
        status: file.status || "success"
      });
    });
  }, {
    immediate: true,
    deep: true
  });
  return {
    abort,
    clearFiles,
    handleError,
    handleProgress,
    handleStart,
    handleSuccess,
    handleRemove,
    submit,
    uploadFiles,
    uploadRef
  };
};
var script$4 = defineComponent({
  name: "ElUpload",
  components: {
    Upload: script$1$1,
    UploadList: script$3
  },
  props: {
    action: {
      type: String,
      required: true
    },
    headers: {
      type: Object,
      default: () => ({})
    },
    method: {
      type: String,
      default: "post"
    },
    data: {
      type: Object,
      default: () => ({})
    },
    multiple: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: "file"
    },
    drag: {
      type: Boolean,
      default: false
    },
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: true
    },
    accept: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "select"
    },
    beforeUpload: {
      type: Function,
      default: NOOP
    },
    beforeRemove: {
      type: Function,
      default: NOOP
    },
    onRemove: {
      type: Function,
      default: NOOP
    },
    onChange: {
      type: Function,
      default: NOOP
    },
    onPreview: {
      type: Function,
      default: NOOP
    },
    onSuccess: {
      type: Function,
      default: NOOP
    },
    onProgress: {
      type: Function,
      default: NOOP
    },
    onError: {
      type: Function,
      default: NOOP
    },
    fileList: {
      type: Array,
      default: () => {
        return [];
      }
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: "text"
    },
    httpRequest: {
      type: Function,
      default: upload
    },
    disabled: Boolean,
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: () => NOOP
    }
  },
  setup(props2) {
    const elForm2 = inject(elFormKey, {});
    const uploadDisabled = computed(() => {
      return props2.disabled || elForm2.disabled;
    });
    const {
      abort,
      clearFiles,
      handleError,
      handleProgress,
      handleStart,
      handleSuccess,
      handleRemove,
      submit,
      uploadRef,
      uploadFiles
    } = useHandlers(props2);
    provide("uploader", getCurrentInstance());
    onBeforeUnmount(() => {
      uploadFiles.value.forEach((file) => {
        if (file.url && file.url.indexOf("blob:") === 0) {
          URL.revokeObjectURL(file.url);
        }
      });
    });
    return {
      abort,
      dragOver: ref(false),
      draging: ref(false),
      handleError,
      handleProgress,
      handleRemove,
      handleStart,
      handleSuccess,
      uploadDisabled,
      uploadFiles,
      uploadRef,
      submit,
      clearFiles
    };
  },
  render() {
    var _a, _b;
    let uploadList;
    if (this.showFileList) {
      uploadList = h$1(script$3, {
        disabled: this.uploadDisabled,
        listType: this.listType,
        files: this.uploadFiles,
        onRemove: this.handleRemove,
        handlePreview: this.onPreview
      }, this.$slots.file ? {
        default: (props2) => {
          return this.$slots.file({
            file: props2.file
          });
        }
      } : null);
    } else {
      uploadList = null;
    }
    const uploadData2 = {
      type: this.type,
      drag: this.drag,
      action: this.action,
      multiple: this.multiple,
      "before-upload": this.beforeUpload,
      "with-credentials": this.withCredentials,
      headers: this.headers,
      method: this.method,
      name: this.name,
      data: this.data,
      accept: this.accept,
      fileList: this.uploadFiles,
      autoUpload: this.autoUpload,
      listType: this.listType,
      disabled: this.uploadDisabled,
      limit: this.limit,
      "on-exceed": this.onExceed,
      "on-start": this.handleStart,
      "on-progress": this.handleProgress,
      "on-success": this.handleSuccess,
      "on-error": this.handleError,
      "on-preview": this.onPreview,
      "on-remove": this.handleRemove,
      "http-request": this.httpRequest,
      ref: "uploadRef"
    };
    const trigger = this.$slots.trigger || this.$slots.default;
    const uploadComponent = h$1(script$1$1, uploadData2, {
      default: () => trigger == null ? void 0 : trigger()
    });
    return h$1("div", [
      this.listType === "picture-card" ? uploadList : null,
      this.$slots.trigger ? [uploadComponent, this.$slots.default()] : uploadComponent,
      (_b = (_a = this.$slots).tip) == null ? void 0 : _b.call(_a),
      this.listType !== "picture-card" ? uploadList : null
    ]);
  }
});
script$4.__file = "packages/components/upload/src/index.vue";
script$4.install = (app) => {
  app.component(script$4.name, script$4);
};
const _Upload = script$4;
const ElUpload = _Upload;
const messageTypes = ["success", "info", "warning", "error"];
const messageProps = {
  customClass: {
    type: String,
    default: ""
  },
  center: {
    type: Boolean,
    default: false
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3e3
  },
  iconClass: {
    type: String,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  message: buildProp({
    type: definePropType([String, Object]),
    default: ""
  }),
  onClose: buildProp({
    type: definePropType(Function),
    required: false
  }),
  showClose: {
    type: Boolean,
    default: false
  },
  type: buildProp({
    type: String,
    values: messageTypes,
    default: "info"
  }),
  offset: {
    type: Number,
    default: 20
  },
  zIndex: {
    type: Number,
    default: 0
  }
};
const messageEmits = {
  destroy: () => true
};
const typeMap = {
  success: "el-icon-success",
  info: "el-icon-info",
  warning: "el-icon-warning",
  error: "el-icon-error"
};
var script$1 = defineComponent({
  name: "ElMessage",
  props: messageProps,
  emits: messageEmits,
  setup(props2) {
    const visible = ref(false);
    let timer = void 0;
    const typeClass = computed(() => {
      var _a;
      return props2.iconClass ? props2.iconClass : (_a = typeMap[props2.type]) != null ? _a : "";
    });
    const customStyle = computed(() => ({
      top: `${props2.offset}px`,
      zIndex: props2.zIndex
    }));
    function startTimer() {
      if (props2.duration > 0) {
        ({ stop: timer } = useTimeoutFn(() => {
          if (visible.value)
            close2();
        }, props2.duration));
      }
    }
    function clearTimer() {
      timer == null ? void 0 : timer();
    }
    function close2() {
      visible.value = false;
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        if (visible.value) {
          close2();
        }
      } else {
        startTimer();
      }
    }
    onMounted(() => {
      startTimer();
      visible.value = true;
    });
    useEventListener(document, "keydown", keydown);
    return {
      typeClass,
      customStyle,
      visible,
      close: close2,
      clearTimer,
      startTimer
    };
  }
});
const _hoisted_1$t = ["id"];
const _hoisted_2$m = {
  key: 0,
  class: "el-message__content"
};
const _hoisted_3$i = ["innerHTML"];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "el-message-fade",
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("destroy"))
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        id: _ctx.id,
        class: normalizeClass([
          "el-message",
          _ctx.type && !_ctx.iconClass ? `el-message--${_ctx.type}` : "",
          _ctx.center ? "is-center" : "",
          _ctx.showClose ? "is-closable" : "",
          _ctx.customClass
        ]),
        style: normalizeStyle(_ctx.customStyle),
        role: "alert",
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.startTimer && _ctx.startTimer(...args))
      }, [
        _ctx.type || _ctx.iconClass ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-message__icon", _ctx.typeClass, _ctx.iconClass])
        }, null, 2)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default", {}, () => [
          !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_2$m, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
            createElementVNode("p", {
              class: "el-message__content",
              innerHTML: _ctx.message
            }, null, 8, _hoisted_3$i)
          ], 2112))
        ]),
        _ctx.showClose ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "el-message__closeBtn el-icon-close",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.close && _ctx.close(...args), ["stop"]))
        })) : createCommentVNode("v-if", true)
      ], 46, _hoisted_1$t), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeLeave"]);
}
script$1.render = render$3;
script$1.__file = "packages/components/message/src/message.vue";
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key2, value) => key2 in obj ? __defProp$1(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b2) => __defProps$1(a2, __getOwnPropDescs$1(b2));
const instances = [];
let seed = 1;
const message = function(options2 = {}) {
  if (isServer)
    return { close: () => void 0 };
  if (typeof options2 === "string" || isVNode(options2)) {
    options2 = { message: options2 };
  }
  let verticalOffset = options2.offset || 20;
  instances.forEach(({ vm: vm2 }) => {
    var _a;
    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + 16;
  });
  verticalOffset += 16;
  const id2 = `message_${seed++}`;
  const userOnClose = options2.onClose;
  const props2 = __spreadProps$1(__spreadValues$1({
    zIndex: PopupManager$1.nextZIndex(),
    offset: verticalOffset
  }, options2), {
    id: id2,
    onClose: () => {
      close(id2, userOnClose);
    }
  });
  const container = document.createElement("div");
  container.className = `container_${id2}`;
  const message2 = props2.message;
  const vm = createVNode(script$1, props2, isVNode(props2.message) ? { default: () => message2 } : null);
  vm.props.onDestroy = () => {
    render$t(null, container);
  };
  render$t(vm, container);
  instances.push({ vm });
  document.body.appendChild(container.firstElementChild);
  return {
    close: () => vm.component.proxy.visible = false
  };
};
messageTypes.forEach((type4) => {
  message[type4] = (options2 = {}) => {
    if (typeof options2 === "string" || isVNode(options2)) {
      options2 = {
        message: options2
      };
    }
    return message(__spreadProps$1(__spreadValues$1({}, options2), {
      type: type4
    }));
  };
});
function close(id2, userOnClose) {
  const idx = instances.findIndex(({ vm: vm2 }) => id2 === vm2.component.props.id);
  if (idx === -1)
    return;
  const { vm } = instances[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  instances.splice(idx, 1);
  const len = instances.length;
  if (len < 1)
    return;
  for (let i = idx; i < len; i++) {
    const pos = parseInt(instances[i].vm.el.style["top"], 10) - removedHeight - 16;
    instances[i].vm.component.props.offset = pos;
  }
}
function closeAll() {
  var _a;
  for (let i = instances.length - 1; i >= 0; i--) {
    const instance = instances[i].vm.component;
    (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.close();
  }
}
message.closeAll = closeAll;
const ElMessage = withInstallFunction(message, "$message");
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const TypeMap = {
  success: "success",
  info: "info",
  warning: "warning",
  error: "error"
};
var script = defineComponent({
  name: "ElMessageBox",
  directives: {
    TrapFocus: TrapFocus$1
  },
  components: {
    ElButton,
    ElInput: _Input,
    ElOverlay
  },
  inheritAttrs: false,
  props: {
    buttonSize: {
      type: String,
      validator: isValidComponentSize
    },
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    roundButton: {
      default: false,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const visible = ref(false);
    const state = reactive({
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: false,
      distinguishCancelAndClose: false,
      iconClass: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: true,
      modalClass: "",
      showCancelButton: false,
      showConfirmButton: true,
      type: "",
      title: void 0,
      showInput: false,
      action: "",
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonDisabled: false,
      editorErrorMessage: "",
      validateError: false,
      zIndex: PopupManager$1.nextZIndex()
    });
    const icon = computed(() => state.iconClass || (state.type && TypeMap[state.type] ? `el-icon-${TypeMap[state.type]}` : ""));
    const hasMessage = computed(() => !!state.message);
    const inputRef = ref(null);
    const confirmRef = ref(null);
    const confirmButtonClasses = computed(() => `el-button--primary ${state.confirmButtonClass}`);
    watch(() => state.inputValue, (val) => __async(this, null, function* () {
      yield nextTick();
      if (props2.boxType === "prompt" && val !== null) {
        validate();
      }
    }), { immediate: true });
    watch(() => visible.value, (val) => {
      if (val) {
        if (props2.boxType === "alert" || props2.boxType === "confirm") {
          nextTick().then(() => {
            var _a, _b, _c;
            (_c = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus) == null ? void 0 : _c.call(_b);
          });
        }
        state.zIndex = PopupManager$1.nextZIndex();
      }
      if (props2.boxType !== "prompt")
        return;
      if (val) {
        nextTick().then(() => {
          if (inputRef.value && inputRef.value.$el) {
            getInputElement().focus();
          }
        });
      } else {
        state.editorErrorMessage = "";
        state.validateError = false;
      }
    });
    onMounted(() => __async(this, null, function* () {
      yield nextTick();
      if (props2.closeOnHashChange) {
        on(window, "hashchange", doClose);
      }
    }));
    onBeforeUnmount(() => {
      if (props2.closeOnHashChange) {
        off(window, "hashchange", doClose);
      }
    });
    function doClose() {
      if (!visible.value)
        return;
      visible.value = false;
      nextTick(() => {
        if (state.action)
          emit2("action", state.action);
      });
    }
    const handleWrapperClick = () => {
      if (props2.closeOnClickModal) {
        handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
      }
    };
    const handleInputEnter = () => {
      if (state.inputType !== "textarea") {
        return handleAction("confirm");
      }
    };
    const handleAction = (action) => {
      var _a;
      if (props2.boxType === "prompt" && action === "confirm" && !validate()) {
        return;
      }
      state.action = action;
      if (state.beforeClose) {
        (_a = state.beforeClose) == null ? void 0 : _a.call(state, action, state, doClose);
      } else {
        doClose();
      }
    };
    const validate = () => {
      if (props2.boxType === "prompt") {
        const inputPattern = state.inputPattern;
        if (inputPattern && !inputPattern.test(state.inputValue || "")) {
          state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
          state.validateError = true;
          return false;
        }
        const inputValidator = state.inputValidator;
        if (typeof inputValidator === "function") {
          const validateResult = inputValidator(state.inputValue);
          if (validateResult === false) {
            state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
            state.validateError = true;
            return false;
          }
          if (typeof validateResult === "string") {
            state.editorErrorMessage = validateResult;
            state.validateError = true;
            return false;
          }
        }
      }
      state.editorErrorMessage = "";
      state.validateError = false;
      return true;
    };
    const getInputElement = () => {
      const inputRefs = inputRef.value.$refs;
      return inputRefs.input || inputRefs.textarea;
    };
    const handleClose = () => {
      handleAction("close");
    };
    if (props2.closeOnPressEscape) {
      useModal({
        handleClose
      }, visible);
    } else {
      usePreventGlobal(visible, "keydown", (e) => e.code === EVENT_CODE.esc);
    }
    if (props2.lockScroll) {
      useLockScreen(visible);
    }
    useRestoreActive(visible);
    return __spreadProps2(__spreadValues2({}, toRefs(state)), {
      visible,
      hasMessage,
      icon,
      confirmButtonClasses,
      inputRef,
      confirmRef,
      doClose,
      handleClose,
      handleWrapperClick,
      handleInputEnter,
      handleAction,
      t
    });
  }
});
const _hoisted_1$s = ["aria-label"];
const _hoisted_2$l = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_3$h = { class: "el-message-box__title" };
const _hoisted_4$b = /* @__PURE__ */ createElementVNode("i", { class: "el-message-box__close el-icon-close" }, null, -1);
const _hoisted_5$7 = [
  _hoisted_4$b
];
const _hoisted_6$5 = { class: "el-message-box__content" };
const _hoisted_7$4 = { class: "el-message-box__container" };
const _hoisted_8$2 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_9$1 = { key: 0 };
const _hoisted_10 = ["innerHTML"];
const _hoisted_11 = { class: "el-message-box__input" };
const _hoisted_12 = { class: "el-message-box__btns" };
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_overlay = resolveComponent("el-overlay");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("vanish"))
  }, {
    default: withCtx(() => [
      withDirectives(createVNode(_component_el_overlay, {
        "z-index": _ctx.zIndex,
        "overlay-class": ["is-message-box", _ctx.modalClass],
        mask: _ctx.modal,
        onClick: withModifiers(_ctx.handleWrapperClick, ["self"])
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            ref: "root",
            "aria-label": _ctx.title || "dialog",
            "aria-modal": "true",
            class: normalizeClass([
              "el-message-box",
              _ctx.customClass,
              { "el-message-box--center": _ctx.center }
            ]),
            style: normalizeStyle(_ctx.customStyle)
          }, [
            _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", _hoisted_2$l, [
              createElementVNode("div", _hoisted_3$h, [
                _ctx.icon && _ctx.center ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["el-message-box__status", _ctx.icon])
                }, null, 2)) : createCommentVNode("v-if", true),
                createElementVNode("span", null, toDisplayString(_ctx.title), 1)
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: "el-message-box__headerbtn",
                "aria-label": "Close",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
              }, _hoisted_5$7, 32)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            createElementVNode("div", _hoisted_6$5, [
              createElementVNode("div", _hoisted_7$4, [
                _ctx.icon && !_ctx.center && _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["el-message-box__status", _ctx.icon])
                }, null, 2)) : createCommentVNode("v-if", true),
                _ctx.hasMessage ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_9$1, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock("p", {
                      key: 1,
                      innerHTML: _ctx.message
                    }, null, 8, _hoisted_10))
                  ])
                ])) : createCommentVNode("v-if", true)
              ]),
              withDirectives(createElementVNode("div", _hoisted_11, [
                createVNode(_component_el_input, {
                  ref: "inputRef",
                  modelValue: _ctx.inputValue,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                  type: _ctx.inputType,
                  placeholder: _ctx.inputPlaceholder,
                  class: normalizeClass({ invalid: _ctx.validateError }),
                  onKeydown: withKeys(withModifiers(_ctx.handleInputEnter, ["prevent"]), ["enter"])
                }, null, 8, ["modelValue", "type", "placeholder", "class", "onKeydown"]),
                createElementVNode("div", {
                  class: "el-message-box__errormsg",
                  style: normalizeStyle({
                    visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                  })
                }, toDisplayString(_ctx.editorErrorMessage), 5)
              ], 512), [
                [vShow, _ctx.showInput]
              ])
            ]),
            createElementVNode("div", _hoisted_12, [
              _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                key: 0,
                loading: _ctx.cancelButtonLoading,
                class: normalizeClass([_ctx.cancelButtonClass]),
                round: _ctx.roundButton,
                size: _ctx.buttonSize || "small",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
              withDirectives(createVNode(_component_el_button, {
                ref: "confirmRef",
                loading: _ctx.confirmButtonLoading,
                class: normalizeClass([_ctx.confirmButtonClasses]),
                round: _ctx.roundButton,
                disabled: _ctx.confirmButtonDisabled,
                size: _ctx.buttonSize || "small",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "disabled", "size"]), [
                [vShow, _ctx.showConfirmButton]
              ])
            ])
          ], 14, _hoisted_1$s), [
            [_directive_trap_focus]
          ])
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask", "onClick"]), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
script.render = render$2;
script.__file = "packages/components/message-box/src/index.vue";
const messageInstance = new Map();
const initInstance = (props2, container) => {
  const vnode = h$1(script, props2);
  render$t(vnode, container);
  document.body.appendChild(container.firstElementChild);
  return vnode.component;
};
const genContainer = () => {
  return document.createElement("div");
};
const showMessage = (options2) => {
  const container = genContainer();
  options2.onVanish = () => {
    render$t(null, container);
    messageInstance.delete(vm);
  };
  options2.onAction = (action) => {
    const currentMsg = messageInstance.get(vm);
    let resolve;
    if (options2.showInput) {
      resolve = { value: vm.inputValue, action };
    } else {
      resolve = action;
    }
    if (options2.callback) {
      options2.callback(resolve, instance.proxy);
    } else {
      if (action === "cancel" || action === "close") {
        if (options2.distinguishCancelAndClose && action !== "cancel") {
          currentMsg.reject("close");
        } else {
          currentMsg.reject("cancel");
        }
      } else {
        currentMsg.resolve(resolve);
      }
    }
  };
  const instance = initInstance(options2, container);
  const vm = instance.proxy;
  for (const prop in options2) {
    if (hasOwn(options2, prop) && !hasOwn(vm.$props, prop)) {
      vm[prop] = options2[prop];
    }
  }
  watch(() => vm.message, (newVal, oldVal) => {
    if (isVNode(newVal)) {
      instance.slots.default = () => [newVal];
    } else if (isVNode(oldVal) && !isVNode(newVal)) {
      delete instance.slots.default;
    }
  }, {
    immediate: true
  });
  vm.visible = true;
  return vm;
};
function MessageBox(options2) {
  if (isServer)
    return;
  let callback;
  if (isString$1(options2) || isVNode(options2)) {
    options2 = {
      message: options2
    };
  } else {
    callback = options2.callback;
  }
  return new Promise((resolve, reject) => {
    const vm = showMessage(options2);
    messageInstance.set(vm, {
      options: options2,
      callback,
      resolve,
      reject
    });
  });
}
MessageBox.alert = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    type: "",
    closeOnPressEscape: false,
    closeOnClickModal: false
  }, options2, {
    boxType: "alert"
  }));
};
MessageBox.confirm = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    type: "",
    showCancelButton: true
  }, options2, {
    boxType: "confirm"
  }));
};
MessageBox.prompt = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    showCancelButton: true,
    showInput: true,
    type: ""
  }, options2, {
    boxType: "prompt"
  }));
};
MessageBox.close = () => {
  messageInstance.forEach((_2, vm) => {
    vm.doClose();
  });
  messageInstance.clear();
};
const _MessageBox = MessageBox;
_MessageBox.install = (app) => {
  app.config.globalProperties.$msgbox = _MessageBox;
  app.config.globalProperties.$messageBox = _MessageBox;
  app.config.globalProperties.$alert = _MessageBox.alert;
  app.config.globalProperties.$confirm = _MessageBox.confirm;
  app.config.globalProperties.$prompt = _MessageBox.prompt;
};
const ElMessageBox = _MessageBox;
var base = "";
var elTooltip = "";
var elPopper = "";
var elDivider = "";
const _sfc_main$1K = {
  name: "objectRender",
  components: { FormRenderItem: defineAsyncComponent(() => Promise.resolve().then(function() {
    return index$3;
  })) },
  props: {
    path: String,
    modelValue: Object,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const update = (key2, value) => {
      emit2("update:modelValue", Object.assign({}, props2.modelValue, { [key2]: value }));
    };
    return {
      update
    };
  }
};
const _hoisted_1$r = { class: "form-item-list" };
function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_form_render_item = __unplugin_components_0$3;
  return openBlock(), createElementBlock("div", _hoisted_1$r, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item) => {
      return openBlock(), createBlock(_component_form_render_item, {
        key: item.uuid,
        "model-value": $props.modelValue[item.options.key],
        "onUpdate:modelValue": ($event) => $setup.update(item.options.key, $event),
        component: item.component,
        items: item.items,
        options: item.options,
        path: item.options.key ? $props.path + "." + item.options.key : $props.path,
        style: normalizeStyle({
          "padding-left": $props.options.gutter / 2 + "px",
          "padding-right": $props.options.gutter / 2 + "px"
        })
      }, null, 8, ["model-value", "onUpdate:modelValue", "component", "items", "options", "path", "style"]);
    }), 128))
  ]);
}
var __unplugin_components_0$5 = /* @__PURE__ */ _export_sfc(_sfc_main$1K, [["render", _sfc_render$1K]]);
var __glob_0_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __unplugin_components_0$5
});
var elCard = "";
const _sfc_main$1J = {
  name: "cardRender",
  components: { ElCard, objectRender: __unplugin_components_0$5 },
  props: {
    path: String,
    modelValue: Object,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
const _hoisted_1$q = { class: "card-header" };
function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_object_render = __unplugin_components_0$5;
  const _component_el_card = ElCard;
  return openBlock(), createBlock(_component_el_card, {
    class: "form-card",
    shadow: $props.options.shadow,
    "body-style": { padding: $props.options.padding }
  }, {
    header: withCtx(() => [
      createElementVNode("div", _hoisted_1$q, [
        createElementVNode("span", null, toDisplayString($props.options.label), 1)
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_object_render, {
        items: $props.items,
        options: $props.options,
        path: $props.path,
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
      }, null, 8, ["items", "options", "path", "model-value"])
    ]),
    _: 1
  }, 8, ["shadow", "body-style"]);
}
var cardRender = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["render", _sfc_render$1J]]);
var __glob_0_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cardRender
});
var elCascader = "";
var elInput = "";
var elTag = "";
var elCascaderPanel = "";
var elCheckbox = "";
var elRadio = "";
var elScrollbar = "";
var elFormItem = "";
const _sfc_main$1I = {
  name: "cascaderRender",
  components: { ElFormItem, ElCascader },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader = ElCascader;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_cascader, {
        key: 0,
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        options: $props.options.options.items,
        disabled: $props.options.disabled,
        clearable: $props.options.clearable,
        props: {
          expandTrigger: $props.options.expandTrigger
        }
      }, null, 8, ["model-value", "options", "disabled", "clearable", "props"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var cascaderRender = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$1I]]);
var __glob_0_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cascaderRender
});
var elCheckboxGroup = "";
const _sfc_main$1H = {
  name: "checkboxRender",
  components: { ElFormItem, ElCheckboxGroup: ElCheckboxGroup$1, ElCheckbox },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  const _component_el_checkbox_group = ElCheckboxGroup$1;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_checkbox_group, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_checkbox, {
              key: item.value,
              label: item.value
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(item.label), 1)
              ]),
              _: 2
            }, 1032, ["label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var checkboxRender = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$1H]]);
var __glob_0_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": checkboxRender
});
var elColorPicker = "";
var elButton = "";
const _sfc_main$1G = {
  name: "colorPickerRender",
  components: { ElFormItem, ElColorPicker },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_color_picker = ElColorPicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_color_picker, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled,
        "show-alpha": $props.options.showAlpha
      }, null, 8, ["model-value", "disabled", "show-alpha"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var colorPickerRender = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["render", _sfc_render$1G]]);
var __glob_0_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": colorPickerRender
});
var elDatePicker = "";
const _sfc_main$1F = {
  name: "datePickerRender",
  components: { ElFormItem, ElDatePicker },
  props: {
    path: String,
    modelValue: Date,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker = ElDatePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_date_picker, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var datePickerRender = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["render", _sfc_render$1F]]);
var __glob_0_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": datePickerRender
});
const _sfc_main$1E = {
  name: "dateRangePickerRender",
  components: { ElFormItem, ElDatePicker },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker = ElDatePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_date_picker, {
        type: "daterange",
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var dateRangePickerRender = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$1E]]);
var __glob_0_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": dateRangePickerRender
});
var quill_core = "";
var quill_snow = "";
var quill_bubble = "";
var quill = { exports: {} };
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object4, property) {
        return Object.prototype.hasOwnProperty.call(object4, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 109);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var container_1 = __webpack_require__(17);
        var format_1 = __webpack_require__(18);
        var leaf_1 = __webpack_require__(19);
        var scroll_1 = __webpack_require__(45);
        var inline_1 = __webpack_require__(46);
        var block_1 = __webpack_require__(47);
        var embed_1 = __webpack_require__(48);
        var text_1 = __webpack_require__(49);
        var attributor_1 = __webpack_require__(12);
        var class_1 = __webpack_require__(32);
        var style_1 = __webpack_require__(33);
        var store_1 = __webpack_require__(31);
        var Registry = __webpack_require__(1);
        var Parchment = {
          Scope: Registry.Scope,
          create: Registry.create,
          find: Registry.find,
          query: Registry.query,
          register: Registry.register,
          Container: container_1.default,
          Format: format_1.default,
          Leaf: leaf_1.default,
          Embed: embed_1.default,
          Scroll: scroll_1.default,
          Block: block_1.default,
          Inline: inline_1.default,
          Text: text_1.default,
          Attributor: {
            Attribute: attributor_1.default,
            Class: class_1.default,
            Style: style_1.default,
            Store: store_1.default
          }
        };
        exports2.default = Parchment;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var ParchmentError = function(_super) {
          __extends(ParchmentError2, _super);
          function ParchmentError2(message2) {
            var _this = this;
            message2 = "[Parchment] " + message2;
            _this = _super.call(this, message2) || this;
            _this.message = message2;
            _this.name = _this.constructor.name;
            return _this;
          }
          return ParchmentError2;
        }(Error);
        exports2.ParchmentError = ParchmentError;
        var attributes = {};
        var classes = {};
        var tags2 = {};
        var types2 = {};
        exports2.DATA_KEY = "__blot";
        var Scope;
        (function(Scope2) {
          Scope2[Scope2["TYPE"] = 3] = "TYPE";
          Scope2[Scope2["LEVEL"] = 12] = "LEVEL";
          Scope2[Scope2["ATTRIBUTE"] = 13] = "ATTRIBUTE";
          Scope2[Scope2["BLOT"] = 14] = "BLOT";
          Scope2[Scope2["INLINE"] = 7] = "INLINE";
          Scope2[Scope2["BLOCK"] = 11] = "BLOCK";
          Scope2[Scope2["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
          Scope2[Scope2["INLINE_BLOT"] = 6] = "INLINE_BLOT";
          Scope2[Scope2["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
          Scope2[Scope2["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
          Scope2[Scope2["ANY"] = 15] = "ANY";
        })(Scope = exports2.Scope || (exports2.Scope = {}));
        function create(input, value) {
          var match = query2(input);
          if (match == null) {
            throw new ParchmentError("Unable to create " + input + " blot");
          }
          var BlotClass = match;
          var node = input instanceof Node || input["nodeType"] === Node.TEXT_NODE ? input : BlotClass.create(value);
          return new BlotClass(node, value);
        }
        exports2.create = create;
        function find2(node, bubble) {
          if (bubble === void 0) {
            bubble = false;
          }
          if (node == null)
            return null;
          if (node[exports2.DATA_KEY] != null)
            return node[exports2.DATA_KEY].blot;
          if (bubble)
            return find2(node.parentNode, bubble);
          return null;
        }
        exports2.find = find2;
        function query2(query3, scope) {
          if (scope === void 0) {
            scope = Scope.ANY;
          }
          var match;
          if (typeof query3 === "string") {
            match = types2[query3] || attributes[query3];
          } else if (query3 instanceof Text || query3["nodeType"] === Node.TEXT_NODE) {
            match = types2["text"];
          } else if (typeof query3 === "number") {
            if (query3 & Scope.LEVEL & Scope.BLOCK) {
              match = types2["block"];
            } else if (query3 & Scope.LEVEL & Scope.INLINE) {
              match = types2["inline"];
            }
          } else if (query3 instanceof HTMLElement) {
            var names = (query3.getAttribute("class") || "").split(/\s+/);
            for (var i in names) {
              match = classes[names[i]];
              if (match)
                break;
            }
            match = match || tags2[query3.tagName];
          }
          if (match == null)
            return null;
          if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
            return match;
          return null;
        }
        exports2.query = query2;
        function register2() {
          var Definitions = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            Definitions[_i] = arguments[_i];
          }
          if (Definitions.length > 1) {
            return Definitions.map(function(d2) {
              return register2(d2);
            });
          }
          var Definition = Definitions[0];
          if (typeof Definition.blotName !== "string" && typeof Definition.attrName !== "string") {
            throw new ParchmentError("Invalid definition");
          } else if (Definition.blotName === "abstract") {
            throw new ParchmentError("Cannot register abstract class");
          }
          types2[Definition.blotName || Definition.attrName] = Definition;
          if (typeof Definition.keyName === "string") {
            attributes[Definition.keyName] = Definition;
          } else {
            if (Definition.className != null) {
              classes[Definition.className] = Definition;
            }
            if (Definition.tagName != null) {
              if (Array.isArray(Definition.tagName)) {
                Definition.tagName = Definition.tagName.map(function(tagName) {
                  return tagName.toUpperCase();
                });
              } else {
                Definition.tagName = Definition.tagName.toUpperCase();
              }
              var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
              tagNames.forEach(function(tag) {
                if (tags2[tag] == null || Definition.className == null) {
                  tags2[tag] = Definition;
                }
              });
            }
          }
          return Definition;
        }
        exports2.register = register2;
      },
      function(module2, exports2, __webpack_require__) {
        var diff = __webpack_require__(51);
        var equal = __webpack_require__(11);
        var extend2 = __webpack_require__(3);
        var op = __webpack_require__(20);
        var NULL_CHARACTER = String.fromCharCode(0);
        var Delta = function(ops) {
          if (Array.isArray(ops)) {
            this.ops = ops;
          } else if (ops != null && Array.isArray(ops.ops)) {
            this.ops = ops.ops;
          } else {
            this.ops = [];
          }
        };
        Delta.prototype.insert = function(text, attributes) {
          var newOp = {};
          if (text.length === 0)
            return this;
          newOp.insert = text;
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        };
        Delta.prototype["delete"] = function(length) {
          if (length <= 0)
            return this;
          return this.push({ "delete": length });
        };
        Delta.prototype.retain = function(length, attributes) {
          if (length <= 0)
            return this;
          var newOp = { retain: length };
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        };
        Delta.prototype.push = function(newOp) {
          var index2 = this.ops.length;
          var lastOp = this.ops[index2 - 1];
          newOp = extend2(true, {}, newOp);
          if (typeof lastOp === "object") {
            if (typeof newOp["delete"] === "number" && typeof lastOp["delete"] === "number") {
              this.ops[index2 - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
              return this;
            }
            if (typeof lastOp["delete"] === "number" && newOp.insert != null) {
              index2 -= 1;
              lastOp = this.ops[index2 - 1];
              if (typeof lastOp !== "object") {
                this.ops.unshift(newOp);
                return this;
              }
            }
            if (equal(newOp.attributes, lastOp.attributes)) {
              if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                this.ops[index2 - 1] = { insert: lastOp.insert + newOp.insert };
                if (typeof newOp.attributes === "object")
                  this.ops[index2 - 1].attributes = newOp.attributes;
                return this;
              } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                this.ops[index2 - 1] = { retain: lastOp.retain + newOp.retain };
                if (typeof newOp.attributes === "object")
                  this.ops[index2 - 1].attributes = newOp.attributes;
                return this;
              }
            }
          }
          if (index2 === this.ops.length) {
            this.ops.push(newOp);
          } else {
            this.ops.splice(index2, 0, newOp);
          }
          return this;
        };
        Delta.prototype.chop = function() {
          var lastOp = this.ops[this.ops.length - 1];
          if (lastOp && lastOp.retain && !lastOp.attributes) {
            this.ops.pop();
          }
          return this;
        };
        Delta.prototype.filter = function(predicate) {
          return this.ops.filter(predicate);
        };
        Delta.prototype.forEach = function(predicate) {
          this.ops.forEach(predicate);
        };
        Delta.prototype.map = function(predicate) {
          return this.ops.map(predicate);
        };
        Delta.prototype.partition = function(predicate) {
          var passed = [], failed = [];
          this.forEach(function(op2) {
            var target = predicate(op2) ? passed : failed;
            target.push(op2);
          });
          return [passed, failed];
        };
        Delta.prototype.reduce = function(predicate, initial) {
          return this.ops.reduce(predicate, initial);
        };
        Delta.prototype.changeLength = function() {
          return this.reduce(function(length, elem) {
            if (elem.insert) {
              return length + op.length(elem);
            } else if (elem.delete) {
              return length - elem.delete;
            }
            return length;
          }, 0);
        };
        Delta.prototype.length = function() {
          return this.reduce(function(length, elem) {
            return length + op.length(elem);
          }, 0);
        };
        Delta.prototype.slice = function(start2, end2) {
          start2 = start2 || 0;
          if (typeof end2 !== "number")
            end2 = Infinity;
          var ops = [];
          var iter = op.iterator(this.ops);
          var index2 = 0;
          while (index2 < end2 && iter.hasNext()) {
            var nextOp;
            if (index2 < start2) {
              nextOp = iter.next(start2 - index2);
            } else {
              nextOp = iter.next(end2 - index2);
              ops.push(nextOp);
            }
            index2 += op.length(nextOp);
          }
          return new Delta(ops);
        };
        Delta.prototype.compose = function(other) {
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var ops = [];
          var firstOther = otherIter.peek();
          if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
            var firstLeft = firstOther.retain;
            while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
              firstLeft -= thisIter.peekLength();
              ops.push(thisIter.next());
            }
            if (firstOther.retain - firstLeft > 0) {
              otherIter.next(firstOther.retain - firstLeft);
            }
          }
          var delta = new Delta(ops);
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else if (thisIter.peekType() === "delete") {
              delta.push(thisIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);
              if (typeof otherOp.retain === "number") {
                var newOp = {};
                if (typeof thisOp.retain === "number") {
                  newOp.retain = length;
                } else {
                  newOp.insert = thisOp.insert;
                }
                var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                if (attributes)
                  newOp.attributes = attributes;
                delta.push(newOp);
                if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
                  var rest = new Delta(thisIter.rest());
                  return delta.concat(rest).chop();
                }
              } else if (typeof otherOp["delete"] === "number" && typeof thisOp.retain === "number") {
                delta.push(otherOp);
              }
            }
          }
          return delta.chop();
        };
        Delta.prototype.concat = function(other) {
          var delta = new Delta(this.ops.slice());
          if (other.ops.length > 0) {
            delta.push(other.ops[0]);
            delta.ops = delta.ops.concat(other.ops.slice(1));
          }
          return delta;
        };
        Delta.prototype.diff = function(other, index2) {
          if (this.ops === other.ops) {
            return new Delta();
          }
          var strings = [this, other].map(function(delta2) {
            return delta2.map(function(op2) {
              if (op2.insert != null) {
                return typeof op2.insert === "string" ? op2.insert : NULL_CHARACTER;
              }
              var prep = delta2 === other ? "on" : "with";
              throw new Error("diff() called " + prep + " non-document");
            }).join("");
          });
          var delta = new Delta();
          var diffResult = diff(strings[0], strings[1], index2);
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          diffResult.forEach(function(component) {
            var length = component[1].length;
            while (length > 0) {
              var opLength = 0;
              switch (component[0]) {
                case diff.INSERT:
                  opLength = Math.min(otherIter.peekLength(), length);
                  delta.push(otherIter.next(opLength));
                  break;
                case diff.DELETE:
                  opLength = Math.min(length, thisIter.peekLength());
                  thisIter.next(opLength);
                  delta["delete"](opLength);
                  break;
                case diff.EQUAL:
                  opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                  var thisOp = thisIter.next(opLength);
                  var otherOp = otherIter.next(opLength);
                  if (equal(thisOp.insert, otherOp.insert)) {
                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
                  } else {
                    delta.push(otherOp)["delete"](opLength);
                  }
                  break;
              }
              length -= opLength;
            }
          });
          return delta.chop();
        };
        Delta.prototype.eachLine = function(predicate, newline) {
          newline = newline || "\n";
          var iter = op.iterator(this.ops);
          var line = new Delta();
          var i = 0;
          while (iter.hasNext()) {
            if (iter.peekType() !== "insert")
              return;
            var thisOp = iter.peek();
            var start2 = op.length(thisOp) - iter.peekLength();
            var index2 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start2) - start2 : -1;
            if (index2 < 0) {
              line.push(iter.next());
            } else if (index2 > 0) {
              line.push(iter.next(index2));
            } else {
              if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                return;
              }
              i += 1;
              line = new Delta();
            }
          }
          if (line.length() > 0) {
            predicate(line, {}, i);
          }
        };
        Delta.prototype.transform = function(other, priority) {
          priority = !!priority;
          if (typeof other === "number") {
            return this.transformPosition(other, priority);
          }
          var thisIter = op.iterator(this.ops);
          var otherIter = op.iterator(other.ops);
          var delta = new Delta();
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
              delta.retain(op.length(thisIter.next()));
            } else if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else {
              var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              var thisOp = thisIter.next(length);
              var otherOp = otherIter.next(length);
              if (thisOp["delete"]) {
                continue;
              } else if (otherOp["delete"]) {
                delta.push(otherOp);
              } else {
                delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
              }
            }
          }
          return delta.chop();
        };
        Delta.prototype.transformPosition = function(index2, priority) {
          priority = !!priority;
          var thisIter = op.iterator(this.ops);
          var offset2 = 0;
          while (thisIter.hasNext() && offset2 <= index2) {
            var length = thisIter.peekLength();
            var nextType = thisIter.peekType();
            thisIter.next();
            if (nextType === "delete") {
              index2 -= Math.min(length, index2 - offset2);
              continue;
            } else if (nextType === "insert" && (offset2 < index2 || !priority)) {
              index2 += length;
            }
            offset2 += length;
          }
          return index2;
        };
        module2.exports = Delta;
      },
      function(module2, exports2) {
        var hasOwn2 = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var defineProperty2 = Object.defineProperty;
        var gOPD = Object.getOwnPropertyDescriptor;
        var isArray2 = function isArray3(arr) {
          if (typeof Array.isArray === "function") {
            return Array.isArray(arr);
          }
          return toStr.call(arr) === "[object Array]";
        };
        var isPlainObject = function isPlainObject2(obj) {
          if (!obj || toStr.call(obj) !== "[object Object]") {
            return false;
          }
          var hasOwnConstructor = hasOwn2.call(obj, "constructor");
          var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
          if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
            return false;
          }
          var key2;
          for (key2 in obj) {
          }
          return typeof key2 === "undefined" || hasOwn2.call(obj, key2);
        };
        var setProperty = function setProperty2(target, options2) {
          if (defineProperty2 && options2.name === "__proto__") {
            defineProperty2(target, options2.name, {
              enumerable: true,
              configurable: true,
              value: options2.newValue,
              writable: true
            });
          } else {
            target[options2.name] = options2.newValue;
          }
        };
        var getProperty = function getProperty2(obj, name) {
          if (name === "__proto__") {
            if (!hasOwn2.call(obj, name)) {
              return void 0;
            } else if (gOPD) {
              return gOPD(obj, name).value;
            }
          }
          return obj[name];
        };
        module2.exports = function extend2() {
          var options2, name, src, copy2, copyIsArray, clone2;
          var target = arguments[0];
          var i = 1;
          var length = arguments.length;
          var deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i = 2;
          }
          if (target == null || typeof target !== "object" && typeof target !== "function") {
            target = {};
          }
          for (; i < length; ++i) {
            options2 = arguments[i];
            if (options2 != null) {
              for (name in options2) {
                src = getProperty(target, name);
                copy2 = getProperty(options2, name);
                if (target !== copy2) {
                  if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray2(copy2)))) {
                    if (copyIsArray) {
                      copyIsArray = false;
                      clone2 = src && isArray2(src) ? src : [];
                    } else {
                      clone2 = src && isPlainObject(src) ? src : {};
                    }
                    setProperty(target, { name, newValue: extend2(deep, clone2, copy2) });
                  } else if (typeof copy2 !== "undefined") {
                    setProperty(target, { name, newValue: copy2 });
                  }
                }
              }
            }
          }
          return target;
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.BlockEmbed = exports2.bubbleFormats = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _break = __webpack_require__(16);
        var _break2 = _interopRequireDefault(_break);
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var NEWLINE_LENGTH = 1;
        var BlockEmbed = function(_Parchment$Embed) {
          _inherits(BlockEmbed2, _Parchment$Embed);
          function BlockEmbed2() {
            _classCallCheck(this, BlockEmbed2);
            return _possibleConstructorReturn(this, (BlockEmbed2.__proto__ || Object.getPrototypeOf(BlockEmbed2)).apply(this, arguments));
          }
          _createClass(BlockEmbed2, [{
            key: "attach",
            value: function attach() {
              _get(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "attach", this).call(this);
              this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
            }
          }, {
            key: "delta",
            value: function delta() {
              return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
            }
          }, {
            key: "format",
            value: function format2(name, value) {
              var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
              if (attribute != null) {
                this.attributes.attribute(attribute, value);
              }
            }
          }, {
            key: "formatAt",
            value: function formatAt(index2, length, name, value) {
              this.format(name, value);
            }
          }, {
            key: "insertAt",
            value: function insertAt(index2, value, def) {
              if (typeof value === "string" && value.endsWith("\n")) {
                var block = _parchment2.default.create(Block.blotName);
                this.parent.insertBefore(block, index2 === 0 ? this : this.next);
                block.insertAt(0, value.slice(0, -1));
              } else {
                _get(BlockEmbed2.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed2.prototype), "insertAt", this).call(this, index2, value, def);
              }
            }
          }]);
          return BlockEmbed2;
        }(_parchment2.default.Embed);
        BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
        var Block = function(_Parchment$Block) {
          _inherits(Block2, _Parchment$Block);
          function Block2(domNode) {
            _classCallCheck(this, Block2);
            var _this2 = _possibleConstructorReturn(this, (Block2.__proto__ || Object.getPrototypeOf(Block2)).call(this, domNode));
            _this2.cache = {};
            return _this2;
          }
          _createClass(Block2, [{
            key: "delta",
            value: function delta() {
              if (this.cache.delta == null) {
                this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta2, leaf) {
                  if (leaf.length() === 0) {
                    return delta2;
                  } else {
                    return delta2.insert(leaf.value(), bubbleFormats(leaf));
                  }
                }, new _quillDelta2.default()).insert("\n", bubbleFormats(this));
              }
              return this.cache.delta;
            }
          }, {
            key: "deleteAt",
            value: function deleteAt(index2, length) {
              _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "deleteAt", this).call(this, index2, length);
              this.cache = {};
            }
          }, {
            key: "formatAt",
            value: function formatAt(index2, length, name, value) {
              if (length <= 0)
                return;
              if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                if (index2 + length === this.length()) {
                  this.format(name, value);
                }
              } else {
                _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "formatAt", this).call(this, index2, Math.min(length, this.length() - index2 - 1), name, value);
              }
              this.cache = {};
            }
          }, {
            key: "insertAt",
            value: function insertAt(index2, value, def) {
              if (def != null)
                return _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertAt", this).call(this, index2, value, def);
              if (value.length === 0)
                return;
              var lines = value.split("\n");
              var text = lines.shift();
              if (text.length > 0) {
                if (index2 < this.length() - 1 || this.children.tail == null) {
                  _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertAt", this).call(this, Math.min(index2, this.length() - 1), text);
                } else {
                  this.children.tail.insertAt(this.children.tail.length(), text);
                }
                this.cache = {};
              }
              var block = this;
              lines.reduce(function(index3, line) {
                block = block.split(index3, true);
                block.insertAt(0, line);
                return line.length;
              }, index2 + text.length);
            }
          }, {
            key: "insertBefore",
            value: function insertBefore(blot, ref2) {
              var head = this.children.head;
              _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "insertBefore", this).call(this, blot, ref2);
              if (head instanceof _break2.default) {
                head.remove();
              }
              this.cache = {};
            }
          }, {
            key: "length",
            value: function length() {
              if (this.cache.length == null) {
                this.cache.length = _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "length", this).call(this) + NEWLINE_LENGTH;
              }
              return this.cache.length;
            }
          }, {
            key: "moveChildren",
            value: function moveChildren(target, ref2) {
              _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "moveChildren", this).call(this, target, ref2);
              this.cache = {};
            }
          }, {
            key: "optimize",
            value: function optimize(context) {
              _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "optimize", this).call(this, context);
              this.cache = {};
            }
          }, {
            key: "path",
            value: function path(index2) {
              return _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "path", this).call(this, index2, true);
            }
          }, {
            key: "removeChild",
            value: function removeChild(child) {
              _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "removeChild", this).call(this, child);
              this.cache = {};
            }
          }, {
            key: "split",
            value: function split(index2) {
              var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (force && (index2 === 0 || index2 >= this.length() - NEWLINE_LENGTH)) {
                var clone2 = this.clone();
                if (index2 === 0) {
                  this.parent.insertBefore(clone2, this);
                  return this;
                } else {
                  this.parent.insertBefore(clone2, this.next);
                  return clone2;
                }
              } else {
                var next = _get(Block2.prototype.__proto__ || Object.getPrototypeOf(Block2.prototype), "split", this).call(this, index2, force);
                this.cache = {};
                return next;
              }
            }
          }]);
          return Block2;
        }(_parchment2.default.Block);
        Block.blotName = "block";
        Block.tagName = "P";
        Block.defaultChild = "break";
        Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];
        function bubbleFormats(blot) {
          var formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (blot == null)
            return formats;
          if (typeof blot.formats === "function") {
            formats = (0, _extend2.default)(formats, blot.formats());
          }
          if (blot.parent == null || blot.parent.blotName == "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
            return formats;
          }
          return bubbleFormats(blot.parent, formats);
        }
        exports2.bubbleFormats = bubbleFormats;
        exports2.BlockEmbed = BlockEmbed;
        exports2.default = Block;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.overload = exports2.expandConfig = void 0;
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        __webpack_require__(50);
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _editor = __webpack_require__(14);
        var _editor2 = _interopRequireDefault(_editor);
        var _emitter3 = __webpack_require__(8);
        var _emitter4 = _interopRequireDefault(_emitter3);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _selection = __webpack_require__(15);
        var _selection2 = _interopRequireDefault(_selection);
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        var _theme = __webpack_require__(34);
        var _theme2 = _interopRequireDefault(_theme);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var debug = (0, _logger2.default)("quill");
        var Quill2 = function() {
          _createClass(Quill3, null, [{
            key: "debug",
            value: function debug2(limit2) {
              if (limit2 === true) {
                limit2 = "log";
              }
              _logger2.default.level(limit2);
            }
          }, {
            key: "find",
            value: function find2(node) {
              return node.__quill || _parchment2.default.find(node);
            }
          }, {
            key: "import",
            value: function _import(name) {
              if (this.imports[name] == null) {
                debug.error("Cannot import " + name + ". Are you sure it was registered?");
              }
              return this.imports[name];
            }
          }, {
            key: "register",
            value: function register2(path, target) {
              var _this = this;
              var overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (typeof path !== "string") {
                var name = path.attrName || path.blotName;
                if (typeof name === "string") {
                  this.register("formats/" + name, path, target);
                } else {
                  Object.keys(path).forEach(function(key2) {
                    _this.register(key2, path[key2], target);
                  });
                }
              } else {
                if (this.imports[path] != null && !overwrite) {
                  debug.warn("Overwriting " + path + " with", target);
                }
                this.imports[path] = target;
                if ((path.startsWith("blots/") || path.startsWith("formats/")) && target.blotName !== "abstract") {
                  _parchment2.default.register(target);
                } else if (path.startsWith("modules") && typeof target.register === "function") {
                  target.register();
                }
              }
            }
          }]);
          function Quill3(container) {
            var _this2 = this;
            var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck(this, Quill3);
            this.options = expandConfig(container, options2);
            this.container = this.options.container;
            if (this.container == null) {
              return debug.error("Invalid Quill container", container);
            }
            if (this.options.debug) {
              Quill3.debug(this.options.debug);
            }
            var html = this.container.innerHTML.trim();
            this.container.classList.add("ql-container");
            this.container.innerHTML = "";
            this.container.__quill = this;
            this.root = this.addContainer("ql-editor");
            this.root.classList.add("ql-blank");
            this.root.setAttribute("data-gramm", false);
            this.scrollingContainer = this.options.scrollingContainer || this.root;
            this.emitter = new _emitter4.default();
            this.scroll = _parchment2.default.create(this.root, {
              emitter: this.emitter,
              whitelist: this.options.formats
            });
            this.editor = new _editor2.default(this.scroll);
            this.selection = new _selection2.default(this.scroll, this.emitter);
            this.theme = new this.options.theme(this, this.options);
            this.keyboard = this.theme.addModule("keyboard");
            this.clipboard = this.theme.addModule("clipboard");
            this.history = this.theme.addModule("history");
            this.theme.init();
            this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type4) {
              if (type4 === _emitter4.default.events.TEXT_CHANGE) {
                _this2.root.classList.toggle("ql-blank", _this2.editor.isBlank());
              }
            });
            this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {
              var range3 = _this2.selection.lastRange;
              var index2 = range3 && range3.length === 0 ? range3.index : void 0;
              modify.call(_this2, function() {
                return _this2.editor.update(null, mutations, index2);
              }, source);
            });
            var contents = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">` + html + "<p><br></p></div>");
            this.setContents(contents);
            this.history.clear();
            if (this.options.placeholder) {
              this.root.setAttribute("data-placeholder", this.options.placeholder);
            }
            if (this.options.readOnly) {
              this.disable();
            }
          }
          _createClass(Quill3, [{
            key: "addContainer",
            value: function addContainer(container) {
              var refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (typeof container === "string") {
                var className = container;
                container = document.createElement("div");
                container.classList.add(className);
              }
              this.container.insertBefore(container, refNode);
              return container;
            }
          }, {
            key: "blur",
            value: function blur() {
              this.selection.setRange(null);
            }
          }, {
            key: "deleteText",
            value: function deleteText(index2, length, source) {
              var _this3 = this;
              var _overload = overload(index2, length, source);
              var _overload2 = _slicedToArray(_overload, 4);
              index2 = _overload2[0];
              length = _overload2[1];
              source = _overload2[3];
              return modify.call(this, function() {
                return _this3.editor.deleteText(index2, length);
              }, source, index2, -1 * length);
            }
          }, {
            key: "disable",
            value: function disable() {
              this.enable(false);
            }
          }, {
            key: "enable",
            value: function enable() {
              var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              this.scroll.enable(enabled);
              this.container.classList.toggle("ql-disabled", !enabled);
            }
          }, {
            key: "focus",
            value: function focus() {
              var scrollTop = this.scrollingContainer.scrollTop;
              this.selection.focus();
              this.scrollingContainer.scrollTop = scrollTop;
              this.scrollIntoView();
            }
          }, {
            key: "format",
            value: function format2(name, value) {
              var _this4 = this;
              var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
              return modify.call(this, function() {
                var range3 = _this4.getSelection(true);
                var change = new _quillDelta2.default();
                if (range3 == null) {
                  return change;
                } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
                  change = _this4.editor.formatLine(range3.index, range3.length, _defineProperty2({}, name, value));
                } else if (range3.length === 0) {
                  _this4.selection.format(name, value);
                  return change;
                } else {
                  change = _this4.editor.formatText(range3.index, range3.length, _defineProperty2({}, name, value));
                }
                _this4.setSelection(range3, _emitter4.default.sources.SILENT);
                return change;
              }, source);
            }
          }, {
            key: "formatLine",
            value: function formatLine(index2, length, name, value, source) {
              var _this5 = this;
              var formats = void 0;
              var _overload3 = overload(index2, length, name, value, source);
              var _overload4 = _slicedToArray(_overload3, 4);
              index2 = _overload4[0];
              length = _overload4[1];
              formats = _overload4[2];
              source = _overload4[3];
              return modify.call(this, function() {
                return _this5.editor.formatLine(index2, length, formats);
              }, source, index2, 0);
            }
          }, {
            key: "formatText",
            value: function formatText(index2, length, name, value, source) {
              var _this6 = this;
              var formats = void 0;
              var _overload5 = overload(index2, length, name, value, source);
              var _overload6 = _slicedToArray(_overload5, 4);
              index2 = _overload6[0];
              length = _overload6[1];
              formats = _overload6[2];
              source = _overload6[3];
              return modify.call(this, function() {
                return _this6.editor.formatText(index2, length, formats);
              }, source, index2, 0);
            }
          }, {
            key: "getBounds",
            value: function getBounds(index2) {
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var bounds = void 0;
              if (typeof index2 === "number") {
                bounds = this.selection.getBounds(index2, length);
              } else {
                bounds = this.selection.getBounds(index2.index, index2.length);
              }
              var containerBounds = this.container.getBoundingClientRect();
              return {
                bottom: bounds.bottom - containerBounds.top,
                height: bounds.height,
                left: bounds.left - containerBounds.left,
                right: bounds.right - containerBounds.left,
                top: bounds.top - containerBounds.top,
                width: bounds.width
              };
            }
          }, {
            key: "getContents",
            value: function getContents() {
              var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
              var _overload7 = overload(index2, length);
              var _overload8 = _slicedToArray(_overload7, 2);
              index2 = _overload8[0];
              length = _overload8[1];
              return this.editor.getContents(index2, length);
            }
          }, {
            key: "getFormat",
            value: function getFormat() {
              var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              if (typeof index2 === "number") {
                return this.editor.getFormat(index2, length);
              } else {
                return this.editor.getFormat(index2.index, index2.length);
              }
            }
          }, {
            key: "getIndex",
            value: function getIndex(blot) {
              return blot.offset(this.scroll);
            }
          }, {
            key: "getLength",
            value: function getLength() {
              return this.scroll.length();
            }
          }, {
            key: "getLeaf",
            value: function getLeaf(index2) {
              return this.scroll.leaf(index2);
            }
          }, {
            key: "getLine",
            value: function getLine(index2) {
              return this.scroll.line(index2);
            }
          }, {
            key: "getLines",
            value: function getLines() {
              var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
              if (typeof index2 !== "number") {
                return this.scroll.lines(index2.index, index2.length);
              } else {
                return this.scroll.lines(index2, length);
              }
            }
          }, {
            key: "getModule",
            value: function getModule(name) {
              return this.theme.modules[name];
            }
          }, {
            key: "getSelection",
            value: function getSelection() {
              var focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              if (focus)
                this.focus();
              this.update();
              return this.selection.getRange()[0];
            }
          }, {
            key: "getText",
            value: function getText() {
              var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
              var _overload9 = overload(index2, length);
              var _overload10 = _slicedToArray(_overload9, 2);
              index2 = _overload10[0];
              length = _overload10[1];
              return this.editor.getText(index2, length);
            }
          }, {
            key: "hasFocus",
            value: function hasFocus() {
              return this.selection.hasFocus();
            }
          }, {
            key: "insertEmbed",
            value: function insertEmbed(index2, embed, value) {
              var _this7 = this;
              var source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Quill3.sources.API;
              return modify.call(this, function() {
                return _this7.editor.insertEmbed(index2, embed, value);
              }, source, index2);
            }
          }, {
            key: "insertText",
            value: function insertText(index2, text, name, value, source) {
              var _this8 = this;
              var formats = void 0;
              var _overload11 = overload(index2, 0, name, value, source);
              var _overload12 = _slicedToArray(_overload11, 4);
              index2 = _overload12[0];
              formats = _overload12[2];
              source = _overload12[3];
              return modify.call(this, function() {
                return _this8.editor.insertText(index2, text, formats);
              }, source, index2, text.length);
            }
          }, {
            key: "isEnabled",
            value: function isEnabled() {
              return !this.container.classList.contains("ql-disabled");
            }
          }, {
            key: "off",
            value: function off2() {
              return this.emitter.off.apply(this.emitter, arguments);
            }
          }, {
            key: "on",
            value: function on2() {
              return this.emitter.on.apply(this.emitter, arguments);
            }
          }, {
            key: "once",
            value: function once2() {
              return this.emitter.once.apply(this.emitter, arguments);
            }
          }, {
            key: "pasteHTML",
            value: function pasteHTML(index2, html, source) {
              this.clipboard.dangerouslyPasteHTML(index2, html, source);
            }
          }, {
            key: "removeFormat",
            value: function removeFormat(index2, length, source) {
              var _this9 = this;
              var _overload13 = overload(index2, length, source);
              var _overload14 = _slicedToArray(_overload13, 4);
              index2 = _overload14[0];
              length = _overload14[1];
              source = _overload14[3];
              return modify.call(this, function() {
                return _this9.editor.removeFormat(index2, length);
              }, source, index2);
            }
          }, {
            key: "scrollIntoView",
            value: function scrollIntoView2() {
              this.selection.scrollIntoView(this.scrollingContainer);
            }
          }, {
            key: "setContents",
            value: function setContents(delta) {
              var _this10 = this;
              var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
              return modify.call(this, function() {
                delta = new _quillDelta2.default(delta);
                var length = _this10.getLength();
                var deleted = _this10.editor.deleteText(0, length);
                var applied = _this10.editor.applyDelta(delta);
                var lastOp = applied.ops[applied.ops.length - 1];
                if (lastOp != null && typeof lastOp.insert === "string" && lastOp.insert[lastOp.insert.length - 1] === "\n") {
                  _this10.editor.deleteText(_this10.getLength() - 1, 1);
                  applied.delete(1);
                }
                var ret = deleted.compose(applied);
                return ret;
              }, source);
            }
          }, {
            key: "setSelection",
            value: function setSelection(index2, length, source) {
              if (index2 == null) {
                this.selection.setRange(null, length || Quill3.sources.API);
              } else {
                var _overload15 = overload(index2, length, source);
                var _overload16 = _slicedToArray(_overload15, 4);
                index2 = _overload16[0];
                length = _overload16[1];
                source = _overload16[3];
                this.selection.setRange(new _selection.Range(index2, length), source);
                if (source !== _emitter4.default.sources.SILENT) {
                  this.selection.scrollIntoView(this.scrollingContainer);
                }
              }
            }
          }, {
            key: "setText",
            value: function setText(text) {
              var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
              var delta = new _quillDelta2.default().insert(text);
              return this.setContents(delta, source);
            }
          }, {
            key: "update",
            value: function update() {
              var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
              var change = this.scroll.update(source);
              this.selection.update(source);
              return change;
            }
          }, {
            key: "updateContents",
            value: function updateContents(delta) {
              var _this11 = this;
              var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _emitter4.default.sources.API;
              return modify.call(this, function() {
                delta = new _quillDelta2.default(delta);
                return _this11.editor.applyDelta(delta, source);
              }, source, true);
            }
          }]);
          return Quill3;
        }();
        Quill2.DEFAULTS = {
          bounds: null,
          formats: null,
          modules: {},
          placeholder: "",
          readOnly: false,
          scrollingContainer: null,
          strict: true,
          theme: "default"
        };
        Quill2.events = _emitter4.default.events;
        Quill2.sources = _emitter4.default.sources;
        Quill2.version = "1.3.7";
        Quill2.imports = {
          "delta": _quillDelta2.default,
          "parchment": _parchment2.default,
          "core/module": _module2.default,
          "core/theme": _theme2.default
        };
        function expandConfig(container, userConfig) {
          userConfig = (0, _extend2.default)(true, {
            container,
            modules: {
              clipboard: true,
              keyboard: true,
              history: true
            }
          }, userConfig);
          if (!userConfig.theme || userConfig.theme === Quill2.DEFAULTS.theme) {
            userConfig.theme = _theme2.default;
          } else {
            userConfig.theme = Quill2.import("themes/" + userConfig.theme);
            if (userConfig.theme == null) {
              throw new Error("Invalid theme " + userConfig.theme + ". Did you register it?");
            }
          }
          var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
          [themeConfig, userConfig].forEach(function(config) {
            config.modules = config.modules || {};
            Object.keys(config.modules).forEach(function(module3) {
              if (config.modules[module3] === true) {
                config.modules[module3] = {};
              }
            });
          });
          var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
          var moduleConfig = moduleNames.reduce(function(config, name) {
            var moduleClass = Quill2.import("modules/" + name);
            if (moduleClass == null) {
              debug.error("Cannot load " + name + " module. Are you sure you registered it?");
            } else {
              config[name] = moduleClass.DEFAULTS || {};
            }
            return config;
          }, {});
          if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
            userConfig.modules.toolbar = {
              container: userConfig.modules.toolbar
            };
          }
          userConfig = (0, _extend2.default)(true, {}, Quill2.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
          ["bounds", "container", "scrollingContainer"].forEach(function(key2) {
            if (typeof userConfig[key2] === "string") {
              userConfig[key2] = document.querySelector(userConfig[key2]);
            }
          });
          userConfig.modules = Object.keys(userConfig.modules).reduce(function(config, name) {
            if (userConfig.modules[name]) {
              config[name] = userConfig.modules[name];
            }
            return config;
          }, {});
          return userConfig;
        }
        function modify(modifier, source, index2, shift) {
          if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
            return new _quillDelta2.default();
          }
          var range3 = index2 == null ? null : this.getSelection();
          var oldDelta = this.editor.delta;
          var change = modifier();
          if (range3 != null) {
            if (index2 === true)
              index2 = range3.index;
            if (shift == null) {
              range3 = shiftRange(range3, change, source);
            } else if (shift !== 0) {
              range3 = shiftRange(range3, index2, shift, source);
            }
            this.setSelection(range3, _emitter4.default.sources.SILENT);
          }
          if (change.length() > 0) {
            var _emitter;
            var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
            (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
            if (source !== _emitter4.default.sources.SILENT) {
              var _emitter2;
              (_emitter2 = this.emitter).emit.apply(_emitter2, args);
            }
          }
          return change;
        }
        function overload(index2, length, name, value, source) {
          var formats = {};
          if (typeof index2.index === "number" && typeof index2.length === "number") {
            if (typeof length !== "number") {
              source = value, value = name, name = length, length = index2.length, index2 = index2.index;
            } else {
              length = index2.length, index2 = index2.index;
            }
          } else if (typeof length !== "number") {
            source = value, value = name, name = length, length = 0;
          }
          if ((typeof name === "undefined" ? "undefined" : _typeof2(name)) === "object") {
            formats = name;
            source = value;
          } else if (typeof name === "string") {
            if (value != null) {
              formats[name] = value;
            } else {
              source = name;
            }
          }
          source = source || _emitter4.default.sources.API;
          return [index2, length, formats, source];
        }
        function shiftRange(range3, index2, length, source) {
          if (range3 == null)
            return null;
          var start2 = void 0, end2 = void 0;
          if (index2 instanceof _quillDelta2.default) {
            var _map = [range3.index, range3.index + range3.length].map(function(pos) {
              return index2.transformPosition(pos, source !== _emitter4.default.sources.USER);
            });
            var _map2 = _slicedToArray(_map, 2);
            start2 = _map2[0];
            end2 = _map2[1];
          } else {
            var _map3 = [range3.index, range3.index + range3.length].map(function(pos) {
              if (pos < index2 || pos === index2 && source === _emitter4.default.sources.USER)
                return pos;
              if (length >= 0) {
                return pos + length;
              } else {
                return Math.max(index2, pos + length);
              }
            });
            var _map4 = _slicedToArray(_map3, 2);
            start2 = _map4[0];
            end2 = _map4[1];
          }
          return new _selection.Range(start2, end2 - start2);
        }
        exports2.expandConfig = expandConfig;
        exports2.overload = overload;
        exports2.default = Quill2;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Inline = function(_Parchment$Inline) {
          _inherits(Inline2, _Parchment$Inline);
          function Inline2() {
            _classCallCheck(this, Inline2);
            return _possibleConstructorReturn(this, (Inline2.__proto__ || Object.getPrototypeOf(Inline2)).apply(this, arguments));
          }
          _createClass(Inline2, [{
            key: "formatAt",
            value: function formatAt(index2, length, name, value) {
              if (Inline2.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
                var blot = this.isolate(index2, length);
                if (value) {
                  blot.wrap(name, value);
                }
              } else {
                _get(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "formatAt", this).call(this, index2, length, name, value);
              }
            }
          }, {
            key: "optimize",
            value: function optimize(context) {
              _get(Inline2.prototype.__proto__ || Object.getPrototypeOf(Inline2.prototype), "optimize", this).call(this, context);
              if (this.parent instanceof Inline2 && Inline2.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                var parent = this.parent.isolate(this.offset(), this.length());
                this.moveChildren(parent);
                parent.wrap(this);
              }
            }
          }], [{
            key: "compare",
            value: function compare(self2, other) {
              var selfIndex = Inline2.order.indexOf(self2);
              var otherIndex = Inline2.order.indexOf(other);
              if (selfIndex >= 0 || otherIndex >= 0) {
                return selfIndex - otherIndex;
              } else if (self2 === other) {
                return 0;
              } else if (self2 < other) {
                return -1;
              } else {
                return 1;
              }
            }
          }]);
          return Inline2;
        }(_parchment2.default.Inline);
        Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
        Inline.order = [
          "cursor",
          "inline",
          "underline",
          "strike",
          "italic",
          "bold",
          "script",
          "link",
          "code"
        ];
        exports2.default = Inline;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var TextBlot = function(_Parchment$Text) {
          _inherits(TextBlot2, _Parchment$Text);
          function TextBlot2() {
            _classCallCheck(this, TextBlot2);
            return _possibleConstructorReturn(this, (TextBlot2.__proto__ || Object.getPrototypeOf(TextBlot2)).apply(this, arguments));
          }
          return TextBlot2;
        }(_parchment2.default.Text);
        exports2.default = TextBlot;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _eventemitter = __webpack_require__(54);
        var _eventemitter2 = _interopRequireDefault(_eventemitter);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var debug = (0, _logger2.default)("quill:events");
        var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
        EVENTS.forEach(function(eventName) {
          document.addEventListener(eventName, function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(node) {
              if (node.__quill && node.__quill.emitter) {
                var _node$__quill$emitter;
                (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
              }
            });
          });
        });
        var Emitter = function(_EventEmitter) {
          _inherits(Emitter2, _EventEmitter);
          function Emitter2() {
            _classCallCheck(this, Emitter2);
            var _this = _possibleConstructorReturn(this, (Emitter2.__proto__ || Object.getPrototypeOf(Emitter2)).call(this));
            _this.listeners = {};
            _this.on("error", debug.error);
            return _this;
          }
          _createClass(Emitter2, [{
            key: "emit",
            value: function emit2() {
              debug.log.apply(debug, arguments);
              _get(Emitter2.prototype.__proto__ || Object.getPrototypeOf(Emitter2.prototype), "emit", this).apply(this, arguments);
            }
          }, {
            key: "handleDOM",
            value: function handleDOM(event) {
              for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              (this.listeners[event.type] || []).forEach(function(_ref) {
                var node = _ref.node, handler = _ref.handler;
                if (event.target === node || node.contains(event.target)) {
                  handler.apply(void 0, [event].concat(args));
                }
              });
            }
          }, {
            key: "listenDOM",
            value: function listenDOM(eventName, node, handler) {
              if (!this.listeners[eventName]) {
                this.listeners[eventName] = [];
              }
              this.listeners[eventName].push({ node, handler });
            }
          }]);
          return Emitter2;
        }(_eventemitter2.default);
        Emitter.events = {
          EDITOR_CHANGE: "editor-change",
          SCROLL_BEFORE_UPDATE: "scroll-before-update",
          SCROLL_OPTIMIZE: "scroll-optimize",
          SCROLL_UPDATE: "scroll-update",
          SELECTION_CHANGE: "selection-change",
          TEXT_CHANGE: "text-change"
        };
        Emitter.sources = {
          API: "api",
          SILENT: "silent",
          USER: "user"
        };
        exports2.default = Emitter;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Module = function Module2(quill2) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          _classCallCheck(this, Module2);
          this.quill = quill2;
          this.options = options2;
        };
        Module.DEFAULTS = {};
        exports2.default = Module;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var levels = ["error", "warn", "log", "info"];
        var level = "warn";
        function debug(method4) {
          if (levels.indexOf(method4) <= levels.indexOf(level)) {
            var _console;
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_console = console)[method4].apply(_console, args);
          }
        }
        function namespace(ns) {
          return levels.reduce(function(logger, method4) {
            logger[method4] = debug.bind(console, method4, ns);
            return logger;
          }, {});
        }
        debug.level = namespace.level = function(newLevel) {
          level = newLevel;
        };
        exports2.default = namespace;
      },
      function(module2, exports2, __webpack_require__) {
        var pSlice = Array.prototype.slice;
        var objectKeys = __webpack_require__(52);
        var isArguments2 = __webpack_require__(53);
        var deepEqual = module2.exports = function(actual, expected, opts) {
          if (!opts)
            opts = {};
          if (actual === expected) {
            return true;
          } else if (actual instanceof Date && expected instanceof Date) {
            return actual.getTime() === expected.getTime();
          } else if (!actual || !expected || typeof actual != "object" && typeof expected != "object") {
            return opts.strict ? actual === expected : actual == expected;
          } else {
            return objEquiv(actual, expected, opts);
          }
        };
        function isUndefinedOrNull(value) {
          return value === null || value === void 0;
        }
        function isBuffer2(x2) {
          if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number")
            return false;
          if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
            return false;
          }
          if (x2.length > 0 && typeof x2[0] !== "number")
            return false;
          return true;
        }
        function objEquiv(a2, b2, opts) {
          var i, key2;
          if (isUndefinedOrNull(a2) || isUndefinedOrNull(b2))
            return false;
          if (a2.prototype !== b2.prototype)
            return false;
          if (isArguments2(a2)) {
            if (!isArguments2(b2)) {
              return false;
            }
            a2 = pSlice.call(a2);
            b2 = pSlice.call(b2);
            return deepEqual(a2, b2, opts);
          }
          if (isBuffer2(a2)) {
            if (!isBuffer2(b2)) {
              return false;
            }
            if (a2.length !== b2.length)
              return false;
            for (i = 0; i < a2.length; i++) {
              if (a2[i] !== b2[i])
                return false;
            }
            return true;
          }
          try {
            var ka = objectKeys(a2), kb = objectKeys(b2);
          } catch (e) {
            return false;
          }
          if (ka.length != kb.length)
            return false;
          ka.sort();
          kb.sort();
          for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] != kb[i])
              return false;
          }
          for (i = ka.length - 1; i >= 0; i--) {
            key2 = ka[i];
            if (!deepEqual(a2[key2], b2[key2], opts))
              return false;
          }
          return typeof a2 === typeof b2;
        }
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Registry = __webpack_require__(1);
        var Attributor = function() {
          function Attributor2(attrName, keyName, options2) {
            if (options2 === void 0) {
              options2 = {};
            }
            this.attrName = attrName;
            this.keyName = keyName;
            var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
            if (options2.scope != null) {
              this.scope = options2.scope & Registry.Scope.LEVEL | attributeBit;
            } else {
              this.scope = Registry.Scope.ATTRIBUTE;
            }
            if (options2.whitelist != null)
              this.whitelist = options2.whitelist;
          }
          Attributor2.keys = function(node) {
            return [].map.call(node.attributes, function(item) {
              return item.name;
            });
          };
          Attributor2.prototype.add = function(node, value) {
            if (!this.canAdd(node, value))
              return false;
            node.setAttribute(this.keyName, value);
            return true;
          };
          Attributor2.prototype.canAdd = function(node, value) {
            var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
            if (match == null)
              return false;
            if (this.whitelist == null)
              return true;
            if (typeof value === "string") {
              return this.whitelist.indexOf(value.replace(/["']/g, "")) > -1;
            } else {
              return this.whitelist.indexOf(value) > -1;
            }
          };
          Attributor2.prototype.remove = function(node) {
            node.removeAttribute(this.keyName);
          };
          Attributor2.prototype.value = function(node) {
            var value = node.getAttribute(this.keyName);
            if (this.canAdd(node, value) && value) {
              return value;
            }
            return "";
          };
          return Attributor2;
        }();
        exports2.default = Attributor;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.Code = void 0;
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Code = function(_Inline) {
          _inherits(Code2, _Inline);
          function Code2() {
            _classCallCheck(this, Code2);
            return _possibleConstructorReturn(this, (Code2.__proto__ || Object.getPrototypeOf(Code2)).apply(this, arguments));
          }
          return Code2;
        }(_inline2.default);
        Code.blotName = "code";
        Code.tagName = "CODE";
        var CodeBlock = function(_Block) {
          _inherits(CodeBlock2, _Block);
          function CodeBlock2() {
            _classCallCheck(this, CodeBlock2);
            return _possibleConstructorReturn(this, (CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2)).apply(this, arguments));
          }
          _createClass(CodeBlock2, [{
            key: "delta",
            value: function delta() {
              var _this3 = this;
              var text = this.domNode.textContent;
              if (text.endsWith("\n")) {
                text = text.slice(0, -1);
              }
              return text.split("\n").reduce(function(delta2, frag) {
                return delta2.insert(frag).insert("\n", _this3.formats());
              }, new _quillDelta2.default());
            }
          }, {
            key: "format",
            value: function format2(name, value) {
              if (name === this.statics.blotName && value)
                return;
              var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text = _descendant2[0];
              if (text != null) {
                text.deleteAt(text.length() - 1, 1);
              }
              _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "format", this).call(this, name, value);
            }
          }, {
            key: "formatAt",
            value: function formatAt(index2, length, name, value) {
              if (length === 0)
                return;
              if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
                return;
              }
              var nextNewline = this.newlineIndex(index2);
              if (nextNewline < 0 || nextNewline >= index2 + length)
                return;
              var prevNewline = this.newlineIndex(index2, true) + 1;
              var isolateLength = nextNewline - prevNewline + 1;
              var blot = this.isolate(prevNewline, isolateLength);
              var next = blot.next;
              blot.format(name, value);
              if (next instanceof CodeBlock2) {
                next.formatAt(0, index2 - prevNewline + length - isolateLength, name, value);
              }
            }
          }, {
            key: "insertAt",
            value: function insertAt(index2, value, def) {
              if (def != null)
                return;
              var _descendant3 = this.descendant(_text2.default, index2), _descendant4 = _slicedToArray(_descendant3, 2), text = _descendant4[0], offset2 = _descendant4[1];
              text.insertAt(offset2, value);
            }
          }, {
            key: "length",
            value: function length() {
              var length2 = this.domNode.textContent.length;
              if (!this.domNode.textContent.endsWith("\n")) {
                return length2 + 1;
              }
              return length2;
            }
          }, {
            key: "newlineIndex",
            value: function newlineIndex(searchIndex) {
              var reverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (!reverse) {
                var offset2 = this.domNode.textContent.slice(searchIndex).indexOf("\n");
                return offset2 > -1 ? searchIndex + offset2 : -1;
              } else {
                return this.domNode.textContent.slice(0, searchIndex).lastIndexOf("\n");
              }
            }
          }, {
            key: "optimize",
            value: function optimize(context) {
              if (!this.domNode.textContent.endsWith("\n")) {
                this.appendChild(_parchment2.default.create("text", "\n"));
              }
              _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "optimize", this).call(this, context);
              var next = this.next;
              if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
                next.optimize(context);
                next.moveChildren(this);
                next.remove();
              }
            }
          }, {
            key: "replace",
            value: function replace(target) {
              _get(CodeBlock2.prototype.__proto__ || Object.getPrototypeOf(CodeBlock2.prototype), "replace", this).call(this, target);
              [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(node) {
                var blot = _parchment2.default.find(node);
                if (blot == null) {
                  node.parentNode.removeChild(node);
                } else if (blot instanceof _parchment2.default.Embed) {
                  blot.remove();
                } else {
                  blot.unwrap();
                }
              });
            }
          }], [{
            key: "create",
            value: function create(value) {
              var domNode = _get(CodeBlock2.__proto__ || Object.getPrototypeOf(CodeBlock2), "create", this).call(this, value);
              domNode.setAttribute("spellcheck", false);
              return domNode;
            }
          }, {
            key: "formats",
            value: function formats() {
              return true;
            }
          }]);
          return CodeBlock2;
        }(_block2.default);
        CodeBlock.blotName = "code-block";
        CodeBlock.tagName = "PRE";
        CodeBlock.TAB = "  ";
        exports2.Code = Code;
        exports2.default = CodeBlock;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _op = __webpack_require__(20);
        var _op2 = _interopRequireDefault(_op);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _code = __webpack_require__(13);
        var _code2 = _interopRequireDefault(_code);
        var _cursor = __webpack_require__(24);
        var _cursor2 = _interopRequireDefault(_cursor);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        var _break = __webpack_require__(16);
        var _break2 = _interopRequireDefault(_break);
        var _clone = __webpack_require__(21);
        var _clone2 = _interopRequireDefault(_clone);
        var _deepEqual = __webpack_require__(11);
        var _deepEqual2 = _interopRequireDefault(_deepEqual);
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var ASCII = /^[ -~]*$/;
        var Editor = function() {
          function Editor2(scroll) {
            _classCallCheck(this, Editor2);
            this.scroll = scroll;
            this.delta = this.getDelta();
          }
          _createClass(Editor2, [{
            key: "applyDelta",
            value: function applyDelta(delta) {
              var _this = this;
              var consumeNextNewline = false;
              this.scroll.update();
              var scrollLength = this.scroll.length();
              this.scroll.batchStart();
              delta = normalizeDelta(delta);
              delta.reduce(function(index2, op) {
                var length = op.retain || op.delete || op.insert.length || 1;
                var attributes = op.attributes || {};
                if (op.insert != null) {
                  if (typeof op.insert === "string") {
                    var text = op.insert;
                    if (text.endsWith("\n") && consumeNextNewline) {
                      consumeNextNewline = false;
                      text = text.slice(0, -1);
                    }
                    if (index2 >= scrollLength && !text.endsWith("\n")) {
                      consumeNextNewline = true;
                    }
                    _this.scroll.insertAt(index2, text);
                    var _scroll$line = _this.scroll.line(index2), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset2 = _scroll$line2[1];
                    var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                    if (line instanceof _block2.default) {
                      var _line$descendant = line.descendant(_parchment2.default.Leaf, offset2), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];
                      formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                    }
                    attributes = _op2.default.attributes.diff(formats, attributes) || {};
                  } else if (_typeof2(op.insert) === "object") {
                    var key2 = Object.keys(op.insert)[0];
                    if (key2 == null)
                      return index2;
                    _this.scroll.insertAt(index2, key2, op.insert[key2]);
                  }
                  scrollLength += length;
                }
                Object.keys(attributes).forEach(function(name) {
                  _this.scroll.formatAt(index2, length, name, attributes[name]);
                });
                return index2 + length;
              }, 0);
              delta.reduce(function(index2, op) {
                if (typeof op.delete === "number") {
                  _this.scroll.deleteAt(index2, op.delete);
                  return index2;
                }
                return index2 + (op.retain || op.insert.length || 1);
              }, 0);
              this.scroll.batchEnd();
              return this.update(delta);
            }
          }, {
            key: "deleteText",
            value: function deleteText(index2, length) {
              this.scroll.deleteAt(index2, length);
              return this.update(new _quillDelta2.default().retain(index2).delete(length));
            }
          }, {
            key: "formatLine",
            value: function formatLine(index2, length) {
              var _this2 = this;
              var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              this.scroll.update();
              Object.keys(formats).forEach(function(format2) {
                if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format2])
                  return;
                var lines = _this2.scroll.lines(index2, Math.max(length, 1));
                var lengthRemaining = length;
                lines.forEach(function(line) {
                  var lineLength = line.length();
                  if (!(line instanceof _code2.default)) {
                    line.format(format2, formats[format2]);
                  } else {
                    var codeIndex = index2 - line.offset(_this2.scroll);
                    var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                    line.formatAt(codeIndex, codeLength, format2, formats[format2]);
                  }
                  lengthRemaining -= lineLength;
                });
              });
              this.scroll.optimize();
              return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
            }
          }, {
            key: "formatText",
            value: function formatText(index2, length) {
              var _this3 = this;
              var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              Object.keys(formats).forEach(function(format2) {
                _this3.scroll.formatAt(index2, length, format2, formats[format2]);
              });
              return this.update(new _quillDelta2.default().retain(index2).retain(length, (0, _clone2.default)(formats)));
            }
          }, {
            key: "getContents",
            value: function getContents(index2, length) {
              return this.delta.slice(index2, index2 + length);
            }
          }, {
            key: "getDelta",
            value: function getDelta() {
              return this.scroll.lines().reduce(function(delta, line) {
                return delta.concat(line.delta());
              }, new _quillDelta2.default());
            }
          }, {
            key: "getFormat",
            value: function getFormat(index2) {
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var lines = [], leaves = [];
              if (length === 0) {
                this.scroll.path(index2).forEach(function(path) {
                  var _path = _slicedToArray(path, 1), blot = _path[0];
                  if (blot instanceof _block2.default) {
                    lines.push(blot);
                  } else if (blot instanceof _parchment2.default.Leaf) {
                    leaves.push(blot);
                  }
                });
              } else {
                lines = this.scroll.lines(index2, length);
                leaves = this.scroll.descendants(_parchment2.default.Leaf, index2, length);
              }
              var formatsArr = [lines, leaves].map(function(blots) {
                if (blots.length === 0)
                  return {};
                var formats = (0, _block.bubbleFormats)(blots.shift());
                while (Object.keys(formats).length > 0) {
                  var blot = blots.shift();
                  if (blot == null)
                    return formats;
                  formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
                }
                return formats;
              });
              return _extend2.default.apply(_extend2.default, formatsArr);
            }
          }, {
            key: "getText",
            value: function getText(index2, length) {
              return this.getContents(index2, length).filter(function(op) {
                return typeof op.insert === "string";
              }).map(function(op) {
                return op.insert;
              }).join("");
            }
          }, {
            key: "insertEmbed",
            value: function insertEmbed(index2, embed, value) {
              this.scroll.insertAt(index2, embed, value);
              return this.update(new _quillDelta2.default().retain(index2).insert(_defineProperty2({}, embed, value)));
            }
          }, {
            key: "insertText",
            value: function insertText(index2, text) {
              var _this4 = this;
              var formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
              this.scroll.insertAt(index2, text);
              Object.keys(formats).forEach(function(format2) {
                _this4.scroll.formatAt(index2, text.length, format2, formats[format2]);
              });
              return this.update(new _quillDelta2.default().retain(index2).insert(text, (0, _clone2.default)(formats)));
            }
          }, {
            key: "isBlank",
            value: function isBlank() {
              if (this.scroll.children.length == 0)
                return true;
              if (this.scroll.children.length > 1)
                return false;
              var block = this.scroll.children.head;
              if (block.statics.blotName !== _block2.default.blotName)
                return false;
              if (block.children.length > 1)
                return false;
              return block.children.head instanceof _break2.default;
            }
          }, {
            key: "removeFormat",
            value: function removeFormat(index2, length) {
              var text = this.getText(index2, length);
              var _scroll$line3 = this.scroll.line(index2 + length), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset2 = _scroll$line4[1];
              var suffixLength = 0, suffix = new _quillDelta2.default();
              if (line != null) {
                if (!(line instanceof _code2.default)) {
                  suffixLength = line.length() - offset2;
                } else {
                  suffixLength = line.newlineIndex(offset2) - offset2 + 1;
                }
                suffix = line.delta().slice(offset2, offset2 + suffixLength - 1).insert("\n");
              }
              var contents = this.getContents(index2, length + suffixLength);
              var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
              var delta = new _quillDelta2.default().retain(index2).concat(diff);
              return this.applyDelta(delta);
            }
          }, {
            key: "update",
            value: function update(change) {
              var mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              var cursorIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
              var oldDelta = this.delta;
              if (mutations.length === 1 && mutations[0].type === "characterData" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
                var textBlot = _parchment2.default.find(mutations[0].target);
                var formats = (0, _block.bubbleFormats)(textBlot);
                var index2 = textBlot.offset(this.scroll);
                var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, "");
                var oldText = new _quillDelta2.default().insert(oldValue);
                var newText = new _quillDelta2.default().insert(textBlot.value());
                var diffDelta = new _quillDelta2.default().retain(index2).concat(oldText.diff(newText, cursorIndex));
                change = diffDelta.reduce(function(delta, op) {
                  if (op.insert) {
                    return delta.insert(op.insert, formats);
                  } else {
                    return delta.push(op);
                  }
                }, new _quillDelta2.default());
                this.delta = oldDelta.compose(change);
              } else {
                this.delta = this.getDelta();
                if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
                  change = oldDelta.diff(this.delta, cursorIndex);
                }
              }
              return change;
            }
          }]);
          return Editor2;
        }();
        function combineFormats(formats, combined) {
          return Object.keys(combined).reduce(function(merged, name) {
            if (formats[name] == null)
              return merged;
            if (combined[name] === formats[name]) {
              merged[name] = combined[name];
            } else if (Array.isArray(combined[name])) {
              if (combined[name].indexOf(formats[name]) < 0) {
                merged[name] = combined[name].concat([formats[name]]);
              }
            } else {
              merged[name] = [combined[name], formats[name]];
            }
            return merged;
          }, {});
        }
        function normalizeDelta(delta) {
          return delta.reduce(function(delta2, op) {
            if (op.insert === 1) {
              var attributes = (0, _clone2.default)(op.attributes);
              delete attributes["image"];
              return delta2.insert({ image: op.attributes.image }, attributes);
            }
            if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
              op = (0, _clone2.default)(op);
              if (op.attributes.list) {
                op.attributes.list = "ordered";
              } else {
                op.attributes.list = "bullet";
                delete op.attributes.bullet;
              }
            }
            if (typeof op.insert === "string") {
              var text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
              return delta2.insert(text, op.attributes);
            }
            return delta2.push(op);
          }, new _quillDelta2.default());
        }
        exports2.default = Editor;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.Range = void 0;
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _clone = __webpack_require__(21);
        var _clone2 = _interopRequireDefault(_clone);
        var _deepEqual = __webpack_require__(11);
        var _deepEqual2 = _interopRequireDefault(_deepEqual);
        var _emitter3 = __webpack_require__(8);
        var _emitter4 = _interopRequireDefault(_emitter3);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          } else {
            return Array.from(arr);
          }
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var debug = (0, _logger2.default)("quill:selection");
        var Range = function Range2(index2) {
          var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          _classCallCheck(this, Range2);
          this.index = index2;
          this.length = length;
        };
        var Selection = function() {
          function Selection2(scroll, emitter) {
            var _this = this;
            _classCallCheck(this, Selection2);
            this.emitter = emitter;
            this.scroll = scroll;
            this.composing = false;
            this.mouseDown = false;
            this.root = this.scroll.domNode;
            this.cursor = _parchment2.default.create("cursor", this);
            this.lastRange = this.savedRange = new Range(0, 0);
            this.handleComposition();
            this.handleDragging();
            this.emitter.listenDOM("selectionchange", document, function() {
              if (!_this.mouseDown) {
                setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
              }
            });
            this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type4, delta) {
              if (type4 === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
                _this.update(_emitter4.default.sources.SILENT);
              }
            });
            this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {
              if (!_this.hasFocus())
                return;
              var native = _this.getNativeRange();
              if (native == null)
                return;
              if (native.start.node === _this.cursor.textNode)
                return;
              _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {
                try {
                  _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
                } catch (ignored) {
                }
              });
            });
            this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context) {
              if (context.range) {
                var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;
                _this.setNativeRange(startNode, startOffset, endNode, endOffset);
              }
            });
            this.update(_emitter4.default.sources.SILENT);
          }
          _createClass(Selection2, [{
            key: "handleComposition",
            value: function handleComposition() {
              var _this2 = this;
              this.root.addEventListener("compositionstart", function() {
                _this2.composing = true;
              });
              this.root.addEventListener("compositionend", function() {
                _this2.composing = false;
                if (_this2.cursor.parent) {
                  var range3 = _this2.cursor.restore();
                  if (!range3)
                    return;
                  setTimeout(function() {
                    _this2.setNativeRange(range3.startNode, range3.startOffset, range3.endNode, range3.endOffset);
                  }, 1);
                }
              });
            }
          }, {
            key: "handleDragging",
            value: function handleDragging() {
              var _this3 = this;
              this.emitter.listenDOM("mousedown", document.body, function() {
                _this3.mouseDown = true;
              });
              this.emitter.listenDOM("mouseup", document.body, function() {
                _this3.mouseDown = false;
                _this3.update(_emitter4.default.sources.USER);
              });
            }
          }, {
            key: "focus",
            value: function focus() {
              if (this.hasFocus())
                return;
              this.root.focus();
              this.setRange(this.savedRange);
            }
          }, {
            key: "format",
            value: function format2(_format, value) {
              if (this.scroll.whitelist != null && !this.scroll.whitelist[_format])
                return;
              this.scroll.update();
              var nativeRange = this.getNativeRange();
              if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK))
                return;
              if (nativeRange.start.node !== this.cursor.textNode) {
                var blot = _parchment2.default.find(nativeRange.start.node, false);
                if (blot == null)
                  return;
                if (blot instanceof _parchment2.default.Leaf) {
                  var after = blot.split(nativeRange.start.offset);
                  blot.parent.insertBefore(this.cursor, after);
                } else {
                  blot.insertBefore(this.cursor, nativeRange.start.node);
                }
                this.cursor.attach();
              }
              this.cursor.format(_format, value);
              this.scroll.optimize();
              this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
              this.update();
            }
          }, {
            key: "getBounds",
            value: function getBounds(index2) {
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var scrollLength = this.scroll.length();
              index2 = Math.min(index2, scrollLength - 1);
              length = Math.min(index2 + length, scrollLength - 1) - index2;
              var node = void 0, _scroll$leaf = this.scroll.leaf(index2), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset2 = _scroll$leaf2[1];
              if (leaf == null)
                return null;
              var _leaf$position = leaf.position(offset2, true);
              var _leaf$position2 = _slicedToArray(_leaf$position, 2);
              node = _leaf$position2[0];
              offset2 = _leaf$position2[1];
              var range3 = document.createRange();
              if (length > 0) {
                range3.setStart(node, offset2);
                var _scroll$leaf3 = this.scroll.leaf(index2 + length);
                var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);
                leaf = _scroll$leaf4[0];
                offset2 = _scroll$leaf4[1];
                if (leaf == null)
                  return null;
                var _leaf$position3 = leaf.position(offset2, true);
                var _leaf$position4 = _slicedToArray(_leaf$position3, 2);
                node = _leaf$position4[0];
                offset2 = _leaf$position4[1];
                range3.setEnd(node, offset2);
                return range3.getBoundingClientRect();
              } else {
                var side = "left";
                var rect = void 0;
                if (node instanceof Text) {
                  if (offset2 < node.data.length) {
                    range3.setStart(node, offset2);
                    range3.setEnd(node, offset2 + 1);
                  } else {
                    range3.setStart(node, offset2 - 1);
                    range3.setEnd(node, offset2);
                    side = "right";
                  }
                  rect = range3.getBoundingClientRect();
                } else {
                  rect = leaf.domNode.getBoundingClientRect();
                  if (offset2 > 0)
                    side = "right";
                }
                return {
                  bottom: rect.top + rect.height,
                  height: rect.height,
                  left: rect[side],
                  right: rect[side],
                  top: rect.top,
                  width: 0
                };
              }
            }
          }, {
            key: "getNativeRange",
            value: function getNativeRange() {
              var selection = document.getSelection();
              if (selection == null || selection.rangeCount <= 0)
                return null;
              var nativeRange = selection.getRangeAt(0);
              if (nativeRange == null)
                return null;
              var range3 = this.normalizeNative(nativeRange);
              debug.info("getNativeRange", range3);
              return range3;
            }
          }, {
            key: "getRange",
            value: function getRange() {
              var normalized = this.getNativeRange();
              if (normalized == null)
                return [null, null];
              var range3 = this.normalizedToRange(normalized);
              return [range3, normalized];
            }
          }, {
            key: "hasFocus",
            value: function hasFocus() {
              return document.activeElement === this.root;
            }
          }, {
            key: "normalizedToRange",
            value: function normalizedToRange(range3) {
              var _this4 = this;
              var positions = [[range3.start.node, range3.start.offset]];
              if (!range3.native.collapsed) {
                positions.push([range3.end.node, range3.end.offset]);
              }
              var indexes = positions.map(function(position) {
                var _position = _slicedToArray(position, 2), node = _position[0], offset2 = _position[1];
                var blot = _parchment2.default.find(node, true);
                var index2 = blot.offset(_this4.scroll);
                if (offset2 === 0) {
                  return index2;
                } else if (blot instanceof _parchment2.default.Container) {
                  return index2 + blot.length();
                } else {
                  return index2 + blot.index(node, offset2);
                }
              });
              var end2 = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
              var start2 = Math.min.apply(Math, [end2].concat(_toConsumableArray(indexes)));
              return new Range(start2, end2 - start2);
            }
          }, {
            key: "normalizeNative",
            value: function normalizeNative(nativeRange) {
              if (!contains2(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains2(this.root, nativeRange.endContainer)) {
                return null;
              }
              var range3 = {
                start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
                end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
                native: nativeRange
              };
              [range3.start, range3.end].forEach(function(position) {
                var node = position.node, offset2 = position.offset;
                while (!(node instanceof Text) && node.childNodes.length > 0) {
                  if (node.childNodes.length > offset2) {
                    node = node.childNodes[offset2];
                    offset2 = 0;
                  } else if (node.childNodes.length === offset2) {
                    node = node.lastChild;
                    offset2 = node instanceof Text ? node.data.length : node.childNodes.length + 1;
                  } else {
                    break;
                  }
                }
                position.node = node, position.offset = offset2;
              });
              return range3;
            }
          }, {
            key: "rangeToNative",
            value: function rangeToNative(range3) {
              var _this5 = this;
              var indexes = range3.collapsed ? [range3.index] : [range3.index, range3.index + range3.length];
              var args = [];
              var scrollLength = this.scroll.length();
              indexes.forEach(function(index2, i) {
                index2 = Math.min(scrollLength - 1, index2);
                var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index2), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset2 = _scroll$leaf6[1];
                var _leaf$position5 = leaf.position(offset2, i !== 0);
                var _leaf$position6 = _slicedToArray(_leaf$position5, 2);
                node = _leaf$position6[0];
                offset2 = _leaf$position6[1];
                args.push(node, offset2);
              });
              if (args.length < 2) {
                args = args.concat(args);
              }
              return args;
            }
          }, {
            key: "scrollIntoView",
            value: function scrollIntoView2(scrollingContainer) {
              var range3 = this.lastRange;
              if (range3 == null)
                return;
              var bounds = this.getBounds(range3.index, range3.length);
              if (bounds == null)
                return;
              var limit2 = this.scroll.length() - 1;
              var _scroll$line = this.scroll.line(Math.min(range3.index, limit2)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];
              var last = first;
              if (range3.length > 0) {
                var _scroll$line3 = this.scroll.line(Math.min(range3.index + range3.length, limit2));
                var _scroll$line4 = _slicedToArray(_scroll$line3, 1);
                last = _scroll$line4[0];
              }
              if (first == null || last == null)
                return;
              var scrollBounds = scrollingContainer.getBoundingClientRect();
              if (bounds.top < scrollBounds.top) {
                scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
              } else if (bounds.bottom > scrollBounds.bottom) {
                scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
              }
            }
          }, {
            key: "setNativeRange",
            value: function setNativeRange(startNode, startOffset) {
              var endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
              var endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
              var force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
              debug.info("setNativeRange", startNode, startOffset, endNode, endOffset);
              if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
                return;
              }
              var selection = document.getSelection();
              if (selection == null)
                return;
              if (startNode != null) {
                if (!this.hasFocus())
                  this.root.focus();
                var native = (this.getNativeRange() || {}).native;
                if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
                  if (startNode.tagName == "BR") {
                    startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                    startNode = startNode.parentNode;
                  }
                  if (endNode.tagName == "BR") {
                    endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                    endNode = endNode.parentNode;
                  }
                  var range3 = document.createRange();
                  range3.setStart(startNode, startOffset);
                  range3.setEnd(endNode, endOffset);
                  selection.removeAllRanges();
                  selection.addRange(range3);
                }
              } else {
                selection.removeAllRanges();
                this.root.blur();
                document.body.focus();
              }
            }
          }, {
            key: "setRange",
            value: function setRange(range3) {
              var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _emitter4.default.sources.API;
              if (typeof force === "string") {
                source = force;
                force = false;
              }
              debug.info("setRange", range3);
              if (range3 != null) {
                var args = this.rangeToNative(range3);
                this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
              } else {
                this.setNativeRange(null);
              }
              this.update(source);
            }
          }, {
            key: "update",
            value: function update() {
              var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _emitter4.default.sources.USER;
              var oldRange = this.lastRange;
              var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];
              this.lastRange = lastRange;
              if (this.lastRange != null) {
                this.savedRange = this.lastRange;
              }
              if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
                var _emitter;
                if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
                  this.cursor.restore();
                }
                var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
                (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
                if (source !== _emitter4.default.sources.SILENT) {
                  var _emitter2;
                  (_emitter2 = this.emitter).emit.apply(_emitter2, args);
                }
              }
            }
          }]);
          return Selection2;
        }();
        function contains2(parent, descendant) {
          try {
            descendant.parentNode;
          } catch (e) {
            return false;
          }
          if (descendant instanceof Text) {
            descendant = descendant.parentNode;
          }
          return parent.contains(descendant);
        }
        exports2.Range = Range;
        exports2.default = Selection;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Break = function(_Parchment$Embed) {
          _inherits(Break2, _Parchment$Embed);
          function Break2() {
            _classCallCheck(this, Break2);
            return _possibleConstructorReturn(this, (Break2.__proto__ || Object.getPrototypeOf(Break2)).apply(this, arguments));
          }
          _createClass(Break2, [{
            key: "insertInto",
            value: function insertInto(parent, ref2) {
              if (parent.children.length === 0) {
                _get(Break2.prototype.__proto__ || Object.getPrototypeOf(Break2.prototype), "insertInto", this).call(this, parent, ref2);
              } else {
                this.remove();
              }
            }
          }, {
            key: "length",
            value: function length() {
              return 0;
            }
          }, {
            key: "value",
            value: function value() {
              return "";
            }
          }], [{
            key: "value",
            value: function value() {
              return void 0;
            }
          }]);
          return Break2;
        }(_parchment2.default.Embed);
        Break.blotName = "break";
        Break.tagName = "BR";
        exports2.default = Break;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var linked_list_1 = __webpack_require__(44);
        var shadow_1 = __webpack_require__(30);
        var Registry = __webpack_require__(1);
        var ContainerBlot = function(_super) {
          __extends(ContainerBlot2, _super);
          function ContainerBlot2(domNode) {
            var _this = _super.call(this, domNode) || this;
            _this.build();
            return _this;
          }
          ContainerBlot2.prototype.appendChild = function(other) {
            this.insertBefore(other);
          };
          ContainerBlot2.prototype.attach = function() {
            _super.prototype.attach.call(this);
            this.children.forEach(function(child) {
              child.attach();
            });
          };
          ContainerBlot2.prototype.build = function() {
            var _this = this;
            this.children = new linked_list_1.default();
            [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {
              try {
                var child = makeBlot(node);
                _this.insertBefore(child, _this.children.head || void 0);
              } catch (err) {
                if (err instanceof Registry.ParchmentError)
                  return;
                else
                  throw err;
              }
            });
          };
          ContainerBlot2.prototype.deleteAt = function(index2, length) {
            if (index2 === 0 && length === this.length()) {
              return this.remove();
            }
            this.children.forEachAt(index2, length, function(child, offset2, length2) {
              child.deleteAt(offset2, length2);
            });
          };
          ContainerBlot2.prototype.descendant = function(criteria, index2) {
            var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
            if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
              return [child, offset2];
            } else if (child instanceof ContainerBlot2) {
              return child.descendant(criteria, offset2);
            } else {
              return [null, -1];
            }
          };
          ContainerBlot2.prototype.descendants = function(criteria, index2, length) {
            if (index2 === void 0) {
              index2 = 0;
            }
            if (length === void 0) {
              length = Number.MAX_VALUE;
            }
            var descendants = [];
            var lengthLeft = length;
            this.children.forEachAt(index2, length, function(child, index3, length2) {
              if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {
                descendants.push(child);
              }
              if (child instanceof ContainerBlot2) {
                descendants = descendants.concat(child.descendants(criteria, index3, lengthLeft));
              }
              lengthLeft -= length2;
            });
            return descendants;
          };
          ContainerBlot2.prototype.detach = function() {
            this.children.forEach(function(child) {
              child.detach();
            });
            _super.prototype.detach.call(this);
          };
          ContainerBlot2.prototype.formatAt = function(index2, length, name, value) {
            this.children.forEachAt(index2, length, function(child, offset2, length2) {
              child.formatAt(offset2, length2, name, value);
            });
          };
          ContainerBlot2.prototype.insertAt = function(index2, value, def) {
            var _a = this.children.find(index2), child = _a[0], offset2 = _a[1];
            if (child) {
              child.insertAt(offset2, value, def);
            } else {
              var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
              this.appendChild(blot);
            }
          };
          ContainerBlot2.prototype.insertBefore = function(childBlot, refBlot) {
            if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {
              return childBlot instanceof child;
            })) {
              throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
            }
            childBlot.insertInto(this, refBlot);
          };
          ContainerBlot2.prototype.length = function() {
            return this.children.reduce(function(memo, child) {
              return memo + child.length();
            }, 0);
          };
          ContainerBlot2.prototype.moveChildren = function(targetParent, refNode) {
            this.children.forEach(function(child) {
              targetParent.insertBefore(child, refNode);
            });
          };
          ContainerBlot2.prototype.optimize = function(context) {
            _super.prototype.optimize.call(this, context);
            if (this.children.length === 0) {
              if (this.statics.defaultChild != null) {
                var child = Registry.create(this.statics.defaultChild);
                this.appendChild(child);
                child.optimize(context);
              } else {
                this.remove();
              }
            }
          };
          ContainerBlot2.prototype.path = function(index2, inclusive) {
            if (inclusive === void 0) {
              inclusive = false;
            }
            var _a = this.children.find(index2, inclusive), child = _a[0], offset2 = _a[1];
            var position = [[this, index2]];
            if (child instanceof ContainerBlot2) {
              return position.concat(child.path(offset2, inclusive));
            } else if (child != null) {
              position.push([child, offset2]);
            }
            return position;
          };
          ContainerBlot2.prototype.removeChild = function(child) {
            this.children.remove(child);
          };
          ContainerBlot2.prototype.replace = function(target) {
            if (target instanceof ContainerBlot2) {
              target.moveChildren(this);
            }
            _super.prototype.replace.call(this, target);
          };
          ContainerBlot2.prototype.split = function(index2, force) {
            if (force === void 0) {
              force = false;
            }
            if (!force) {
              if (index2 === 0)
                return this;
              if (index2 === this.length())
                return this.next;
            }
            var after = this.clone();
            this.parent.insertBefore(after, this.next);
            this.children.forEachAt(index2, this.length(), function(child, offset2, length) {
              child = child.split(offset2, force);
              after.appendChild(child);
            });
            return after;
          };
          ContainerBlot2.prototype.unwrap = function() {
            this.moveChildren(this.parent, this.next);
            this.remove();
          };
          ContainerBlot2.prototype.update = function(mutations, context) {
            var _this = this;
            var addedNodes = [];
            var removedNodes = [];
            mutations.forEach(function(mutation) {
              if (mutation.target === _this.domNode && mutation.type === "childList") {
                addedNodes.push.apply(addedNodes, mutation.addedNodes);
                removedNodes.push.apply(removedNodes, mutation.removedNodes);
              }
            });
            removedNodes.forEach(function(node) {
              if (node.parentNode != null && node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return;
              }
              var blot = Registry.find(node);
              if (blot == null)
                return;
              if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                blot.detach();
              }
            });
            addedNodes.filter(function(node) {
              return node.parentNode == _this.domNode;
            }).sort(function(a2, b2) {
              if (a2 === b2)
                return 0;
              if (a2.compareDocumentPosition(b2) & Node.DOCUMENT_POSITION_FOLLOWING) {
                return 1;
              }
              return -1;
            }).forEach(function(node) {
              var refBlot = null;
              if (node.nextSibling != null) {
                refBlot = Registry.find(node.nextSibling);
              }
              var blot = makeBlot(node);
              if (blot.next != refBlot || blot.next == null) {
                if (blot.parent != null) {
                  blot.parent.removeChild(_this);
                }
                _this.insertBefore(blot, refBlot || void 0);
              }
            });
          };
          return ContainerBlot2;
        }(shadow_1.default);
        function makeBlot(node) {
          var blot = Registry.find(node);
          if (blot == null) {
            try {
              blot = Registry.create(node);
            } catch (e) {
              blot = Registry.create(Registry.Scope.INLINE);
              [].slice.call(node.childNodes).forEach(function(child) {
                blot.domNode.appendChild(child);
              });
              if (node.parentNode) {
                node.parentNode.replaceChild(blot.domNode, node);
              }
              blot.attach();
            }
          }
          return blot;
        }
        exports2.default = ContainerBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var attributor_1 = __webpack_require__(12);
        var store_1 = __webpack_require__(31);
        var container_1 = __webpack_require__(17);
        var Registry = __webpack_require__(1);
        var FormatBlot = function(_super) {
          __extends(FormatBlot2, _super);
          function FormatBlot2(domNode) {
            var _this = _super.call(this, domNode) || this;
            _this.attributes = new store_1.default(_this.domNode);
            return _this;
          }
          FormatBlot2.formats = function(domNode) {
            if (typeof this.tagName === "string") {
              return true;
            } else if (Array.isArray(this.tagName)) {
              return domNode.tagName.toLowerCase();
            }
            return void 0;
          };
          FormatBlot2.prototype.format = function(name, value) {
            var format2 = Registry.query(name);
            if (format2 instanceof attributor_1.default) {
              this.attributes.attribute(format2, value);
            } else if (value) {
              if (format2 != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                this.replaceWith(name, value);
              }
            }
          };
          FormatBlot2.prototype.formats = function() {
            var formats = this.attributes.values();
            var format2 = this.statics.formats(this.domNode);
            if (format2 != null) {
              formats[this.statics.blotName] = format2;
            }
            return formats;
          };
          FormatBlot2.prototype.replaceWith = function(name, value) {
            var replacement = _super.prototype.replaceWith.call(this, name, value);
            this.attributes.copy(replacement);
            return replacement;
          };
          FormatBlot2.prototype.update = function(mutations, context) {
            var _this = this;
            _super.prototype.update.call(this, mutations, context);
            if (mutations.some(function(mutation) {
              return mutation.target === _this.domNode && mutation.type === "attributes";
            })) {
              this.attributes.build();
            }
          };
          FormatBlot2.prototype.wrap = function(name, value) {
            var wrapper = _super.prototype.wrap.call(this, name, value);
            if (wrapper instanceof FormatBlot2 && wrapper.statics.scope === this.statics.scope) {
              this.attributes.move(wrapper);
            }
            return wrapper;
          };
          return FormatBlot2;
        }(container_1.default);
        exports2.default = FormatBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var shadow_1 = __webpack_require__(30);
        var Registry = __webpack_require__(1);
        var LeafBlot = function(_super) {
          __extends(LeafBlot2, _super);
          function LeafBlot2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          LeafBlot2.value = function(domNode) {
            return true;
          };
          LeafBlot2.prototype.index = function(node, offset2) {
            if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
              return Math.min(offset2, 1);
            }
            return -1;
          };
          LeafBlot2.prototype.position = function(index2, inclusive) {
            var offset2 = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
            if (index2 > 0)
              offset2 += 1;
            return [this.parent.domNode, offset2];
          };
          LeafBlot2.prototype.value = function() {
            var _a;
            return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
          };
          LeafBlot2.scope = Registry.Scope.INLINE_BLOT;
          return LeafBlot2;
        }(shadow_1.default);
        exports2.default = LeafBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var equal = __webpack_require__(11);
        var extend2 = __webpack_require__(3);
        var lib = {
          attributes: {
            compose: function(a2, b2, keepNull) {
              if (typeof a2 !== "object")
                a2 = {};
              if (typeof b2 !== "object")
                b2 = {};
              var attributes = extend2(true, {}, b2);
              if (!keepNull) {
                attributes = Object.keys(attributes).reduce(function(copy2, key3) {
                  if (attributes[key3] != null) {
                    copy2[key3] = attributes[key3];
                  }
                  return copy2;
                }, {});
              }
              for (var key2 in a2) {
                if (a2[key2] !== void 0 && b2[key2] === void 0) {
                  attributes[key2] = a2[key2];
                }
              }
              return Object.keys(attributes).length > 0 ? attributes : void 0;
            },
            diff: function(a2, b2) {
              if (typeof a2 !== "object")
                a2 = {};
              if (typeof b2 !== "object")
                b2 = {};
              var attributes = Object.keys(a2).concat(Object.keys(b2)).reduce(function(attributes2, key2) {
                if (!equal(a2[key2], b2[key2])) {
                  attributes2[key2] = b2[key2] === void 0 ? null : b2[key2];
                }
                return attributes2;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : void 0;
            },
            transform: function(a2, b2, priority) {
              if (typeof a2 !== "object")
                return b2;
              if (typeof b2 !== "object")
                return void 0;
              if (!priority)
                return b2;
              var attributes = Object.keys(b2).reduce(function(attributes2, key2) {
                if (a2[key2] === void 0)
                  attributes2[key2] = b2[key2];
                return attributes2;
              }, {});
              return Object.keys(attributes).length > 0 ? attributes : void 0;
            }
          },
          iterator: function(ops) {
            return new Iterator(ops);
          },
          length: function(op) {
            if (typeof op["delete"] === "number") {
              return op["delete"];
            } else if (typeof op.retain === "number") {
              return op.retain;
            } else {
              return typeof op.insert === "string" ? op.insert.length : 1;
            }
          }
        };
        function Iterator(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }
        Iterator.prototype.hasNext = function() {
          return this.peekLength() < Infinity;
        };
        Iterator.prototype.next = function(length) {
          if (!length)
            length = Infinity;
          var nextOp = this.ops[this.index];
          if (nextOp) {
            var offset2 = this.offset;
            var opLength = lib.length(nextOp);
            if (length >= opLength - offset2) {
              length = opLength - offset2;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }
            if (typeof nextOp["delete"] === "number") {
              return { "delete": length };
            } else {
              var retOp = {};
              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }
              if (typeof nextOp.retain === "number") {
                retOp.retain = length;
              } else if (typeof nextOp.insert === "string") {
                retOp.insert = nextOp.insert.substr(offset2, length);
              } else {
                retOp.insert = nextOp.insert;
              }
              return retOp;
            }
          } else {
            return { retain: Infinity };
          }
        };
        Iterator.prototype.peek = function() {
          return this.ops[this.index];
        };
        Iterator.prototype.peekLength = function() {
          if (this.ops[this.index]) {
            return lib.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        };
        Iterator.prototype.peekType = function() {
          if (this.ops[this.index]) {
            if (typeof this.ops[this.index]["delete"] === "number") {
              return "delete";
            } else if (typeof this.ops[this.index].retain === "number") {
              return "retain";
            } else {
              return "insert";
            }
          }
          return "retain";
        };
        Iterator.prototype.rest = function() {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            var offset2 = this.offset;
            var index2 = this.index;
            var next = this.next();
            var rest = this.ops.slice(this.index);
            this.offset = offset2;
            this.index = index2;
            return [next].concat(rest);
          }
        };
        module2.exports = lib;
      },
      function(module2, exports2) {
        var clone2 = function() {
          function _instanceof(obj, type4) {
            return type4 != null && obj instanceof type4;
          }
          var nativeMap;
          try {
            nativeMap = Map;
          } catch (_2) {
            nativeMap = function() {
            };
          }
          var nativeSet;
          try {
            nativeSet = Set;
          } catch (_2) {
            nativeSet = function() {
            };
          }
          var nativePromise;
          try {
            nativePromise = Promise;
          } catch (_2) {
            nativePromise = function() {
            };
          }
          function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
            if (typeof circular === "object") {
              depth = circular.depth;
              prototype = circular.prototype;
              includeNonEnumerable = circular.includeNonEnumerable;
              circular = circular.circular;
            }
            var allParents = [];
            var allChildren = [];
            var useBuffer = typeof Buffer != "undefined";
            if (typeof circular == "undefined")
              circular = true;
            if (typeof depth == "undefined")
              depth = Infinity;
            function _clone(parent2, depth2) {
              if (parent2 === null)
                return null;
              if (depth2 === 0)
                return parent2;
              var child;
              var proto;
              if (typeof parent2 != "object") {
                return parent2;
              }
              if (_instanceof(parent2, nativeMap)) {
                child = new nativeMap();
              } else if (_instanceof(parent2, nativeSet)) {
                child = new nativeSet();
              } else if (_instanceof(parent2, nativePromise)) {
                child = new nativePromise(function(resolve, reject) {
                  parent2.then(function(value) {
                    resolve(_clone(value, depth2 - 1));
                  }, function(err) {
                    reject(_clone(err, depth2 - 1));
                  });
                });
              } else if (clone3.__isArray(parent2)) {
                child = [];
              } else if (clone3.__isRegExp(parent2)) {
                child = new RegExp(parent2.source, __getRegExpFlags(parent2));
                if (parent2.lastIndex)
                  child.lastIndex = parent2.lastIndex;
              } else if (clone3.__isDate(parent2)) {
                child = new Date(parent2.getTime());
              } else if (useBuffer && Buffer.isBuffer(parent2)) {
                if (Buffer.allocUnsafe) {
                  child = Buffer.allocUnsafe(parent2.length);
                } else {
                  child = new Buffer(parent2.length);
                }
                parent2.copy(child);
                return child;
              } else if (_instanceof(parent2, Error)) {
                child = Object.create(parent2);
              } else {
                if (typeof prototype == "undefined") {
                  proto = Object.getPrototypeOf(parent2);
                  child = Object.create(proto);
                } else {
                  child = Object.create(prototype);
                  proto = prototype;
                }
              }
              if (circular) {
                var index2 = allParents.indexOf(parent2);
                if (index2 != -1) {
                  return allChildren[index2];
                }
                allParents.push(parent2);
                allChildren.push(child);
              }
              if (_instanceof(parent2, nativeMap)) {
                parent2.forEach(function(value, key2) {
                  var keyChild = _clone(key2, depth2 - 1);
                  var valueChild = _clone(value, depth2 - 1);
                  child.set(keyChild, valueChild);
                });
              }
              if (_instanceof(parent2, nativeSet)) {
                parent2.forEach(function(value) {
                  var entryChild = _clone(value, depth2 - 1);
                  child.add(entryChild);
                });
              }
              for (var i in parent2) {
                var attrs;
                if (proto) {
                  attrs = Object.getOwnPropertyDescriptor(proto, i);
                }
                if (attrs && attrs.set == null) {
                  continue;
                }
                child[i] = _clone(parent2[i], depth2 - 1);
              }
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(parent2);
                for (var i = 0; i < symbols.length; i++) {
                  var symbol = symbols[i];
                  var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                  if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                    continue;
                  }
                  child[symbol] = _clone(parent2[symbol], depth2 - 1);
                  if (!descriptor.enumerable) {
                    Object.defineProperty(child, symbol, {
                      enumerable: false
                    });
                  }
                }
              }
              if (includeNonEnumerable) {
                var allPropertyNames = Object.getOwnPropertyNames(parent2);
                for (var i = 0; i < allPropertyNames.length; i++) {
                  var propertyName = allPropertyNames[i];
                  var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                  if (descriptor && descriptor.enumerable) {
                    continue;
                  }
                  child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                  Object.defineProperty(child, propertyName, {
                    enumerable: false
                  });
                }
              }
              return child;
            }
            return _clone(parent, depth);
          }
          clone3.clonePrototype = function clonePrototype(parent) {
            if (parent === null)
              return null;
            var c2 = function() {
            };
            c2.prototype = parent;
            return new c2();
          };
          function __objToStr(o2) {
            return Object.prototype.toString.call(o2);
          }
          clone3.__objToStr = __objToStr;
          function __isDate(o2) {
            return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
          }
          clone3.__isDate = __isDate;
          function __isArray(o2) {
            return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
          }
          clone3.__isArray = __isArray;
          function __isRegExp(o2) {
            return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
          }
          clone3.__isRegExp = __isRegExp;
          function __getRegExpFlags(re) {
            var flags = "";
            if (re.global)
              flags += "g";
            if (re.ignoreCase)
              flags += "i";
            if (re.multiline)
              flags += "m";
            return flags;
          }
          clone3.__getRegExpFlags = __getRegExpFlags;
          return clone3;
        }();
        if (typeof module2 === "object" && module2.exports) {
          module2.exports = clone2;
        }
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _emitter = __webpack_require__(8);
        var _emitter2 = _interopRequireDefault(_emitter);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        var _break = __webpack_require__(16);
        var _break2 = _interopRequireDefault(_break);
        var _code = __webpack_require__(13);
        var _code2 = _interopRequireDefault(_code);
        var _container = __webpack_require__(25);
        var _container2 = _interopRequireDefault(_container);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        function isLine(blot) {
          return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
        }
        var Scroll = function(_Parchment$Scroll) {
          _inherits(Scroll2, _Parchment$Scroll);
          function Scroll2(domNode, config) {
            _classCallCheck(this, Scroll2);
            var _this = _possibleConstructorReturn(this, (Scroll2.__proto__ || Object.getPrototypeOf(Scroll2)).call(this, domNode));
            _this.emitter = config.emitter;
            if (Array.isArray(config.whitelist)) {
              _this.whitelist = config.whitelist.reduce(function(whitelist, format2) {
                whitelist[format2] = true;
                return whitelist;
              }, {});
            }
            _this.domNode.addEventListener("DOMNodeInserted", function() {
            });
            _this.optimize();
            _this.enable();
            return _this;
          }
          _createClass(Scroll2, [{
            key: "batchStart",
            value: function batchStart() {
              this.batch = true;
            }
          }, {
            key: "batchEnd",
            value: function batchEnd() {
              this.batch = false;
              this.optimize();
            }
          }, {
            key: "deleteAt",
            value: function deleteAt(index2, length) {
              var _line = this.line(index2), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset2 = _line2[1];
              var _line3 = this.line(index2 + length), _line4 = _slicedToArray(_line3, 1), last = _line4[0];
              _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "deleteAt", this).call(this, index2, length);
              if (last != null && first !== last && offset2 > 0) {
                if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
                  this.optimize();
                  return;
                }
                if (first instanceof _code2.default) {
                  var newlineIndex = first.newlineIndex(first.length(), true);
                  if (newlineIndex > -1) {
                    first = first.split(newlineIndex + 1);
                    if (first === last) {
                      this.optimize();
                      return;
                    }
                  }
                } else if (last instanceof _code2.default) {
                  var _newlineIndex = last.newlineIndex(0);
                  if (_newlineIndex > -1) {
                    last.split(_newlineIndex + 1);
                  }
                }
                var ref2 = last.children.head instanceof _break2.default ? null : last.children.head;
                first.moveChildren(last, ref2);
                first.remove();
              }
              this.optimize();
            }
          }, {
            key: "enable",
            value: function enable() {
              var enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              this.domNode.setAttribute("contenteditable", enabled);
            }
          }, {
            key: "formatAt",
            value: function formatAt(index2, length, format2, value) {
              if (this.whitelist != null && !this.whitelist[format2])
                return;
              _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "formatAt", this).call(this, index2, length, format2, value);
              this.optimize();
            }
          }, {
            key: "insertAt",
            value: function insertAt(index2, value, def) {
              if (def != null && this.whitelist != null && !this.whitelist[value])
                return;
              if (index2 >= this.length()) {
                if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
                  var blot = _parchment2.default.create(this.statics.defaultChild);
                  this.appendChild(blot);
                  if (def == null && value.endsWith("\n")) {
                    value = value.slice(0, -1);
                  }
                  blot.insertAt(0, value, def);
                } else {
                  var embed = _parchment2.default.create(value, def);
                  this.appendChild(embed);
                }
              } else {
                _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertAt", this).call(this, index2, value, def);
              }
              this.optimize();
            }
          }, {
            key: "insertBefore",
            value: function insertBefore(blot, ref2) {
              if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
                var wrapper = _parchment2.default.create(this.statics.defaultChild);
                wrapper.appendChild(blot);
                blot = wrapper;
              }
              _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "insertBefore", this).call(this, blot, ref2);
            }
          }, {
            key: "leaf",
            value: function leaf(index2) {
              return this.path(index2).pop() || [null, -1];
            }
          }, {
            key: "line",
            value: function line(index2) {
              if (index2 === this.length()) {
                return this.line(index2 - 1);
              }
              return this.descendant(isLine, index2);
            }
          }, {
            key: "lines",
            value: function lines() {
              var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
              var getLines = function getLines2(blot, index3, length2) {
                var lines2 = [], lengthLeft = length2;
                blot.children.forEachAt(index3, length2, function(child, index4, length3) {
                  if (isLine(child)) {
                    lines2.push(child);
                  } else if (child instanceof _parchment2.default.Container) {
                    lines2 = lines2.concat(getLines2(child, index4, lengthLeft));
                  }
                  lengthLeft -= length3;
                });
                return lines2;
              };
              return getLines(this, index2, length);
            }
          }, {
            key: "optimize",
            value: function optimize() {
              var mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.batch === true)
                return;
              _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "optimize", this).call(this, mutations, context);
              if (mutations.length > 0) {
                this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
              }
            }
          }, {
            key: "path",
            value: function path(index2) {
              return _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "path", this).call(this, index2).slice(1);
            }
          }, {
            key: "update",
            value: function update(mutations) {
              if (this.batch === true)
                return;
              var source = _emitter2.default.sources.USER;
              if (typeof mutations === "string") {
                source = mutations;
              }
              if (!Array.isArray(mutations)) {
                mutations = this.observer.takeRecords();
              }
              if (mutations.length > 0) {
                this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
              }
              _get(Scroll2.prototype.__proto__ || Object.getPrototypeOf(Scroll2.prototype), "update", this).call(this, mutations.concat([]));
              if (mutations.length > 0) {
                this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
              }
            }
          }]);
          return Scroll2;
        }(_parchment2.default.Scroll);
        Scroll.blotName = "scroll";
        Scroll.className = "ql-editor";
        Scroll.tagName = "DIV";
        Scroll.defaultChild = "block";
        Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];
        exports2.default = Scroll;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.SHORTKEY = exports2.default = void 0;
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _clone = __webpack_require__(21);
        var _clone2 = _interopRequireDefault(_clone);
        var _deepEqual = __webpack_require__(11);
        var _deepEqual2 = _interopRequireDefault(_deepEqual);
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _op = __webpack_require__(20);
        var _op2 = _interopRequireDefault(_op);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var debug = (0, _logger2.default)("quill:keyboard");
        var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
        var Keyboard = function(_Module) {
          _inherits(Keyboard2, _Module);
          _createClass(Keyboard2, null, [{
            key: "match",
            value: function match(evt, binding) {
              binding = normalize(binding);
              if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(key2) {
                return !!binding[key2] !== evt[key2] && binding[key2] !== null;
              })) {
                return false;
              }
              return binding.key === (evt.which || evt.keyCode);
            }
          }]);
          function Keyboard2(quill2, options2) {
            _classCallCheck(this, Keyboard2);
            var _this = _possibleConstructorReturn(this, (Keyboard2.__proto__ || Object.getPrototypeOf(Keyboard2)).call(this, quill2, options2));
            _this.bindings = {};
            Object.keys(_this.options.bindings).forEach(function(name) {
              if (name === "list autofill" && quill2.scroll.whitelist != null && !quill2.scroll.whitelist["list"]) {
                return;
              }
              if (_this.options.bindings[name]) {
                _this.addBinding(_this.options.bindings[name]);
              }
            });
            _this.addBinding({ key: Keyboard2.keys.ENTER, shiftKey: null }, handleEnter);
            _this.addBinding({ key: Keyboard2.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
            });
            if (/Firefox/i.test(navigator.userAgent)) {
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
              _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true }, handleDelete);
            } else {
              _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
              _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
            }
            _this.addBinding({ key: Keyboard2.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
            _this.addBinding({ key: Keyboard2.keys.DELETE }, { collapsed: false }, handleDeleteRange);
            _this.addBinding({ key: Keyboard2.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
            _this.listen();
            return _this;
          }
          _createClass(Keyboard2, [{
            key: "addBinding",
            value: function addBinding(key2) {
              var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              var binding = normalize(key2);
              if (binding == null || binding.key == null) {
                return debug.warn("Attempted to add invalid keyboard binding", binding);
              }
              if (typeof context === "function") {
                context = { handler: context };
              }
              if (typeof handler === "function") {
                handler = { handler };
              }
              binding = (0, _extend2.default)(binding, context, handler);
              this.bindings[binding.key] = this.bindings[binding.key] || [];
              this.bindings[binding.key].push(binding);
            }
          }, {
            key: "listen",
            value: function listen() {
              var _this2 = this;
              this.quill.root.addEventListener("keydown", function(evt) {
                if (evt.defaultPrevented)
                  return;
                var which = evt.which || evt.keyCode;
                var bindings = (_this2.bindings[which] || []).filter(function(binding) {
                  return Keyboard2.match(evt, binding);
                });
                if (bindings.length === 0)
                  return;
                var range3 = _this2.quill.getSelection();
                if (range3 == null || !_this2.quill.hasFocus())
                  return;
                var _quill$getLine = _this2.quill.getLine(range3.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset2 = _quill$getLine2[1];
                var _quill$getLeaf = _this2.quill.getLeaf(range3.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];
                var _ref = range3.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range3.index + range3.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];
                var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : "";
                var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : "";
                var curContext = {
                  collapsed: range3.length === 0,
                  empty: range3.length === 0 && line.length() <= 1,
                  format: _this2.quill.getFormat(range3),
                  offset: offset2,
                  prefix: prefixText,
                  suffix: suffixText
                };
                var prevented = bindings.some(function(binding) {
                  if (binding.collapsed != null && binding.collapsed !== curContext.collapsed)
                    return false;
                  if (binding.empty != null && binding.empty !== curContext.empty)
                    return false;
                  if (binding.offset != null && binding.offset !== curContext.offset)
                    return false;
                  if (Array.isArray(binding.format)) {
                    if (binding.format.every(function(name) {
                      return curContext.format[name] == null;
                    })) {
                      return false;
                    }
                  } else if (_typeof2(binding.format) === "object") {
                    if (!Object.keys(binding.format).every(function(name) {
                      if (binding.format[name] === true)
                        return curContext.format[name] != null;
                      if (binding.format[name] === false)
                        return curContext.format[name] == null;
                      return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                    })) {
                      return false;
                    }
                  }
                  if (binding.prefix != null && !binding.prefix.test(curContext.prefix))
                    return false;
                  if (binding.suffix != null && !binding.suffix.test(curContext.suffix))
                    return false;
                  return binding.handler.call(_this2, range3, curContext) !== true;
                });
                if (prevented) {
                  evt.preventDefault();
                }
              });
            }
          }]);
          return Keyboard2;
        }(_module2.default);
        Keyboard.keys = {
          BACKSPACE: 8,
          TAB: 9,
          ENTER: 13,
          ESCAPE: 27,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          DELETE: 46
        };
        Keyboard.DEFAULTS = {
          bindings: {
            "bold": makeFormatHandler("bold"),
            "italic": makeFormatHandler("italic"),
            "underline": makeFormatHandler("underline"),
            "indent": {
              key: Keyboard.keys.TAB,
              format: ["blockquote", "indent", "list"],
              handler: function handler(range3, context) {
                if (context.collapsed && context.offset !== 0)
                  return true;
                this.quill.format("indent", "+1", _quill2.default.sources.USER);
              }
            },
            "outdent": {
              key: Keyboard.keys.TAB,
              shiftKey: true,
              format: ["blockquote", "indent", "list"],
              handler: function handler(range3, context) {
                if (context.collapsed && context.offset !== 0)
                  return true;
                this.quill.format("indent", "-1", _quill2.default.sources.USER);
              }
            },
            "outdent backspace": {
              key: Keyboard.keys.BACKSPACE,
              collapsed: true,
              shiftKey: null,
              metaKey: null,
              ctrlKey: null,
              altKey: null,
              format: ["indent", "list"],
              offset: 0,
              handler: function handler(range3, context) {
                if (context.format.indent != null) {
                  this.quill.format("indent", "-1", _quill2.default.sources.USER);
                } else if (context.format.list != null) {
                  this.quill.format("list", false, _quill2.default.sources.USER);
                }
              }
            },
            "indent code-block": makeCodeBlockHandler(true),
            "outdent code-block": makeCodeBlockHandler(false),
            "remove tab": {
              key: Keyboard.keys.TAB,
              shiftKey: true,
              collapsed: true,
              prefix: /\t$/,
              handler: function handler(range3) {
                this.quill.deleteText(range3.index - 1, 1, _quill2.default.sources.USER);
              }
            },
            "tab": {
              key: Keyboard.keys.TAB,
              handler: function handler(range3) {
                this.quill.history.cutoff();
                var delta = new _quillDelta2.default().retain(range3.index).delete(range3.length).insert("	");
                this.quill.updateContents(delta, _quill2.default.sources.USER);
                this.quill.history.cutoff();
                this.quill.setSelection(range3.index + 1, _quill2.default.sources.SILENT);
              }
            },
            "list empty enter": {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ["list"],
              empty: true,
              handler: function handler(range3, context) {
                this.quill.format("list", false, _quill2.default.sources.USER);
                if (context.format.indent) {
                  this.quill.format("indent", false, _quill2.default.sources.USER);
                }
              }
            },
            "checklist enter": {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: { list: "checked" },
              handler: function handler(range3) {
                var _quill$getLine3 = this.quill.getLine(range3.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset2 = _quill$getLine4[1];
                var formats = (0, _extend2.default)({}, line.formats(), { list: "checked" });
                var delta = new _quillDelta2.default().retain(range3.index).insert("\n", formats).retain(line.length() - offset2 - 1).retain(1, { list: "unchecked" });
                this.quill.updateContents(delta, _quill2.default.sources.USER);
                this.quill.setSelection(range3.index + 1, _quill2.default.sources.SILENT);
                this.quill.scrollIntoView();
              }
            },
            "header enter": {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ["header"],
              suffix: /^$/,
              handler: function handler(range3, context) {
                var _quill$getLine5 = this.quill.getLine(range3.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset2 = _quill$getLine6[1];
                var delta = new _quillDelta2.default().retain(range3.index).insert("\n", context.format).retain(line.length() - offset2 - 1).retain(1, { header: null });
                this.quill.updateContents(delta, _quill2.default.sources.USER);
                this.quill.setSelection(range3.index + 1, _quill2.default.sources.SILENT);
                this.quill.scrollIntoView();
              }
            },
            "list autofill": {
              key: " ",
              collapsed: true,
              format: { list: false },
              prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
              handler: function handler(range3, context) {
                var length = context.prefix.length;
                var _quill$getLine7 = this.quill.getLine(range3.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset2 = _quill$getLine8[1];
                if (offset2 > length)
                  return true;
                var value = void 0;
                switch (context.prefix.trim()) {
                  case "[]":
                  case "[ ]":
                    value = "unchecked";
                    break;
                  case "[x]":
                    value = "checked";
                    break;
                  case "-":
                  case "*":
                    value = "bullet";
                    break;
                  default:
                    value = "ordered";
                }
                this.quill.insertText(range3.index, " ", _quill2.default.sources.USER);
                this.quill.history.cutoff();
                var delta = new _quillDelta2.default().retain(range3.index - offset2).delete(length + 1).retain(line.length() - 2 - offset2).retain(1, { list: value });
                this.quill.updateContents(delta, _quill2.default.sources.USER);
                this.quill.history.cutoff();
                this.quill.setSelection(range3.index - length, _quill2.default.sources.SILENT);
              }
            },
            "code exit": {
              key: Keyboard.keys.ENTER,
              collapsed: true,
              format: ["code-block"],
              prefix: /\n\n$/,
              suffix: /^\s+$/,
              handler: function handler(range3) {
                var _quill$getLine9 = this.quill.getLine(range3.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset2 = _quill$getLine10[1];
                var delta = new _quillDelta2.default().retain(range3.index + line.length() - offset2 - 2).retain(1, { "code-block": null }).delete(1);
                this.quill.updateContents(delta, _quill2.default.sources.USER);
              }
            },
            "embed left": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
            "embed left shift": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
            "embed right": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
            "embed right shift": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
          }
        };
        function makeEmbedArrowHandler(key2, shiftKey) {
          var _ref3;
          var where = key2 === Keyboard.keys.LEFT ? "prefix" : "suffix";
          return _ref3 = {
            key: key2,
            shiftKey,
            altKey: null
          }, _defineProperty2(_ref3, where, /^$/), _defineProperty2(_ref3, "handler", function handler(range3) {
            var index2 = range3.index;
            if (key2 === Keyboard.keys.RIGHT) {
              index2 += range3.length + 1;
            }
            var _quill$getLeaf3 = this.quill.getLeaf(index2), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];
            if (!(leaf instanceof _parchment2.default.Embed))
              return true;
            if (key2 === Keyboard.keys.LEFT) {
              if (shiftKey) {
                this.quill.setSelection(range3.index - 1, range3.length + 1, _quill2.default.sources.USER);
              } else {
                this.quill.setSelection(range3.index - 1, _quill2.default.sources.USER);
              }
            } else {
              if (shiftKey) {
                this.quill.setSelection(range3.index, range3.length + 1, _quill2.default.sources.USER);
              } else {
                this.quill.setSelection(range3.index + range3.length + 1, _quill2.default.sources.USER);
              }
            }
            return false;
          }), _ref3;
        }
        function handleBackspace(range3, context) {
          if (range3.index === 0 || this.quill.getLength() <= 1)
            return;
          var _quill$getLine11 = this.quill.getLine(range3.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];
          var formats = {};
          if (context.offset === 0) {
            var _quill$getLine13 = this.quill.getLine(range3.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev = _quill$getLine14[0];
            if (prev != null && prev.length() > 1) {
              var curFormats = line.formats();
              var prevFormats = this.quill.getFormat(range3.index - 1, 1);
              formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
            }
          }
          var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
          this.quill.deleteText(range3.index - length, length, _quill2.default.sources.USER);
          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range3.index - length, length, formats, _quill2.default.sources.USER);
          }
          this.quill.focus();
        }
        function handleDelete(range3, context) {
          var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
          if (range3.index >= this.quill.getLength() - length)
            return;
          var formats = {}, nextLength = 0;
          var _quill$getLine15 = this.quill.getLine(range3.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];
          if (context.offset >= line.length() - 1) {
            var _quill$getLine17 = this.quill.getLine(range3.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next = _quill$getLine18[0];
            if (next) {
              var curFormats = line.formats();
              var nextFormats = this.quill.getFormat(range3.index, 1);
              formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
              nextLength = next.length();
            }
          }
          this.quill.deleteText(range3.index, length, _quill2.default.sources.USER);
          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range3.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
          }
        }
        function handleDeleteRange(range3) {
          var lines = this.quill.getLines(range3);
          var formats = {};
          if (lines.length > 1) {
            var firstFormats = lines[0].formats();
            var lastFormats = lines[lines.length - 1].formats();
            formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
          }
          this.quill.deleteText(range3, _quill2.default.sources.USER);
          if (Object.keys(formats).length > 0) {
            this.quill.formatLine(range3.index, 1, formats, _quill2.default.sources.USER);
          }
          this.quill.setSelection(range3.index, _quill2.default.sources.SILENT);
          this.quill.focus();
        }
        function handleEnter(range3, context) {
          var _this3 = this;
          if (range3.length > 0) {
            this.quill.scroll.deleteAt(range3.index, range3.length);
          }
          var lineFormats = Object.keys(context.format).reduce(function(lineFormats2, format2) {
            if (_parchment2.default.query(format2, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format2])) {
              lineFormats2[format2] = context.format[format2];
            }
            return lineFormats2;
          }, {});
          this.quill.insertText(range3.index, "\n", lineFormats, _quill2.default.sources.USER);
          this.quill.setSelection(range3.index + 1, _quill2.default.sources.SILENT);
          this.quill.focus();
          Object.keys(context.format).forEach(function(name) {
            if (lineFormats[name] != null)
              return;
            if (Array.isArray(context.format[name]))
              return;
            if (name === "link")
              return;
            _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
          });
        }
        function makeCodeBlockHandler(indent) {
          return {
            key: Keyboard.keys.TAB,
            shiftKey: !indent,
            format: { "code-block": true },
            handler: function handler(range3) {
              var CodeBlock = _parchment2.default.query("code-block");
              var index2 = range3.index, length = range3.length;
              var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index2), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
              if (block == null)
                return;
              var scrollIndex = this.quill.getIndex(block);
              var start2 = block.newlineIndex(offset2, true) + 1;
              var end2 = block.newlineIndex(scrollIndex + offset2 + length);
              var lines = block.domNode.textContent.slice(start2, end2).split("\n");
              offset2 = 0;
              lines.forEach(function(line, i) {
                if (indent) {
                  block.insertAt(start2 + offset2, CodeBlock.TAB);
                  offset2 += CodeBlock.TAB.length;
                  if (i === 0) {
                    index2 += CodeBlock.TAB.length;
                  } else {
                    length += CodeBlock.TAB.length;
                  }
                } else if (line.startsWith(CodeBlock.TAB)) {
                  block.deleteAt(start2 + offset2, CodeBlock.TAB.length);
                  offset2 -= CodeBlock.TAB.length;
                  if (i === 0) {
                    index2 -= CodeBlock.TAB.length;
                  } else {
                    length -= CodeBlock.TAB.length;
                  }
                }
                offset2 += line.length + 1;
              });
              this.quill.update(_quill2.default.sources.USER);
              this.quill.setSelection(index2, length, _quill2.default.sources.SILENT);
            }
          };
        }
        function makeFormatHandler(format2) {
          return {
            key: format2[0].toUpperCase(),
            shortKey: true,
            handler: function handler(range3, context) {
              this.quill.format(format2, !context.format[format2], _quill2.default.sources.USER);
            }
          };
        }
        function normalize(binding) {
          if (typeof binding === "string" || typeof binding === "number") {
            return normalize({ key: binding });
          }
          if ((typeof binding === "undefined" ? "undefined" : _typeof2(binding)) === "object") {
            binding = (0, _clone2.default)(binding, false);
          }
          if (typeof binding.key === "string") {
            if (Keyboard.keys[binding.key.toUpperCase()] != null) {
              binding.key = Keyboard.keys[binding.key.toUpperCase()];
            } else if (binding.key.length === 1) {
              binding.key = binding.key.toUpperCase().charCodeAt(0);
            } else {
              return null;
            }
          }
          if (binding.shortKey) {
            binding[SHORTKEY] = binding.shortKey;
            delete binding.shortKey;
          }
          return binding;
        }
        exports2.default = Keyboard;
        exports2.SHORTKEY = SHORTKEY;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Cursor = function(_Parchment$Embed) {
          _inherits(Cursor2, _Parchment$Embed);
          _createClass(Cursor2, null, [{
            key: "value",
            value: function value() {
              return void 0;
            }
          }]);
          function Cursor2(domNode, selection) {
            _classCallCheck(this, Cursor2);
            var _this = _possibleConstructorReturn(this, (Cursor2.__proto__ || Object.getPrototypeOf(Cursor2)).call(this, domNode));
            _this.selection = selection;
            _this.textNode = document.createTextNode(Cursor2.CONTENTS);
            _this.domNode.appendChild(_this.textNode);
            _this._length = 0;
            return _this;
          }
          _createClass(Cursor2, [{
            key: "detach",
            value: function detach() {
              if (this.parent != null)
                this.parent.removeChild(this);
            }
          }, {
            key: "format",
            value: function format2(name, value) {
              if (this._length !== 0) {
                return _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "format", this).call(this, name, value);
              }
              var target = this, index2 = 0;
              while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
                index2 += target.offset(target.parent);
                target = target.parent;
              }
              if (target != null) {
                this._length = Cursor2.CONTENTS.length;
                target.optimize();
                target.formatAt(index2, Cursor2.CONTENTS.length, name, value);
                this._length = 0;
              }
            }
          }, {
            key: "index",
            value: function index2(node, offset2) {
              if (node === this.textNode)
                return 0;
              return _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "index", this).call(this, node, offset2);
            }
          }, {
            key: "length",
            value: function length() {
              return this._length;
            }
          }, {
            key: "position",
            value: function position() {
              return [this.textNode, this.textNode.data.length];
            }
          }, {
            key: "remove",
            value: function remove2() {
              _get(Cursor2.prototype.__proto__ || Object.getPrototypeOf(Cursor2.prototype), "remove", this).call(this);
              this.parent = null;
            }
          }, {
            key: "restore",
            value: function restore() {
              if (this.selection.composing || this.parent == null)
                return;
              var textNode = this.textNode;
              var range3 = this.selection.getNativeRange();
              var restoreText = void 0, start2 = void 0, end2 = void 0;
              if (range3 != null && range3.start.node === textNode && range3.end.node === textNode) {
                var _ref = [textNode, range3.start.offset, range3.end.offset];
                restoreText = _ref[0];
                start2 = _ref[1];
                end2 = _ref[2];
              }
              while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
              }
              if (this.textNode.data !== Cursor2.CONTENTS) {
                var text = this.textNode.data.split(Cursor2.CONTENTS).join("");
                if (this.next instanceof _text2.default) {
                  restoreText = this.next.domNode;
                  this.next.insertAt(0, text);
                  this.textNode.data = Cursor2.CONTENTS;
                } else {
                  this.textNode.data = text;
                  this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
                  this.textNode = document.createTextNode(Cursor2.CONTENTS);
                  this.domNode.appendChild(this.textNode);
                }
              }
              this.remove();
              if (start2 != null) {
                var _map = [start2, end2].map(function(offset2) {
                  return Math.max(0, Math.min(restoreText.data.length, offset2 - 1));
                });
                var _map2 = _slicedToArray(_map, 2);
                start2 = _map2[0];
                end2 = _map2[1];
                return {
                  startNode: restoreText,
                  startOffset: start2,
                  endNode: restoreText,
                  endOffset: end2
                };
              }
            }
          }, {
            key: "update",
            value: function update(mutations, context) {
              var _this2 = this;
              if (mutations.some(function(mutation) {
                return mutation.type === "characterData" && mutation.target === _this2.textNode;
              })) {
                var range3 = this.restore();
                if (range3)
                  context.range = range3;
              }
            }
          }, {
            key: "value",
            value: function value() {
              return "";
            }
          }]);
          return Cursor2;
        }(_parchment2.default.Embed);
        Cursor.blotName = "cursor";
        Cursor.className = "ql-cursor";
        Cursor.tagName = "span";
        Cursor.CONTENTS = "\uFEFF";
        exports2.default = Cursor;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Container = function(_Parchment$Container) {
          _inherits(Container2, _Parchment$Container);
          function Container2() {
            _classCallCheck(this, Container2);
            return _possibleConstructorReturn(this, (Container2.__proto__ || Object.getPrototypeOf(Container2)).apply(this, arguments));
          }
          return Container2;
        }(_parchment2.default.Container);
        Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];
        exports2.default = Container;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.ColorStyle = exports2.ColorClass = exports2.ColorAttributor = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ColorAttributor = function(_Parchment$Attributor) {
          _inherits(ColorAttributor2, _Parchment$Attributor);
          function ColorAttributor2() {
            _classCallCheck(this, ColorAttributor2);
            return _possibleConstructorReturn(this, (ColorAttributor2.__proto__ || Object.getPrototypeOf(ColorAttributor2)).apply(this, arguments));
          }
          _createClass(ColorAttributor2, [{
            key: "value",
            value: function value(domNode) {
              var value2 = _get(ColorAttributor2.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor2.prototype), "value", this).call(this, domNode);
              if (!value2.startsWith("rgb("))
                return value2;
              value2 = value2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
              return "#" + value2.split(",").map(function(component) {
                return ("00" + parseInt(component).toString(16)).slice(-2);
              }).join("");
            }
          }]);
          return ColorAttributor2;
        }(_parchment2.default.Attributor.Style);
        var ColorClass = new _parchment2.default.Attributor.Class("color", "ql-color", {
          scope: _parchment2.default.Scope.INLINE
        });
        var ColorStyle = new ColorAttributor("color", "color", {
          scope: _parchment2.default.Scope.INLINE
        });
        exports2.ColorAttributor = ColorAttributor;
        exports2.ColorClass = ColorClass;
        exports2.ColorStyle = ColorStyle;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.sanitize = exports2.default = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Link = function(_Inline) {
          _inherits(Link2, _Inline);
          function Link2() {
            _classCallCheck(this, Link2);
            return _possibleConstructorReturn(this, (Link2.__proto__ || Object.getPrototypeOf(Link2)).apply(this, arguments));
          }
          _createClass(Link2, [{
            key: "format",
            value: function format2(name, value) {
              if (name !== this.statics.blotName || !value)
                return _get(Link2.prototype.__proto__ || Object.getPrototypeOf(Link2.prototype), "format", this).call(this, name, value);
              value = this.constructor.sanitize(value);
              this.domNode.setAttribute("href", value);
            }
          }], [{
            key: "create",
            value: function create(value) {
              var node = _get(Link2.__proto__ || Object.getPrototypeOf(Link2), "create", this).call(this, value);
              value = this.sanitize(value);
              node.setAttribute("href", value);
              node.setAttribute("rel", "noopener noreferrer");
              node.setAttribute("target", "_blank");
              return node;
            }
          }, {
            key: "formats",
            value: function formats(domNode) {
              return domNode.getAttribute("href");
            }
          }, {
            key: "sanitize",
            value: function sanitize(url2) {
              return _sanitize(url2, this.PROTOCOL_WHITELIST) ? url2 : this.SANITIZED_URL;
            }
          }]);
          return Link2;
        }(_inline2.default);
        Link.blotName = "link";
        Link.tagName = "A";
        Link.SANITIZED_URL = "about:blank";
        Link.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"];
        function _sanitize(url2, protocols) {
          var anchor = document.createElement("a");
          anchor.href = url2;
          var protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
          return protocols.indexOf(protocol) > -1;
        }
        exports2.default = Link;
        exports2.sanitize = _sanitize;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _keyboard = __webpack_require__(23);
        var _keyboard2 = _interopRequireDefault(_keyboard);
        var _dropdown = __webpack_require__(107);
        var _dropdown2 = _interopRequireDefault(_dropdown);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var optionsCounter = 0;
        function toggleAriaAttribute(element, attribute) {
          element.setAttribute(attribute, !(element.getAttribute(attribute) === "true"));
        }
        var Picker = function() {
          function Picker2(select) {
            var _this = this;
            _classCallCheck(this, Picker2);
            this.select = select;
            this.container = document.createElement("span");
            this.buildPicker();
            this.select.style.display = "none";
            this.select.parentNode.insertBefore(this.container, this.select);
            this.label.addEventListener("mousedown", function() {
              _this.togglePicker();
            });
            this.label.addEventListener("keydown", function(event) {
              switch (event.keyCode) {
                case _keyboard2.default.keys.ENTER:
                  _this.togglePicker();
                  break;
                case _keyboard2.default.keys.ESCAPE:
                  _this.escape();
                  event.preventDefault();
                  break;
              }
            });
            this.select.addEventListener("change", this.update.bind(this));
          }
          _createClass(Picker2, [{
            key: "togglePicker",
            value: function togglePicker() {
              this.container.classList.toggle("ql-expanded");
              toggleAriaAttribute(this.label, "aria-expanded");
              toggleAriaAttribute(this.options, "aria-hidden");
            }
          }, {
            key: "buildItem",
            value: function buildItem(option2) {
              var _this2 = this;
              var item = document.createElement("span");
              item.tabIndex = "0";
              item.setAttribute("role", "button");
              item.classList.add("ql-picker-item");
              if (option2.hasAttribute("value")) {
                item.setAttribute("data-value", option2.getAttribute("value"));
              }
              if (option2.textContent) {
                item.setAttribute("data-label", option2.textContent);
              }
              item.addEventListener("click", function() {
                _this2.selectItem(item, true);
              });
              item.addEventListener("keydown", function(event) {
                switch (event.keyCode) {
                  case _keyboard2.default.keys.ENTER:
                    _this2.selectItem(item, true);
                    event.preventDefault();
                    break;
                  case _keyboard2.default.keys.ESCAPE:
                    _this2.escape();
                    event.preventDefault();
                    break;
                }
              });
              return item;
            }
          }, {
            key: "buildLabel",
            value: function buildLabel() {
              var label2 = document.createElement("span");
              label2.classList.add("ql-picker-label");
              label2.innerHTML = _dropdown2.default;
              label2.tabIndex = "0";
              label2.setAttribute("role", "button");
              label2.setAttribute("aria-expanded", "false");
              this.container.appendChild(label2);
              return label2;
            }
          }, {
            key: "buildOptions",
            value: function buildOptions() {
              var _this3 = this;
              var options2 = document.createElement("span");
              options2.classList.add("ql-picker-options");
              options2.setAttribute("aria-hidden", "true");
              options2.tabIndex = "-1";
              options2.id = "ql-picker-options-" + optionsCounter;
              optionsCounter += 1;
              this.label.setAttribute("aria-controls", options2.id);
              this.options = options2;
              [].slice.call(this.select.options).forEach(function(option2) {
                var item = _this3.buildItem(option2);
                options2.appendChild(item);
                if (option2.selected === true) {
                  _this3.selectItem(item);
                }
              });
              this.container.appendChild(options2);
            }
          }, {
            key: "buildPicker",
            value: function buildPicker() {
              var _this4 = this;
              [].slice.call(this.select.attributes).forEach(function(item) {
                _this4.container.setAttribute(item.name, item.value);
              });
              this.container.classList.add("ql-picker");
              this.label = this.buildLabel();
              this.buildOptions();
            }
          }, {
            key: "escape",
            value: function escape() {
              var _this5 = this;
              this.close();
              setTimeout(function() {
                return _this5.label.focus();
              }, 1);
            }
          }, {
            key: "close",
            value: function close2() {
              this.container.classList.remove("ql-expanded");
              this.label.setAttribute("aria-expanded", "false");
              this.options.setAttribute("aria-hidden", "true");
            }
          }, {
            key: "selectItem",
            value: function selectItem(item) {
              var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var selected = this.container.querySelector(".ql-selected");
              if (item === selected)
                return;
              if (selected != null) {
                selected.classList.remove("ql-selected");
              }
              if (item == null)
                return;
              item.classList.add("ql-selected");
              this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
              if (item.hasAttribute("data-value")) {
                this.label.setAttribute("data-value", item.getAttribute("data-value"));
              } else {
                this.label.removeAttribute("data-value");
              }
              if (item.hasAttribute("data-label")) {
                this.label.setAttribute("data-label", item.getAttribute("data-label"));
              } else {
                this.label.removeAttribute("data-label");
              }
              if (trigger) {
                if (typeof Event === "function") {
                  this.select.dispatchEvent(new Event("change"));
                } else if ((typeof Event === "undefined" ? "undefined" : _typeof2(Event)) === "object") {
                  var event = document.createEvent("Event");
                  event.initEvent("change", true, true);
                  this.select.dispatchEvent(event);
                }
                this.close();
              }
            }
          }, {
            key: "update",
            value: function update() {
              var option2 = void 0;
              if (this.select.selectedIndex > -1) {
                var item = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                option2 = this.select.options[this.select.selectedIndex];
                this.selectItem(item);
              } else {
                this.selectItem(null);
              }
              var isActive = option2 != null && option2 !== this.select.querySelector("option[selected]");
              this.label.classList.toggle("ql-active", isActive);
            }
          }]);
          return Picker2;
        }();
        exports2.default = Picker;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        var _break = __webpack_require__(16);
        var _break2 = _interopRequireDefault(_break);
        var _container = __webpack_require__(25);
        var _container2 = _interopRequireDefault(_container);
        var _cursor = __webpack_require__(24);
        var _cursor2 = _interopRequireDefault(_cursor);
        var _embed = __webpack_require__(35);
        var _embed2 = _interopRequireDefault(_embed);
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        var _scroll = __webpack_require__(22);
        var _scroll2 = _interopRequireDefault(_scroll);
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        var _clipboard = __webpack_require__(55);
        var _clipboard2 = _interopRequireDefault(_clipboard);
        var _history = __webpack_require__(42);
        var _history2 = _interopRequireDefault(_history);
        var _keyboard = __webpack_require__(23);
        var _keyboard2 = _interopRequireDefault(_keyboard);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        _quill2.default.register({
          "blots/block": _block2.default,
          "blots/block/embed": _block.BlockEmbed,
          "blots/break": _break2.default,
          "blots/container": _container2.default,
          "blots/cursor": _cursor2.default,
          "blots/embed": _embed2.default,
          "blots/inline": _inline2.default,
          "blots/scroll": _scroll2.default,
          "blots/text": _text2.default,
          "modules/clipboard": _clipboard2.default,
          "modules/history": _history2.default,
          "modules/keyboard": _keyboard2.default
        });
        _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);
        exports2.default = _quill2.default;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Registry = __webpack_require__(1);
        var ShadowBlot = function() {
          function ShadowBlot2(domNode) {
            this.domNode = domNode;
            this.domNode[Registry.DATA_KEY] = { blot: this };
          }
          Object.defineProperty(ShadowBlot2.prototype, "statics", {
            get: function() {
              return this.constructor;
            },
            enumerable: true,
            configurable: true
          });
          ShadowBlot2.create = function(value) {
            if (this.tagName == null) {
              throw new Registry.ParchmentError("Blot definition missing tagName");
            }
            var node;
            if (Array.isArray(this.tagName)) {
              if (typeof value === "string") {
                value = value.toUpperCase();
                if (parseInt(value).toString() === value) {
                  value = parseInt(value);
                }
              }
              if (typeof value === "number") {
                node = document.createElement(this.tagName[value - 1]);
              } else if (this.tagName.indexOf(value) > -1) {
                node = document.createElement(value);
              } else {
                node = document.createElement(this.tagName[0]);
              }
            } else {
              node = document.createElement(this.tagName);
            }
            if (this.className) {
              node.classList.add(this.className);
            }
            return node;
          };
          ShadowBlot2.prototype.attach = function() {
            if (this.parent != null) {
              this.scroll = this.parent.scroll;
            }
          };
          ShadowBlot2.prototype.clone = function() {
            var domNode = this.domNode.cloneNode(false);
            return Registry.create(domNode);
          };
          ShadowBlot2.prototype.detach = function() {
            if (this.parent != null)
              this.parent.removeChild(this);
            delete this.domNode[Registry.DATA_KEY];
          };
          ShadowBlot2.prototype.deleteAt = function(index2, length) {
            var blot = this.isolate(index2, length);
            blot.remove();
          };
          ShadowBlot2.prototype.formatAt = function(index2, length, name, value) {
            var blot = this.isolate(index2, length);
            if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
              blot.wrap(name, value);
            } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
              var parent = Registry.create(this.statics.scope);
              blot.wrap(parent);
              parent.format(name, value);
            }
          };
          ShadowBlot2.prototype.insertAt = function(index2, value, def) {
            var blot = def == null ? Registry.create("text", value) : Registry.create(value, def);
            var ref2 = this.split(index2);
            this.parent.insertBefore(blot, ref2);
          };
          ShadowBlot2.prototype.insertInto = function(parentBlot, refBlot) {
            if (refBlot === void 0) {
              refBlot = null;
            }
            if (this.parent != null) {
              this.parent.children.remove(this);
            }
            var refDomNode = null;
            parentBlot.children.insertBefore(this, refBlot);
            if (refBlot != null) {
              refDomNode = refBlot.domNode;
            }
            if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {
              parentBlot.domNode.insertBefore(this.domNode, refDomNode);
            }
            this.parent = parentBlot;
            this.attach();
          };
          ShadowBlot2.prototype.isolate = function(index2, length) {
            var target = this.split(index2);
            target.split(length);
            return target;
          };
          ShadowBlot2.prototype.length = function() {
            return 1;
          };
          ShadowBlot2.prototype.offset = function(root2) {
            if (root2 === void 0) {
              root2 = this.parent;
            }
            if (this.parent == null || this == root2)
              return 0;
            return this.parent.children.offset(this) + this.parent.offset(root2);
          };
          ShadowBlot2.prototype.optimize = function(context) {
            if (this.domNode[Registry.DATA_KEY] != null) {
              delete this.domNode[Registry.DATA_KEY].mutations;
            }
          };
          ShadowBlot2.prototype.remove = function() {
            if (this.domNode.parentNode != null) {
              this.domNode.parentNode.removeChild(this.domNode);
            }
            this.detach();
          };
          ShadowBlot2.prototype.replace = function(target) {
            if (target.parent == null)
              return;
            target.parent.insertBefore(this, target.next);
            target.remove();
          };
          ShadowBlot2.prototype.replaceWith = function(name, value) {
            var replacement = typeof name === "string" ? Registry.create(name, value) : name;
            replacement.replace(this);
            return replacement;
          };
          ShadowBlot2.prototype.split = function(index2, force) {
            return index2 === 0 ? this : this.next;
          };
          ShadowBlot2.prototype.update = function(mutations, context) {
          };
          ShadowBlot2.prototype.wrap = function(name, value) {
            var wrapper = typeof name === "string" ? Registry.create(name, value) : name;
            if (this.parent != null) {
              this.parent.insertBefore(wrapper, this.next);
            }
            wrapper.appendChild(this);
            return wrapper;
          };
          ShadowBlot2.blotName = "abstract";
          return ShadowBlot2;
        }();
        exports2.default = ShadowBlot;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var attributor_1 = __webpack_require__(12);
        var class_1 = __webpack_require__(32);
        var style_1 = __webpack_require__(33);
        var Registry = __webpack_require__(1);
        var AttributorStore = function() {
          function AttributorStore2(domNode) {
            this.attributes = {};
            this.domNode = domNode;
            this.build();
          }
          AttributorStore2.prototype.attribute = function(attribute, value) {
            if (value) {
              if (attribute.add(this.domNode, value)) {
                if (attribute.value(this.domNode) != null) {
                  this.attributes[attribute.attrName] = attribute;
                } else {
                  delete this.attributes[attribute.attrName];
                }
              }
            } else {
              attribute.remove(this.domNode);
              delete this.attributes[attribute.attrName];
            }
          };
          AttributorStore2.prototype.build = function() {
            var _this = this;
            this.attributes = {};
            var attributes = attributor_1.default.keys(this.domNode);
            var classes = class_1.default.keys(this.domNode);
            var styles = style_1.default.keys(this.domNode);
            attributes.concat(classes).concat(styles).forEach(function(name) {
              var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
              if (attr instanceof attributor_1.default) {
                _this.attributes[attr.attrName] = attr;
              }
            });
          };
          AttributorStore2.prototype.copy = function(target) {
            var _this = this;
            Object.keys(this.attributes).forEach(function(key2) {
              var value = _this.attributes[key2].value(_this.domNode);
              target.format(key2, value);
            });
          };
          AttributorStore2.prototype.move = function(target) {
            var _this = this;
            this.copy(target);
            Object.keys(this.attributes).forEach(function(key2) {
              _this.attributes[key2].remove(_this.domNode);
            });
            this.attributes = {};
          };
          AttributorStore2.prototype.values = function() {
            var _this = this;
            return Object.keys(this.attributes).reduce(function(attributes, name) {
              attributes[name] = _this.attributes[name].value(_this.domNode);
              return attributes;
            }, {});
          };
          return AttributorStore2;
        }();
        exports2.default = AttributorStore;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var attributor_1 = __webpack_require__(12);
        function match(node, prefix) {
          var className = node.getAttribute("class") || "";
          return className.split(/\s+/).filter(function(name) {
            return name.indexOf(prefix + "-") === 0;
          });
        }
        var ClassAttributor = function(_super) {
          __extends(ClassAttributor2, _super);
          function ClassAttributor2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ClassAttributor2.keys = function(node) {
            return (node.getAttribute("class") || "").split(/\s+/).map(function(name) {
              return name.split("-").slice(0, -1).join("-");
            });
          };
          ClassAttributor2.prototype.add = function(node, value) {
            if (!this.canAdd(node, value))
              return false;
            this.remove(node);
            node.classList.add(this.keyName + "-" + value);
            return true;
          };
          ClassAttributor2.prototype.remove = function(node) {
            var matches2 = match(node, this.keyName);
            matches2.forEach(function(name) {
              node.classList.remove(name);
            });
            if (node.classList.length === 0) {
              node.removeAttribute("class");
            }
          };
          ClassAttributor2.prototype.value = function(node) {
            var result = match(node, this.keyName)[0] || "";
            var value = result.slice(this.keyName.length + 1);
            return this.canAdd(node, value) ? value : "";
          };
          return ClassAttributor2;
        }(attributor_1.default);
        exports2.default = ClassAttributor;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var attributor_1 = __webpack_require__(12);
        function camelize2(name) {
          var parts = name.split("-");
          var rest = parts.slice(1).map(function(part) {
            return part[0].toUpperCase() + part.slice(1);
          }).join("");
          return parts[0] + rest;
        }
        var StyleAttributor = function(_super) {
          __extends(StyleAttributor2, _super);
          function StyleAttributor2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          StyleAttributor2.keys = function(node) {
            return (node.getAttribute("style") || "").split(";").map(function(value) {
              var arr = value.split(":");
              return arr[0].trim();
            });
          };
          StyleAttributor2.prototype.add = function(node, value) {
            if (!this.canAdd(node, value))
              return false;
            node.style[camelize2(this.keyName)] = value;
            return true;
          };
          StyleAttributor2.prototype.remove = function(node) {
            node.style[camelize2(this.keyName)] = "";
            if (!node.getAttribute("style")) {
              node.removeAttribute("style");
            }
          };
          StyleAttributor2.prototype.value = function(node) {
            var value = node.style[camelize2(this.keyName)];
            return this.canAdd(node, value) ? value : "";
          };
          return StyleAttributor2;
        }(attributor_1.default);
        exports2.default = StyleAttributor;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Theme = function() {
          function Theme2(quill2, options2) {
            _classCallCheck(this, Theme2);
            this.quill = quill2;
            this.options = options2;
            this.modules = {};
          }
          _createClass(Theme2, [{
            key: "init",
            value: function init() {
              var _this = this;
              Object.keys(this.options.modules).forEach(function(name) {
                if (_this.modules[name] == null) {
                  _this.addModule(name);
                }
              });
            }
          }, {
            key: "addModule",
            value: function addModule(name) {
              var moduleClass = this.quill.constructor.import("modules/" + name);
              this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
              return this.modules[name];
            }
          }]);
          return Theme2;
        }();
        Theme.DEFAULTS = {
          modules: {}
        };
        Theme.themes = {
          "default": Theme
        };
        exports2.default = Theme;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _text = __webpack_require__(7);
        var _text2 = _interopRequireDefault(_text);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var GUARD_TEXT = "\uFEFF";
        var Embed = function(_Parchment$Embed) {
          _inherits(Embed2, _Parchment$Embed);
          function Embed2(node) {
            _classCallCheck(this, Embed2);
            var _this = _possibleConstructorReturn(this, (Embed2.__proto__ || Object.getPrototypeOf(Embed2)).call(this, node));
            _this.contentNode = document.createElement("span");
            _this.contentNode.setAttribute("contenteditable", false);
            [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {
              _this.contentNode.appendChild(childNode);
            });
            _this.leftGuard = document.createTextNode(GUARD_TEXT);
            _this.rightGuard = document.createTextNode(GUARD_TEXT);
            _this.domNode.appendChild(_this.leftGuard);
            _this.domNode.appendChild(_this.contentNode);
            _this.domNode.appendChild(_this.rightGuard);
            return _this;
          }
          _createClass(Embed2, [{
            key: "index",
            value: function index2(node, offset2) {
              if (node === this.leftGuard)
                return 0;
              if (node === this.rightGuard)
                return 1;
              return _get(Embed2.prototype.__proto__ || Object.getPrototypeOf(Embed2.prototype), "index", this).call(this, node, offset2);
            }
          }, {
            key: "restore",
            value: function restore(node) {
              var range3 = void 0, textNode = void 0;
              var text = node.data.split(GUARD_TEXT).join("");
              if (node === this.leftGuard) {
                if (this.prev instanceof _text2.default) {
                  var prevLength = this.prev.length();
                  this.prev.insertAt(prevLength, text);
                  range3 = {
                    startNode: this.prev.domNode,
                    startOffset: prevLength + text.length
                  };
                } else {
                  textNode = document.createTextNode(text);
                  this.parent.insertBefore(_parchment2.default.create(textNode), this);
                  range3 = {
                    startNode: textNode,
                    startOffset: text.length
                  };
                }
              } else if (node === this.rightGuard) {
                if (this.next instanceof _text2.default) {
                  this.next.insertAt(0, text);
                  range3 = {
                    startNode: this.next.domNode,
                    startOffset: text.length
                  };
                } else {
                  textNode = document.createTextNode(text);
                  this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
                  range3 = {
                    startNode: textNode,
                    startOffset: text.length
                  };
                }
              }
              node.data = GUARD_TEXT;
              return range3;
            }
          }, {
            key: "update",
            value: function update(mutations, context) {
              var _this2 = this;
              mutations.forEach(function(mutation) {
                if (mutation.type === "characterData" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
                  var range3 = _this2.restore(mutation.target);
                  if (range3)
                    context.range = range3;
                }
              });
            }
          }]);
          return Embed2;
        }(_parchment2.default.Embed);
        exports2.default = Embed;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.AlignStyle = exports2.AlignClass = exports2.AlignAttribute = void 0;
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var config = {
          scope: _parchment2.default.Scope.BLOCK,
          whitelist: ["right", "center", "justify"]
        };
        var AlignAttribute = new _parchment2.default.Attributor.Attribute("align", "align", config);
        var AlignClass = new _parchment2.default.Attributor.Class("align", "ql-align", config);
        var AlignStyle = new _parchment2.default.Attributor.Style("align", "text-align", config);
        exports2.AlignAttribute = AlignAttribute;
        exports2.AlignClass = AlignClass;
        exports2.AlignStyle = AlignStyle;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.BackgroundStyle = exports2.BackgroundClass = void 0;
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _color = __webpack_require__(26);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var BackgroundClass = new _parchment2.default.Attributor.Class("background", "ql-bg", {
          scope: _parchment2.default.Scope.INLINE
        });
        var BackgroundStyle = new _color.ColorAttributor("background", "background-color", {
          scope: _parchment2.default.Scope.INLINE
        });
        exports2.BackgroundClass = BackgroundClass;
        exports2.BackgroundStyle = BackgroundStyle;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.DirectionStyle = exports2.DirectionClass = exports2.DirectionAttribute = void 0;
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var config = {
          scope: _parchment2.default.Scope.BLOCK,
          whitelist: ["rtl"]
        };
        var DirectionAttribute = new _parchment2.default.Attributor.Attribute("direction", "dir", config);
        var DirectionClass = new _parchment2.default.Attributor.Class("direction", "ql-direction", config);
        var DirectionStyle = new _parchment2.default.Attributor.Style("direction", "direction", config);
        exports2.DirectionAttribute = DirectionAttribute;
        exports2.DirectionClass = DirectionClass;
        exports2.DirectionStyle = DirectionStyle;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.FontClass = exports2.FontStyle = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var config = {
          scope: _parchment2.default.Scope.INLINE,
          whitelist: ["serif", "monospace"]
        };
        var FontClass = new _parchment2.default.Attributor.Class("font", "ql-font", config);
        var FontStyleAttributor = function(_Parchment$Attributor) {
          _inherits(FontStyleAttributor2, _Parchment$Attributor);
          function FontStyleAttributor2() {
            _classCallCheck(this, FontStyleAttributor2);
            return _possibleConstructorReturn(this, (FontStyleAttributor2.__proto__ || Object.getPrototypeOf(FontStyleAttributor2)).apply(this, arguments));
          }
          _createClass(FontStyleAttributor2, [{
            key: "value",
            value: function value(node) {
              return _get(FontStyleAttributor2.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor2.prototype), "value", this).call(this, node).replace(/["']/g, "");
            }
          }]);
          return FontStyleAttributor2;
        }(_parchment2.default.Attributor.Style);
        var FontStyle = new FontStyleAttributor("font", "font-family", config);
        exports2.FontStyle = FontStyle;
        exports2.FontClass = FontClass;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.SizeStyle = exports2.SizeClass = void 0;
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        var SizeClass = new _parchment2.default.Attributor.Class("size", "ql-size", {
          scope: _parchment2.default.Scope.INLINE,
          whitelist: ["small", "large", "huge"]
        });
        var SizeStyle = new _parchment2.default.Attributor.Style("size", "font-size", {
          scope: _parchment2.default.Scope.INLINE,
          whitelist: ["10px", "18px", "32px"]
        });
        exports2.SizeClass = SizeClass;
        exports2.SizeStyle = SizeStyle;
      },
      function(module2, exports2, __webpack_require__) {
        module2.exports = {
          "align": {
            "": __webpack_require__(76),
            "center": __webpack_require__(77),
            "right": __webpack_require__(78),
            "justify": __webpack_require__(79)
          },
          "background": __webpack_require__(80),
          "blockquote": __webpack_require__(81),
          "bold": __webpack_require__(82),
          "clean": __webpack_require__(83),
          "code": __webpack_require__(58),
          "code-block": __webpack_require__(58),
          "color": __webpack_require__(84),
          "direction": {
            "": __webpack_require__(85),
            "rtl": __webpack_require__(86)
          },
          "float": {
            "center": __webpack_require__(87),
            "full": __webpack_require__(88),
            "left": __webpack_require__(89),
            "right": __webpack_require__(90)
          },
          "formula": __webpack_require__(91),
          "header": {
            "1": __webpack_require__(92),
            "2": __webpack_require__(93)
          },
          "italic": __webpack_require__(94),
          "image": __webpack_require__(95),
          "indent": {
            "+1": __webpack_require__(96),
            "-1": __webpack_require__(97)
          },
          "link": __webpack_require__(98),
          "list": {
            "ordered": __webpack_require__(99),
            "bullet": __webpack_require__(100),
            "check": __webpack_require__(101)
          },
          "script": {
            "sub": __webpack_require__(102),
            "super": __webpack_require__(103)
          },
          "strike": __webpack_require__(104),
          "underline": __webpack_require__(105),
          "video": __webpack_require__(106)
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.getLastChangeIndex = exports2.default = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var History = function(_Module) {
          _inherits(History2, _Module);
          function History2(quill2, options2) {
            _classCallCheck(this, History2);
            var _this = _possibleConstructorReturn(this, (History2.__proto__ || Object.getPrototypeOf(History2)).call(this, quill2, options2));
            _this.lastRecorded = 0;
            _this.ignoreChange = false;
            _this.clear();
            _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {
              if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange)
                return;
              if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
                _this.record(delta, oldDelta);
              } else {
                _this.transform(delta);
              }
            });
            _this.quill.keyboard.addBinding({ key: "Z", shortKey: true }, _this.undo.bind(_this));
            _this.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, _this.redo.bind(_this));
            if (/Win/i.test(navigator.platform)) {
              _this.quill.keyboard.addBinding({ key: "Y", shortKey: true }, _this.redo.bind(_this));
            }
            return _this;
          }
          _createClass(History2, [{
            key: "change",
            value: function change(source, dest) {
              if (this.stack[source].length === 0)
                return;
              var delta = this.stack[source].pop();
              this.stack[dest].push(delta);
              this.lastRecorded = 0;
              this.ignoreChange = true;
              this.quill.updateContents(delta[source], _quill2.default.sources.USER);
              this.ignoreChange = false;
              var index2 = getLastChangeIndex(delta[source]);
              this.quill.setSelection(index2);
            }
          }, {
            key: "clear",
            value: function clear() {
              this.stack = { undo: [], redo: [] };
            }
          }, {
            key: "cutoff",
            value: function cutoff() {
              this.lastRecorded = 0;
            }
          }, {
            key: "record",
            value: function record(changeDelta, oldDelta) {
              if (changeDelta.ops.length === 0)
                return;
              this.stack.redo = [];
              var undoDelta = this.quill.getContents().diff(oldDelta);
              var timestamp = Date.now();
              if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
                var delta = this.stack.undo.pop();
                undoDelta = undoDelta.compose(delta.undo);
                changeDelta = delta.redo.compose(changeDelta);
              } else {
                this.lastRecorded = timestamp;
              }
              this.stack.undo.push({
                redo: changeDelta,
                undo: undoDelta
              });
              if (this.stack.undo.length > this.options.maxStack) {
                this.stack.undo.shift();
              }
            }
          }, {
            key: "redo",
            value: function redo() {
              this.change("redo", "undo");
            }
          }, {
            key: "transform",
            value: function transform(delta) {
              this.stack.undo.forEach(function(change) {
                change.undo = delta.transform(change.undo, true);
                change.redo = delta.transform(change.redo, true);
              });
              this.stack.redo.forEach(function(change) {
                change.undo = delta.transform(change.undo, true);
                change.redo = delta.transform(change.redo, true);
              });
            }
          }, {
            key: "undo",
            value: function undo() {
              this.change("undo", "redo");
            }
          }]);
          return History2;
        }(_module2.default);
        History.DEFAULTS = {
          delay: 1e3,
          maxStack: 100,
          userOnly: false
        };
        function endsWithNewlineChange(delta) {
          var lastOp = delta.ops[delta.ops.length - 1];
          if (lastOp == null)
            return false;
          if (lastOp.insert != null) {
            return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
          }
          if (lastOp.attributes != null) {
            return Object.keys(lastOp.attributes).some(function(attr) {
              return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
            });
          }
          return false;
        }
        function getLastChangeIndex(delta) {
          var deleteLength = delta.reduce(function(length, op) {
            length += op.delete || 0;
            return length;
          }, 0);
          var changeIndex = delta.length() - deleteLength;
          if (endsWithNewlineChange(delta)) {
            changeIndex -= 1;
          }
          return changeIndex;
        }
        exports2.default = History;
        exports2.getLastChangeIndex = getLastChangeIndex;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.BaseTooltip = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _emitter = __webpack_require__(8);
        var _emitter2 = _interopRequireDefault(_emitter);
        var _keyboard = __webpack_require__(23);
        var _keyboard2 = _interopRequireDefault(_keyboard);
        var _theme = __webpack_require__(34);
        var _theme2 = _interopRequireDefault(_theme);
        var _colorPicker = __webpack_require__(59);
        var _colorPicker2 = _interopRequireDefault(_colorPicker);
        var _iconPicker = __webpack_require__(60);
        var _iconPicker2 = _interopRequireDefault(_iconPicker);
        var _picker = __webpack_require__(28);
        var _picker2 = _interopRequireDefault(_picker);
        var _tooltip = __webpack_require__(61);
        var _tooltip2 = _interopRequireDefault(_tooltip);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ALIGNS = [false, "center", "right", "justify"];
        var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
        var FONTS = [false, "serif", "monospace"];
        var HEADERS = ["1", "2", "3", false];
        var SIZES = ["small", false, "large", "huge"];
        var BaseTheme = function(_Theme) {
          _inherits(BaseTheme2, _Theme);
          function BaseTheme2(quill2, options2) {
            _classCallCheck(this, BaseTheme2);
            var _this = _possibleConstructorReturn(this, (BaseTheme2.__proto__ || Object.getPrototypeOf(BaseTheme2)).call(this, quill2, options2));
            var listener = function listener2(e) {
              if (!document.body.contains(quill2.root)) {
                return document.body.removeEventListener("click", listener2);
              }
              if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
                _this.tooltip.hide();
              }
              if (_this.pickers != null) {
                _this.pickers.forEach(function(picker) {
                  if (!picker.container.contains(e.target)) {
                    picker.close();
                  }
                });
              }
            };
            quill2.emitter.listenDOM("click", document.body, listener);
            return _this;
          }
          _createClass(BaseTheme2, [{
            key: "addModule",
            value: function addModule(name) {
              var module3 = _get(BaseTheme2.prototype.__proto__ || Object.getPrototypeOf(BaseTheme2.prototype), "addModule", this).call(this, name);
              if (name === "toolbar") {
                this.extendToolbar(module3);
              }
              return module3;
            }
          }, {
            key: "buildButtons",
            value: function buildButtons(buttons, icons) {
              buttons.forEach(function(button) {
                var className = button.getAttribute("class") || "";
                className.split(/\s+/).forEach(function(name) {
                  if (!name.startsWith("ql-"))
                    return;
                  name = name.slice("ql-".length);
                  if (icons[name] == null)
                    return;
                  if (name === "direction") {
                    button.innerHTML = icons[name][""] + icons[name]["rtl"];
                  } else if (typeof icons[name] === "string") {
                    button.innerHTML = icons[name];
                  } else {
                    var value = button.value || "";
                    if (value != null && icons[name][value]) {
                      button.innerHTML = icons[name][value];
                    }
                  }
                });
              });
            }
          }, {
            key: "buildPickers",
            value: function buildPickers(selects, icons) {
              var _this2 = this;
              this.pickers = selects.map(function(select) {
                if (select.classList.contains("ql-align")) {
                  if (select.querySelector("option") == null) {
                    fillSelect(select, ALIGNS);
                  }
                  return new _iconPicker2.default(select, icons.align);
                } else if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
                  var format2 = select.classList.contains("ql-background") ? "background" : "color";
                  if (select.querySelector("option") == null) {
                    fillSelect(select, COLORS, format2 === "background" ? "#ffffff" : "#000000");
                  }
                  return new _colorPicker2.default(select, icons[format2]);
                } else {
                  if (select.querySelector("option") == null) {
                    if (select.classList.contains("ql-font")) {
                      fillSelect(select, FONTS);
                    } else if (select.classList.contains("ql-header")) {
                      fillSelect(select, HEADERS);
                    } else if (select.classList.contains("ql-size")) {
                      fillSelect(select, SIZES);
                    }
                  }
                  return new _picker2.default(select);
                }
              });
              var update = function update2() {
                _this2.pickers.forEach(function(picker) {
                  picker.update();
                });
              };
              this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
            }
          }]);
          return BaseTheme2;
        }(_theme2.default);
        BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                formula: function formula() {
                  this.quill.theme.tooltip.edit("formula");
                },
                image: function image() {
                  var _this3 = this;
                  var fileInput = this.container.querySelector("input.ql-image[type=file]");
                  if (fileInput == null) {
                    fileInput = document.createElement("input");
                    fileInput.setAttribute("type", "file");
                    fileInput.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon");
                    fileInput.classList.add("ql-image");
                    fileInput.addEventListener("change", function() {
                      if (fileInput.files != null && fileInput.files[0] != null) {
                        var reader = new FileReader();
                        reader.onload = function(e) {
                          var range3 = _this3.quill.getSelection(true);
                          _this3.quill.updateContents(new _quillDelta2.default().retain(range3.index).delete(range3.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);
                          _this3.quill.setSelection(range3.index + 1, _emitter2.default.sources.SILENT);
                          fileInput.value = "";
                        };
                        reader.readAsDataURL(fileInput.files[0]);
                      }
                    });
                    this.container.appendChild(fileInput);
                  }
                  fileInput.click();
                },
                video: function video() {
                  this.quill.theme.tooltip.edit("video");
                }
              }
            }
          }
        });
        var BaseTooltip = function(_Tooltip2) {
          _inherits(BaseTooltip2, _Tooltip2);
          function BaseTooltip2(quill2, boundsContainer) {
            _classCallCheck(this, BaseTooltip2);
            var _this4 = _possibleConstructorReturn(this, (BaseTooltip2.__proto__ || Object.getPrototypeOf(BaseTooltip2)).call(this, quill2, boundsContainer));
            _this4.textbox = _this4.root.querySelector('input[type="text"]');
            _this4.listen();
            return _this4;
          }
          _createClass(BaseTooltip2, [{
            key: "listen",
            value: function listen() {
              var _this5 = this;
              this.textbox.addEventListener("keydown", function(event) {
                if (_keyboard2.default.match(event, "enter")) {
                  _this5.save();
                  event.preventDefault();
                } else if (_keyboard2.default.match(event, "escape")) {
                  _this5.cancel();
                  event.preventDefault();
                }
              });
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this.hide();
            }
          }, {
            key: "edit",
            value: function edit() {
              var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
              var preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              this.root.classList.remove("ql-hidden");
              this.root.classList.add("ql-editing");
              if (preview != null) {
                this.textbox.value = preview;
              } else if (mode !== this.root.getAttribute("data-mode")) {
                this.textbox.value = "";
              }
              this.position(this.quill.getBounds(this.quill.selection.savedRange));
              this.textbox.select();
              this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + mode) || "");
              this.root.setAttribute("data-mode", mode);
            }
          }, {
            key: "restoreFocus",
            value: function restoreFocus() {
              var scrollTop = this.quill.scrollingContainer.scrollTop;
              this.quill.focus();
              this.quill.scrollingContainer.scrollTop = scrollTop;
            }
          }, {
            key: "save",
            value: function save2() {
              var value = this.textbox.value;
              switch (this.root.getAttribute("data-mode")) {
                case "link": {
                  var scrollTop = this.quill.root.scrollTop;
                  if (this.linkRange) {
                    this.quill.formatText(this.linkRange, "link", value, _emitter2.default.sources.USER);
                    delete this.linkRange;
                  } else {
                    this.restoreFocus();
                    this.quill.format("link", value, _emitter2.default.sources.USER);
                  }
                  this.quill.root.scrollTop = scrollTop;
                  break;
                }
                case "video": {
                  value = extractVideoUrl(value);
                }
                case "formula": {
                  if (!value)
                    break;
                  var range3 = this.quill.getSelection(true);
                  if (range3 != null) {
                    var index2 = range3.index + range3.length;
                    this.quill.insertEmbed(index2, this.root.getAttribute("data-mode"), value, _emitter2.default.sources.USER);
                    if (this.root.getAttribute("data-mode") === "formula") {
                      this.quill.insertText(index2 + 1, " ", _emitter2.default.sources.USER);
                    }
                    this.quill.setSelection(index2 + 2, _emitter2.default.sources.USER);
                  }
                  break;
                }
              }
              this.textbox.value = "";
              this.hide();
            }
          }]);
          return BaseTooltip2;
        }(_tooltip2.default);
        function extractVideoUrl(url2) {
          var match = url2.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url2.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
          if (match) {
            return (match[1] || "https") + "://www.youtube.com/embed/" + match[2] + "?showinfo=0";
          }
          if (match = url2.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
            return (match[1] || "https") + "://player.vimeo.com/video/" + match[2] + "/";
          }
          return url2;
        }
        function fillSelect(select, values) {
          var defaultValue2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          values.forEach(function(value) {
            var option2 = document.createElement("option");
            if (value === defaultValue2) {
              option2.setAttribute("selected", "selected");
            } else {
              option2.setAttribute("value", value);
            }
            select.appendChild(option2);
          });
        }
        exports2.BaseTooltip = BaseTooltip;
        exports2.default = BaseTheme;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var LinkedList = function() {
          function LinkedList2() {
            this.head = this.tail = null;
            this.length = 0;
          }
          LinkedList2.prototype.append = function() {
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              nodes[_i] = arguments[_i];
            }
            this.insertBefore(nodes[0], null);
            if (nodes.length > 1) {
              this.append.apply(this, nodes.slice(1));
            }
          };
          LinkedList2.prototype.contains = function(node) {
            var cur, next = this.iterator();
            while (cur = next()) {
              if (cur === node)
                return true;
            }
            return false;
          };
          LinkedList2.prototype.insertBefore = function(node, refNode) {
            if (!node)
              return;
            node.next = refNode;
            if (refNode != null) {
              node.prev = refNode.prev;
              if (refNode.prev != null) {
                refNode.prev.next = node;
              }
              refNode.prev = node;
              if (refNode === this.head) {
                this.head = node;
              }
            } else if (this.tail != null) {
              this.tail.next = node;
              node.prev = this.tail;
              this.tail = node;
            } else {
              node.prev = null;
              this.head = this.tail = node;
            }
            this.length += 1;
          };
          LinkedList2.prototype.offset = function(target) {
            var index2 = 0, cur = this.head;
            while (cur != null) {
              if (cur === target)
                return index2;
              index2 += cur.length();
              cur = cur.next;
            }
            return -1;
          };
          LinkedList2.prototype.remove = function(node) {
            if (!this.contains(node))
              return;
            if (node.prev != null)
              node.prev.next = node.next;
            if (node.next != null)
              node.next.prev = node.prev;
            if (node === this.head)
              this.head = node.next;
            if (node === this.tail)
              this.tail = node.prev;
            this.length -= 1;
          };
          LinkedList2.prototype.iterator = function(curNode) {
            if (curNode === void 0) {
              curNode = this.head;
            }
            return function() {
              var ret = curNode;
              if (curNode != null)
                curNode = curNode.next;
              return ret;
            };
          };
          LinkedList2.prototype.find = function(index2, inclusive) {
            if (inclusive === void 0) {
              inclusive = false;
            }
            var cur, next = this.iterator();
            while (cur = next()) {
              var length = cur.length();
              if (index2 < length || inclusive && index2 === length && (cur.next == null || cur.next.length() !== 0)) {
                return [cur, index2];
              }
              index2 -= length;
            }
            return [null, 0];
          };
          LinkedList2.prototype.forEach = function(callback) {
            var cur, next = this.iterator();
            while (cur = next()) {
              callback(cur);
            }
          };
          LinkedList2.prototype.forEachAt = function(index2, length, callback) {
            if (length <= 0)
              return;
            var _a = this.find(index2), startNode = _a[0], offset2 = _a[1];
            var cur, curIndex = index2 - offset2, next = this.iterator(startNode);
            while ((cur = next()) && curIndex < index2 + length) {
              var curLength = cur.length();
              if (index2 > curIndex) {
                callback(cur, index2 - curIndex, Math.min(length, curIndex + curLength - index2));
              } else {
                callback(cur, 0, Math.min(curLength, index2 + length - curIndex));
              }
              curIndex += curLength;
            }
          };
          LinkedList2.prototype.map = function(callback) {
            return this.reduce(function(memo, cur) {
              memo.push(callback(cur));
              return memo;
            }, []);
          };
          LinkedList2.prototype.reduce = function(callback, memo) {
            var cur, next = this.iterator();
            while (cur = next()) {
              memo = callback(memo, cur);
            }
            return memo;
          };
          return LinkedList2;
        }();
        exports2.default = LinkedList;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var container_1 = __webpack_require__(17);
        var Registry = __webpack_require__(1);
        var OBSERVER_CONFIG = {
          attributes: true,
          characterData: true,
          characterDataOldValue: true,
          childList: true,
          subtree: true
        };
        var MAX_OPTIMIZE_ITERATIONS = 100;
        var ScrollBlot = function(_super) {
          __extends(ScrollBlot2, _super);
          function ScrollBlot2(node) {
            var _this = _super.call(this, node) || this;
            _this.scroll = _this;
            _this.observer = new MutationObserver(function(mutations) {
              _this.update(mutations);
            });
            _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
            _this.attach();
            return _this;
          }
          ScrollBlot2.prototype.detach = function() {
            _super.prototype.detach.call(this);
            this.observer.disconnect();
          };
          ScrollBlot2.prototype.deleteAt = function(index2, length) {
            this.update();
            if (index2 === 0 && length === this.length()) {
              this.children.forEach(function(child) {
                child.remove();
              });
            } else {
              _super.prototype.deleteAt.call(this, index2, length);
            }
          };
          ScrollBlot2.prototype.formatAt = function(index2, length, name, value) {
            this.update();
            _super.prototype.formatAt.call(this, index2, length, name, value);
          };
          ScrollBlot2.prototype.insertAt = function(index2, value, def) {
            this.update();
            _super.prototype.insertAt.call(this, index2, value, def);
          };
          ScrollBlot2.prototype.optimize = function(mutations, context) {
            var _this = this;
            if (mutations === void 0) {
              mutations = [];
            }
            if (context === void 0) {
              context = {};
            }
            _super.prototype.optimize.call(this, context);
            var records = [].slice.call(this.observer.takeRecords());
            while (records.length > 0)
              mutations.push(records.pop());
            var mark = function(blot, markParent) {
              if (markParent === void 0) {
                markParent = true;
              }
              if (blot == null || blot === _this)
                return;
              if (blot.domNode.parentNode == null)
                return;
              if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                blot.domNode[Registry.DATA_KEY].mutations = [];
              }
              if (markParent)
                mark(blot.parent);
            };
            var optimize = function(blot) {
              if (blot.domNode[Registry.DATA_KEY] == null || blot.domNode[Registry.DATA_KEY].mutations == null) {
                return;
              }
              if (blot instanceof container_1.default) {
                blot.children.forEach(optimize);
              }
              blot.optimize(context);
            };
            var remaining = mutations;
            for (var i = 0; remaining.length > 0; i += 1) {
              if (i >= MAX_OPTIMIZE_ITERATIONS) {
                throw new Error("[Parchment] Maximum optimize iterations reached");
              }
              remaining.forEach(function(mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null)
                  return;
                if (blot.domNode === mutation.target) {
                  if (mutation.type === "childList") {
                    mark(Registry.find(mutation.previousSibling, false));
                    [].forEach.call(mutation.addedNodes, function(node) {
                      var child = Registry.find(node, false);
                      mark(child, false);
                      if (child instanceof container_1.default) {
                        child.children.forEach(function(grandChild) {
                          mark(grandChild, false);
                        });
                      }
                    });
                  } else if (mutation.type === "attributes") {
                    mark(blot.prev);
                  }
                }
                mark(blot);
              });
              this.children.forEach(optimize);
              remaining = [].slice.call(this.observer.takeRecords());
              records = remaining.slice();
              while (records.length > 0)
                mutations.push(records.pop());
            }
          };
          ScrollBlot2.prototype.update = function(mutations, context) {
            var _this = this;
            if (context === void 0) {
              context = {};
            }
            mutations = mutations || this.observer.takeRecords();
            mutations.map(function(mutation) {
              var blot = Registry.find(mutation.target, true);
              if (blot == null)
                return null;
              if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                return blot;
              } else {
                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                return null;
              }
            }).forEach(function(blot) {
              if (blot == null || blot === _this || blot.domNode[Registry.DATA_KEY] == null)
                return;
              blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
            });
            if (this.domNode[Registry.DATA_KEY].mutations != null) {
              _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
            }
            this.optimize(mutations, context);
          };
          ScrollBlot2.blotName = "scroll";
          ScrollBlot2.defaultChild = "block";
          ScrollBlot2.scope = Registry.Scope.BLOCK_BLOT;
          ScrollBlot2.tagName = "DIV";
          return ScrollBlot2;
        }(container_1.default);
        exports2.default = ScrollBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var format_1 = __webpack_require__(18);
        var Registry = __webpack_require__(1);
        function isEqual2(obj1, obj2) {
          if (Object.keys(obj1).length !== Object.keys(obj2).length)
            return false;
          for (var prop in obj1) {
            if (obj1[prop] !== obj2[prop])
              return false;
          }
          return true;
        }
        var InlineBlot = function(_super) {
          __extends(InlineBlot2, _super);
          function InlineBlot2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          InlineBlot2.formats = function(domNode) {
            if (domNode.tagName === InlineBlot2.tagName)
              return void 0;
            return _super.formats.call(this, domNode);
          };
          InlineBlot2.prototype.format = function(name, value) {
            var _this = this;
            if (name === this.statics.blotName && !value) {
              this.children.forEach(function(child) {
                if (!(child instanceof format_1.default)) {
                  child = child.wrap(InlineBlot2.blotName, true);
                }
                _this.attributes.copy(child);
              });
              this.unwrap();
            } else {
              _super.prototype.format.call(this, name, value);
            }
          };
          InlineBlot2.prototype.formatAt = function(index2, length, name, value) {
            if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
              var blot = this.isolate(index2, length);
              blot.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index2, length, name, value);
            }
          };
          InlineBlot2.prototype.optimize = function(context) {
            _super.prototype.optimize.call(this, context);
            var formats = this.formats();
            if (Object.keys(formats).length === 0) {
              return this.unwrap();
            }
            var next = this.next;
            if (next instanceof InlineBlot2 && next.prev === this && isEqual2(formats, next.formats())) {
              next.moveChildren(this);
              next.remove();
            }
          };
          InlineBlot2.blotName = "inline";
          InlineBlot2.scope = Registry.Scope.INLINE_BLOT;
          InlineBlot2.tagName = "SPAN";
          return InlineBlot2;
        }(format_1.default);
        exports2.default = InlineBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var format_1 = __webpack_require__(18);
        var Registry = __webpack_require__(1);
        var BlockBlot = function(_super) {
          __extends(BlockBlot2, _super);
          function BlockBlot2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          BlockBlot2.formats = function(domNode) {
            var tagName = Registry.query(BlockBlot2.blotName).tagName;
            if (domNode.tagName === tagName)
              return void 0;
            return _super.formats.call(this, domNode);
          };
          BlockBlot2.prototype.format = function(name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) == null) {
              return;
            } else if (name === this.statics.blotName && !value) {
              this.replaceWith(BlockBlot2.blotName);
            } else {
              _super.prototype.format.call(this, name, value);
            }
          };
          BlockBlot2.prototype.formatAt = function(index2, length, name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) != null) {
              this.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index2, length, name, value);
            }
          };
          BlockBlot2.prototype.insertAt = function(index2, value, def) {
            if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
              _super.prototype.insertAt.call(this, index2, value, def);
            } else {
              var after = this.split(index2);
              var blot = Registry.create(value, def);
              after.parent.insertBefore(blot, after);
            }
          };
          BlockBlot2.prototype.update = function(mutations, context) {
            if (navigator.userAgent.match(/Trident/)) {
              this.build();
            } else {
              _super.prototype.update.call(this, mutations, context);
            }
          };
          BlockBlot2.blotName = "block";
          BlockBlot2.scope = Registry.Scope.BLOCK_BLOT;
          BlockBlot2.tagName = "P";
          return BlockBlot2;
        }(format_1.default);
        exports2.default = BlockBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var leaf_1 = __webpack_require__(19);
        var EmbedBlot = function(_super) {
          __extends(EmbedBlot2, _super);
          function EmbedBlot2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          EmbedBlot2.formats = function(domNode) {
            return void 0;
          };
          EmbedBlot2.prototype.format = function(name, value) {
            _super.prototype.formatAt.call(this, 0, this.length(), name, value);
          };
          EmbedBlot2.prototype.formatAt = function(index2, length, name, value) {
            if (index2 === 0 && length === this.length()) {
              this.format(name, value);
            } else {
              _super.prototype.formatAt.call(this, index2, length, name, value);
            }
          };
          EmbedBlot2.prototype.formats = function() {
            return this.statics.formats(this.domNode);
          };
          return EmbedBlot2;
        }(leaf_1.default);
        exports2.default = EmbedBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p2 in b2)
              if (b2.hasOwnProperty(p2))
                d2[p2] = b2[p2];
          };
          return function(d2, b2) {
            extendStatics(d2, b2);
            function __() {
              this.constructor = d2;
            }
            d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var leaf_1 = __webpack_require__(19);
        var Registry = __webpack_require__(1);
        var TextBlot = function(_super) {
          __extends(TextBlot2, _super);
          function TextBlot2(node) {
            var _this = _super.call(this, node) || this;
            _this.text = _this.statics.value(_this.domNode);
            return _this;
          }
          TextBlot2.create = function(value) {
            return document.createTextNode(value);
          };
          TextBlot2.value = function(domNode) {
            var text = domNode.data;
            if (text["normalize"])
              text = text["normalize"]();
            return text;
          };
          TextBlot2.prototype.deleteAt = function(index2, length) {
            this.domNode.data = this.text = this.text.slice(0, index2) + this.text.slice(index2 + length);
          };
          TextBlot2.prototype.index = function(node, offset2) {
            if (this.domNode === node) {
              return offset2;
            }
            return -1;
          };
          TextBlot2.prototype.insertAt = function(index2, value, def) {
            if (def == null) {
              this.text = this.text.slice(0, index2) + value + this.text.slice(index2);
              this.domNode.data = this.text;
            } else {
              _super.prototype.insertAt.call(this, index2, value, def);
            }
          };
          TextBlot2.prototype.length = function() {
            return this.text.length;
          };
          TextBlot2.prototype.optimize = function(context) {
            _super.prototype.optimize.call(this, context);
            this.text = this.statics.value(this.domNode);
            if (this.text.length === 0) {
              this.remove();
            } else if (this.next instanceof TextBlot2 && this.next.prev === this) {
              this.insertAt(this.length(), this.next.value());
              this.next.remove();
            }
          };
          TextBlot2.prototype.position = function(index2, inclusive) {
            return [this.domNode, index2];
          };
          TextBlot2.prototype.split = function(index2, force) {
            if (force === void 0) {
              force = false;
            }
            if (!force) {
              if (index2 === 0)
                return this;
              if (index2 === this.length())
                return this.next;
            }
            var after = Registry.create(this.domNode.splitText(index2));
            this.parent.insertBefore(after, this.next);
            this.text = this.statics.value(this.domNode);
            return after;
          };
          TextBlot2.prototype.update = function(mutations, context) {
            var _this = this;
            if (mutations.some(function(mutation) {
              return mutation.type === "characterData" && mutation.target === _this.domNode;
            })) {
              this.text = this.statics.value(this.domNode);
            }
          };
          TextBlot2.prototype.value = function() {
            return this.text;
          };
          TextBlot2.blotName = "text";
          TextBlot2.scope = Registry.Scope.INLINE_BLOT;
          return TextBlot2;
        }(leaf_1.default);
        exports2.default = TextBlot;
      },
      function(module2, exports2, __webpack_require__) {
        var elem = document.createElement("div");
        elem.classList.toggle("test-class", false);
        if (elem.classList.contains("test-class")) {
          var _toggle = DOMTokenList.prototype.toggle;
          DOMTokenList.prototype.toggle = function(token, force) {
            if (arguments.length > 1 && !this.contains(token) === !force) {
              return force;
            } else {
              return _toggle.call(this, token);
            }
          };
        }
        if (!String.prototype.startsWith) {
          String.prototype.startsWith = function(searchString, position) {
            position = position || 0;
            return this.substr(position, searchString.length) === searchString;
          };
        }
        if (!String.prototype.endsWith) {
          String.prototype.endsWith = function(searchString, position) {
            var subjectString = this.toString();
            if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
              position = subjectString.length;
            }
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
          };
        }
        if (!Array.prototype.find) {
          Object.defineProperty(Array.prototype, "find", {
            value: function value(predicate) {
              if (this === null) {
                throw new TypeError("Array.prototype.find called on null or undefined");
              }
              if (typeof predicate !== "function") {
                throw new TypeError("predicate must be a function");
              }
              var list = Object(this);
              var length = list.length >>> 0;
              var thisArg = arguments[1];
              var value2;
              for (var i = 0; i < length; i++) {
                value2 = list[i];
                if (predicate.call(thisArg, value2, i, list)) {
                  return value2;
                }
              }
              return void 0;
            }
          });
        }
        document.addEventListener("DOMContentLoaded", function() {
          document.execCommand("enableObjectResizing", false, false);
          document.execCommand("autoUrlDetect", false, false);
        });
      },
      function(module2, exports2) {
        var DIFF_DELETE = -1;
        var DIFF_INSERT = 1;
        var DIFF_EQUAL = 0;
        function diff_main(text1, text2, cursor_pos) {
          if (text1 == text2) {
            if (text1) {
              return [[DIFF_EQUAL, text1]];
            }
            return [];
          }
          if (cursor_pos < 0 || text1.length < cursor_pos) {
            cursor_pos = null;
          }
          var commonlength = diff_commonPrefix(text1, text2);
          var commonprefix = text1.substring(0, commonlength);
          text1 = text1.substring(commonlength);
          text2 = text2.substring(commonlength);
          commonlength = diff_commonSuffix(text1, text2);
          var commonsuffix = text1.substring(text1.length - commonlength);
          text1 = text1.substring(0, text1.length - commonlength);
          text2 = text2.substring(0, text2.length - commonlength);
          var diffs = diff_compute_(text1, text2);
          if (commonprefix) {
            diffs.unshift([DIFF_EQUAL, commonprefix]);
          }
          if (commonsuffix) {
            diffs.push([DIFF_EQUAL, commonsuffix]);
          }
          diff_cleanupMerge(diffs);
          if (cursor_pos != null) {
            diffs = fix_cursor(diffs, cursor_pos);
          }
          diffs = fix_emoji(diffs);
          return diffs;
        }
        function diff_compute_(text1, text2) {
          var diffs;
          if (!text1) {
            return [[DIFF_INSERT, text2]];
          }
          if (!text2) {
            return [[DIFF_DELETE, text1]];
          }
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          var i = longtext.indexOf(shorttext);
          if (i != -1) {
            diffs = [
              [DIFF_INSERT, longtext.substring(0, i)],
              [DIFF_EQUAL, shorttext],
              [DIFF_INSERT, longtext.substring(i + shorttext.length)]
            ];
            if (text1.length > text2.length) {
              diffs[0][0] = diffs[2][0] = DIFF_DELETE;
            }
            return diffs;
          }
          if (shorttext.length == 1) {
            return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
          }
          var hm = diff_halfMatch_(text1, text2);
          if (hm) {
            var text1_a = hm[0];
            var text1_b = hm[1];
            var text2_a = hm[2];
            var text2_b = hm[3];
            var mid_common = hm[4];
            var diffs_a = diff_main(text1_a, text2_a);
            var diffs_b = diff_main(text1_b, text2_b);
            return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
          }
          return diff_bisect_(text1, text2);
        }
        function diff_bisect_(text1, text2) {
          var text1_length = text1.length;
          var text2_length = text2.length;
          var max_d = Math.ceil((text1_length + text2_length) / 2);
          var v_offset = max_d;
          var v_length = 2 * max_d;
          var v1 = new Array(v_length);
          var v2 = new Array(v_length);
          for (var x2 = 0; x2 < v_length; x2++) {
            v1[x2] = -1;
            v2[x2] = -1;
          }
          v1[v_offset + 1] = 0;
          v2[v_offset + 1] = 0;
          var delta = text1_length - text2_length;
          var front = delta % 2 != 0;
          var k1start = 0;
          var k1end = 0;
          var k2start = 0;
          var k2end = 0;
          for (var d2 = 0; d2 < max_d; d2++) {
            for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
              var k1_offset = v_offset + k1;
              var x1;
              if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
                x1 = v1[k1_offset + 1];
              } else {
                x1 = v1[k1_offset - 1] + 1;
              }
              var y1 = x1 - k1;
              while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
              }
              v1[k1_offset] = x1;
              if (x1 > text1_length) {
                k1end += 2;
              } else if (y1 > text2_length) {
                k1start += 2;
              } else if (front) {
                var k2_offset = v_offset + delta - k1;
                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                  var x22 = text1_length - v2[k2_offset];
                  if (x1 >= x22) {
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            }
            for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
              var k2_offset = v_offset + k2;
              var x22;
              if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
                x22 = v2[k2_offset + 1];
              } else {
                x22 = v2[k2_offset - 1] + 1;
              }
              var y2 = x22 - k2;
              while (x22 < text1_length && y2 < text2_length && text1.charAt(text1_length - x22 - 1) == text2.charAt(text2_length - y2 - 1)) {
                x22++;
                y2++;
              }
              v2[k2_offset] = x22;
              if (x22 > text1_length) {
                k2end += 2;
              } else if (y2 > text2_length) {
                k2start += 2;
              } else if (!front) {
                var k1_offset = v_offset + delta - k2;
                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                  var x1 = v1[k1_offset];
                  var y1 = v_offset + x1 - k1_offset;
                  x22 = text1_length - x22;
                  if (x1 >= x22) {
                    return diff_bisectSplit_(text1, text2, x1, y1);
                  }
                }
              }
            }
          }
          return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
        }
        function diff_bisectSplit_(text1, text2, x2, y) {
          var text1a = text1.substring(0, x2);
          var text2a = text2.substring(0, y);
          var text1b = text1.substring(x2);
          var text2b = text2.substring(y);
          var diffs = diff_main(text1a, text2a);
          var diffsb = diff_main(text1b, text2b);
          return diffs.concat(diffsb);
        }
        function diff_commonPrefix(text1, text2) {
          if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
            return 0;
          }
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerstart = 0;
          while (pointermin < pointermid) {
            if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
              pointermin = pointermid;
              pointerstart = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        }
        function diff_commonSuffix(text1, text2) {
          if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
            return 0;
          }
          var pointermin = 0;
          var pointermax = Math.min(text1.length, text2.length);
          var pointermid = pointermax;
          var pointerend = 0;
          while (pointermin < pointermid) {
            if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
              pointermin = pointermid;
              pointerend = pointermin;
            } else {
              pointermax = pointermid;
            }
            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
          }
          return pointermid;
        }
        function diff_halfMatch_(text1, text2) {
          var longtext = text1.length > text2.length ? text1 : text2;
          var shorttext = text1.length > text2.length ? text2 : text1;
          if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
            return null;
          }
          function diff_halfMatchI_(longtext2, shorttext2, i) {
            var seed2 = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
            var j = -1;
            var best_common = "";
            var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
            while ((j = shorttext2.indexOf(seed2, j + 1)) != -1) {
              var prefixLength = diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
              var suffixLength = diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
              if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
                best_longtext_a = longtext2.substring(0, i - suffixLength);
                best_longtext_b = longtext2.substring(i + prefixLength);
                best_shorttext_a = shorttext2.substring(0, j - suffixLength);
                best_shorttext_b = shorttext2.substring(j + prefixLength);
              }
            }
            if (best_common.length * 2 >= longtext2.length) {
              return [
                best_longtext_a,
                best_longtext_b,
                best_shorttext_a,
                best_shorttext_b,
                best_common
              ];
            } else {
              return null;
            }
          }
          var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
          var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
          var hm;
          if (!hm1 && !hm2) {
            return null;
          } else if (!hm2) {
            hm = hm1;
          } else if (!hm1) {
            hm = hm2;
          } else {
            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
          }
          var text1_a, text1_b, text2_a, text2_b;
          if (text1.length > text2.length) {
            text1_a = hm[0];
            text1_b = hm[1];
            text2_a = hm[2];
            text2_b = hm[3];
          } else {
            text2_a = hm[0];
            text2_b = hm[1];
            text1_a = hm[2];
            text1_b = hm[3];
          }
          var mid_common = hm[4];
          return [text1_a, text1_b, text2_a, text2_b, mid_common];
        }
        function diff_cleanupMerge(diffs) {
          diffs.push([DIFF_EQUAL, ""]);
          var pointer = 0;
          var count_delete = 0;
          var count_insert = 0;
          var text_delete = "";
          var text_insert = "";
          var commonlength;
          while (pointer < diffs.length) {
            switch (diffs[pointer][0]) {
              case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
              case DIFF_EQUAL:
                if (count_delete + count_insert > 1) {
                  if (count_delete !== 0 && count_insert !== 0) {
                    commonlength = diff_commonPrefix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                        diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                      } else {
                        diffs.splice(0, 0, [
                          DIFF_EQUAL,
                          text_insert.substring(0, commonlength)
                        ]);
                        pointer++;
                      }
                      text_insert = text_insert.substring(commonlength);
                      text_delete = text_delete.substring(commonlength);
                    }
                    commonlength = diff_commonSuffix(text_insert, text_delete);
                    if (commonlength !== 0) {
                      diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                      text_insert = text_insert.substring(0, text_insert.length - commonlength);
                      text_delete = text_delete.substring(0, text_delete.length - commonlength);
                    }
                  }
                  if (count_delete === 0) {
                    diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
                  } else if (count_insert === 0) {
                    diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
                  } else {
                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                  }
                  pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - 1][1] += diffs[pointer][1];
                  diffs.splice(pointer, 1);
                } else {
                  pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = "";
                text_insert = "";
                break;
            }
          }
          if (diffs[diffs.length - 1][1] === "") {
            diffs.pop();
          }
          var changes = false;
          pointer = 1;
          while (pointer < diffs.length - 1) {
            if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
              if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
              } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
              }
            }
            pointer++;
          }
          if (changes) {
            diff_cleanupMerge(diffs);
          }
        }
        var diff = diff_main;
        diff.INSERT = DIFF_INSERT;
        diff.DELETE = DIFF_DELETE;
        diff.EQUAL = DIFF_EQUAL;
        module2.exports = diff;
        function cursor_normalize_diff(diffs, cursor_pos) {
          if (cursor_pos === 0) {
            return [DIFF_EQUAL, diffs];
          }
          for (var current_pos = 0, i = 0; i < diffs.length; i++) {
            var d2 = diffs[i];
            if (d2[0] === DIFF_DELETE || d2[0] === DIFF_EQUAL) {
              var next_pos = current_pos + d2[1].length;
              if (cursor_pos === next_pos) {
                return [i + 1, diffs];
              } else if (cursor_pos < next_pos) {
                diffs = diffs.slice();
                var split_pos = cursor_pos - current_pos;
                var d_left = [d2[0], d2[1].slice(0, split_pos)];
                var d_right = [d2[0], d2[1].slice(split_pos)];
                diffs.splice(i, 1, d_left, d_right);
                return [i + 1, diffs];
              } else {
                current_pos = next_pos;
              }
            }
          }
          throw new Error("cursor_pos is out of bounds!");
        }
        function fix_cursor(diffs, cursor_pos) {
          var norm = cursor_normalize_diff(diffs, cursor_pos);
          var ndiffs = norm[1];
          var cursor_pointer = norm[0];
          var d2 = ndiffs[cursor_pointer];
          var d_next = ndiffs[cursor_pointer + 1];
          if (d2 == null) {
            return diffs;
          } else if (d2[0] !== DIFF_EQUAL) {
            return diffs;
          } else {
            if (d_next != null && d2[1] + d_next[1] === d_next[1] + d2[1]) {
              ndiffs.splice(cursor_pointer, 2, d_next, d2);
              return merge_tuples(ndiffs, cursor_pointer, 2);
            } else if (d_next != null && d_next[1].indexOf(d2[1]) === 0) {
              ndiffs.splice(cursor_pointer, 2, [d_next[0], d2[1]], [0, d2[1]]);
              var suffix = d_next[1].slice(d2[1].length);
              if (suffix.length > 0) {
                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
              }
              return merge_tuples(ndiffs, cursor_pointer, 3);
            } else {
              return diffs;
            }
          }
        }
        function fix_emoji(diffs) {
          var compact = false;
          var starts_with_pair_end = function(str) {
            return str.charCodeAt(0) >= 56320 && str.charCodeAt(0) <= 57343;
          };
          var ends_with_pair_start = function(str) {
            return str.charCodeAt(str.length - 1) >= 55296 && str.charCodeAt(str.length - 1) <= 56319;
          };
          for (var i = 2; i < diffs.length; i += 1) {
            if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
              compact = true;
              diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
              diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
              diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
            }
          }
          if (!compact) {
            return diffs;
          }
          var fixed_diffs = [];
          for (var i = 0; i < diffs.length; i += 1) {
            if (diffs[i][1].length > 0) {
              fixed_diffs.push(diffs[i]);
            }
          }
          return fixed_diffs;
        }
        function merge_tuples(diffs, start2, length) {
          for (var i = start2 + length - 1; i >= 0 && i >= start2 - 1; i--) {
            if (i + 1 < diffs.length) {
              var left_d = diffs[i];
              var right_d = diffs[i + 1];
              if (left_d[0] === right_d[1]) {
                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
              }
            }
          }
          return diffs;
        }
      },
      function(module2, exports2) {
        exports2 = module2.exports = typeof Object.keys === "function" ? Object.keys : shim;
        exports2.shim = shim;
        function shim(obj) {
          var keys2 = [];
          for (var key2 in obj)
            keys2.push(key2);
          return keys2;
        }
      },
      function(module2, exports2) {
        var supportsArgumentsClass = function() {
          return Object.prototype.toString.call(arguments);
        }() == "[object Arguments]";
        exports2 = module2.exports = supportsArgumentsClass ? supported : unsupported;
        exports2.supported = supported;
        function supported(object4) {
          return Object.prototype.toString.call(object4) == "[object Arguments]";
        }
        exports2.unsupported = unsupported;
        function unsupported(object4) {
          return object4 && typeof object4 == "object" && typeof object4.length == "number" && Object.prototype.hasOwnProperty.call(object4, "callee") && !Object.prototype.propertyIsEnumerable.call(object4, "callee") || false;
        }
      },
      function(module2, exports2) {
        var has = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = Object.create(null);
          if (!new Events().__proto__)
            prefix = false;
        }
        function EE(fn2, context, once2) {
          this.fn = fn2;
          this.context = context;
          this.once = once2 || false;
        }
        function EventEmitter() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          var names = [], events2, name;
          if (this._eventsCount === 0)
            return names;
          for (name in events2 = this._events) {
            if (has.call(events2, name))
              names.push(prefix ? name.slice(1) : name);
          }
          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events2));
          }
          return names;
        };
        EventEmitter.prototype.listeners = function listeners(event, exists) {
          var evt = prefix ? prefix + event : event, available = this._events[evt];
          if (exists)
            return !!available;
          if (!available)
            return [];
          if (available.fn)
            return [available.fn];
          for (var i = 0, l2 = available.length, ee = new Array(l2); i < l2; i++) {
            ee[i] = available[i].fn;
          }
          return ee;
        };
        EventEmitter.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return false;
          var listeners = this._events[evt], len = arguments.length, args, i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
              args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i = 0; i < length; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, void 0, true);
              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter.prototype.on = function on2(event, fn2, context) {
          var listener = new EE(fn2, context || this), evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            this._events[evt] = listener, this._eventsCount++;
          else if (!this._events[evt].fn)
            this._events[evt].push(listener);
          else
            this._events[evt] = [this._events[evt], listener];
          return this;
        };
        EventEmitter.prototype.once = function once2(event, fn2, context) {
          var listener = new EE(fn2, context || this, true), evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            this._events[evt] = listener, this._eventsCount++;
          else if (!this._events[evt].fn)
            this._events[evt].push(listener);
          else
            this._events[evt] = [this._events[evt], listener];
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(event, fn2, context, once2) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return this;
          if (!fn2) {
            if (--this._eventsCount === 0)
              this._events = new Events();
            else
              delete this._events[evt];
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context || listeners.context === context)) {
              if (--this._eventsCount === 0)
                this._events = new Events();
              else
                delete this._events[evt];
            }
          } else {
            for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn2 || once2 && !listeners[i].once || context && listeners[i].context !== context) {
                events2.push(listeners[i]);
              }
            }
            if (events2.length)
              this._events[evt] = events2.length === 1 ? events2[0] : events2;
            else if (--this._eventsCount === 0)
              this._events = new Events();
            else
              delete this._events[evt];
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt]) {
              if (--this._eventsCount === 0)
                this._events = new Events();
              else
                delete this._events[evt];
            }
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
          return this;
        };
        EventEmitter.prefixed = prefix;
        EventEmitter.EventEmitter = EventEmitter;
        if (typeof module2 !== "undefined") {
          module2.exports = EventEmitter;
        }
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.matchText = exports2.matchSpacing = exports2.matchNewline = exports2.matchBlot = exports2.matchAttributor = exports2.default = void 0;
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _extend2 = __webpack_require__(3);
        var _extend3 = _interopRequireDefault(_extend2);
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        var _align = __webpack_require__(36);
        var _background = __webpack_require__(37);
        var _code = __webpack_require__(13);
        var _code2 = _interopRequireDefault(_code);
        var _color = __webpack_require__(26);
        var _direction = __webpack_require__(38);
        var _font = __webpack_require__(39);
        var _size = __webpack_require__(40);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var debug = (0, _logger2.default)("quill:clipboard");
        var DOM_KEY = "__ql-matcher";
        var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["b", matchAlias.bind(matchAlias, "bold")], ["i", matchAlias.bind(matchAlias, "italic")], ["style", matchIgnore]];
        var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function(memo, attr) {
          memo[attr.keyName] = attr;
          return memo;
        }, {});
        var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function(memo, attr) {
          memo[attr.keyName] = attr;
          return memo;
        }, {});
        var Clipboard = function(_Module) {
          _inherits(Clipboard2, _Module);
          function Clipboard2(quill2, options2) {
            _classCallCheck(this, Clipboard2);
            var _this = _possibleConstructorReturn(this, (Clipboard2.__proto__ || Object.getPrototypeOf(Clipboard2)).call(this, quill2, options2));
            _this.quill.root.addEventListener("paste", _this.onPaste.bind(_this));
            _this.container = _this.quill.addContainer("ql-clipboard");
            _this.container.setAttribute("contenteditable", true);
            _this.container.setAttribute("tabindex", -1);
            _this.matchers = [];
            CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {
              var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];
              if (!options2.matchVisual && matcher === matchSpacing)
                return;
              _this.addMatcher(selector, matcher);
            });
            return _this;
          }
          _createClass(Clipboard2, [{
            key: "addMatcher",
            value: function addMatcher(selector, matcher) {
              this.matchers.push([selector, matcher]);
            }
          }, {
            key: "convert",
            value: function convert(html) {
              if (typeof html === "string") {
                this.container.innerHTML = html.replace(/\>\r?\n +\</g, "><");
                return this.convert();
              }
              var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
              if (formats[_code2.default.blotName]) {
                var text = this.container.innerText;
                this.container.innerHTML = "";
                return new _quillDelta2.default().insert(text, _defineProperty2({}, _code2.default.blotName, formats[_code2.default.blotName]));
              }
              var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];
              var delta = traverse(this.container, elementMatchers, textMatchers);
              if (deltaEndsWith(delta, "\n") && delta.ops[delta.ops.length - 1].attributes == null) {
                delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
              }
              debug.log("convert", this.container.innerHTML, delta);
              this.container.innerHTML = "";
              return delta;
            }
          }, {
            key: "dangerouslyPasteHTML",
            value: function dangerouslyPasteHTML(index2, html) {
              var source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _quill2.default.sources.API;
              if (typeof index2 === "string") {
                this.quill.setContents(this.convert(index2), html);
                this.quill.setSelection(0, _quill2.default.sources.SILENT);
              } else {
                var paste = this.convert(html);
                this.quill.updateContents(new _quillDelta2.default().retain(index2).concat(paste), source);
                this.quill.setSelection(index2 + paste.length(), _quill2.default.sources.SILENT);
              }
            }
          }, {
            key: "onPaste",
            value: function onPaste(e) {
              var _this2 = this;
              if (e.defaultPrevented || !this.quill.isEnabled())
                return;
              var range3 = this.quill.getSelection();
              var delta = new _quillDelta2.default().retain(range3.index);
              var scrollTop = this.quill.scrollingContainer.scrollTop;
              this.container.focus();
              this.quill.selection.update(_quill2.default.sources.SILENT);
              setTimeout(function() {
                delta = delta.concat(_this2.convert()).delete(range3.length);
                _this2.quill.updateContents(delta, _quill2.default.sources.USER);
                _this2.quill.setSelection(delta.length() - range3.length, _quill2.default.sources.SILENT);
                _this2.quill.scrollingContainer.scrollTop = scrollTop;
                _this2.quill.focus();
              }, 1);
            }
          }, {
            key: "prepareMatching",
            value: function prepareMatching() {
              var _this3 = this;
              var elementMatchers = [], textMatchers = [];
              this.matchers.forEach(function(pair) {
                var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];
                switch (selector) {
                  case Node.TEXT_NODE:
                    textMatchers.push(matcher);
                    break;
                  case Node.ELEMENT_NODE:
                    elementMatchers.push(matcher);
                    break;
                  default:
                    [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {
                      node[DOM_KEY] = node[DOM_KEY] || [];
                      node[DOM_KEY].push(matcher);
                    });
                    break;
                }
              });
              return [elementMatchers, textMatchers];
            }
          }]);
          return Clipboard2;
        }(_module2.default);
        Clipboard.DEFAULTS = {
          matchers: [],
          matchVisual: true
        };
        function applyFormat(delta, format2, value) {
          if ((typeof format2 === "undefined" ? "undefined" : _typeof2(format2)) === "object") {
            return Object.keys(format2).reduce(function(delta2, key2) {
              return applyFormat(delta2, key2, format2[key2]);
            }, delta);
          } else {
            return delta.reduce(function(delta2, op) {
              if (op.attributes && op.attributes[format2]) {
                return delta2.push(op);
              } else {
                return delta2.insert(op.insert, (0, _extend3.default)({}, _defineProperty2({}, format2, value), op.attributes));
              }
            }, new _quillDelta2.default());
          }
        }
        function computeStyle(node) {
          if (node.nodeType !== Node.ELEMENT_NODE)
            return {};
          var DOM_KEY2 = "__ql-computed-style";
          return node[DOM_KEY2] || (node[DOM_KEY2] = window.getComputedStyle(node));
        }
        function deltaEndsWith(delta, text) {
          var endText = "";
          for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
            var op = delta.ops[i];
            if (typeof op.insert !== "string")
              break;
            endText = op.insert + endText;
          }
          return endText.slice(-1 * text.length) === text;
        }
        function isLine(node) {
          if (node.childNodes.length === 0)
            return false;
          var style = computeStyle(node);
          return ["block", "list-item"].indexOf(style.display) > -1;
        }
        function traverse(node, elementMatchers, textMatchers) {
          if (node.nodeType === node.TEXT_NODE) {
            return textMatchers.reduce(function(delta, matcher) {
              return matcher(node, delta);
            }, new _quillDelta2.default());
          } else if (node.nodeType === node.ELEMENT_NODE) {
            return [].reduce.call(node.childNodes || [], function(delta, childNode) {
              var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
              if (childNode.nodeType === node.ELEMENT_NODE) {
                childrenDelta = elementMatchers.reduce(function(childrenDelta2, matcher) {
                  return matcher(childNode, childrenDelta2);
                }, childrenDelta);
                childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta2, matcher) {
                  return matcher(childNode, childrenDelta2);
                }, childrenDelta);
              }
              return delta.concat(childrenDelta);
            }, new _quillDelta2.default());
          } else {
            return new _quillDelta2.default();
          }
        }
        function matchAlias(format2, node, delta) {
          return applyFormat(delta, format2, true);
        }
        function matchAttributor(node, delta) {
          var attributes = _parchment2.default.Attributor.Attribute.keys(node);
          var classes = _parchment2.default.Attributor.Class.keys(node);
          var styles = _parchment2.default.Attributor.Style.keys(node);
          var formats = {};
          attributes.concat(classes).concat(styles).forEach(function(name) {
            var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
            if (attr != null) {
              formats[attr.attrName] = attr.value(node);
              if (formats[attr.attrName])
                return;
            }
            attr = ATTRIBUTE_ATTRIBUTORS[name];
            if (attr != null && (attr.attrName === name || attr.keyName === name)) {
              formats[attr.attrName] = attr.value(node) || void 0;
            }
            attr = STYLE_ATTRIBUTORS[name];
            if (attr != null && (attr.attrName === name || attr.keyName === name)) {
              attr = STYLE_ATTRIBUTORS[name];
              formats[attr.attrName] = attr.value(node) || void 0;
            }
          });
          if (Object.keys(formats).length > 0) {
            delta = applyFormat(delta, formats);
          }
          return delta;
        }
        function matchBlot(node, delta) {
          var match = _parchment2.default.query(node);
          if (match == null)
            return delta;
          if (match.prototype instanceof _parchment2.default.Embed) {
            var embed = {};
            var value = match.value(node);
            if (value != null) {
              embed[match.blotName] = value;
              delta = new _quillDelta2.default().insert(embed, match.formats(node));
            }
          } else if (typeof match.formats === "function") {
            delta = applyFormat(delta, match.blotName, match.formats(node));
          }
          return delta;
        }
        function matchBreak(node, delta) {
          if (!deltaEndsWith(delta, "\n")) {
            delta.insert("\n");
          }
          return delta;
        }
        function matchIgnore() {
          return new _quillDelta2.default();
        }
        function matchIndent(node, delta) {
          var match = _parchment2.default.query(node);
          if (match == null || match.blotName !== "list-item" || !deltaEndsWith(delta, "\n")) {
            return delta;
          }
          var indent = -1, parent = node.parentNode;
          while (!parent.classList.contains("ql-clipboard")) {
            if ((_parchment2.default.query(parent) || {}).blotName === "list") {
              indent += 1;
            }
            parent = parent.parentNode;
          }
          if (indent <= 0)
            return delta;
          return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent }));
        }
        function matchNewline(node, delta) {
          if (!deltaEndsWith(delta, "\n")) {
            if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
              delta.insert("\n");
            }
          }
          return delta;
        }
        function matchSpacing(node, delta) {
          if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, "\n\n")) {
            var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
            if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
              delta.insert("\n");
            }
          }
          return delta;
        }
        function matchStyles(node, delta) {
          var formats = {};
          var style = node.style || {};
          if (style.fontStyle && computeStyle(node).fontStyle === "italic") {
            formats.italic = true;
          }
          if (style.fontWeight && (computeStyle(node).fontWeight.startsWith("bold") || parseInt(computeStyle(node).fontWeight) >= 700)) {
            formats.bold = true;
          }
          if (Object.keys(formats).length > 0) {
            delta = applyFormat(delta, formats);
          }
          if (parseFloat(style.textIndent || 0) > 0) {
            delta = new _quillDelta2.default().insert("	").concat(delta);
          }
          return delta;
        }
        function matchText(node, delta) {
          var text = node.data;
          if (node.parentNode.tagName === "O:P") {
            return delta.insert(text.trim());
          }
          if (text.trim().length === 0 && node.parentNode.classList.contains("ql-clipboard")) {
            return delta;
          }
          if (!computeStyle(node.parentNode).whiteSpace.startsWith("pre")) {
            var replacer = function replacer2(collapse, match) {
              match = match.replace(/[^\u00a0]/g, "");
              return match.length < 1 && collapse ? " " : match;
            };
            text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
            text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
            if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
              text = text.replace(/^\s+/, replacer.bind(replacer, false));
            }
            if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
              text = text.replace(/\s+$/, replacer.bind(replacer, false));
            }
          }
          return delta.insert(text);
        }
        exports2.default = Clipboard;
        exports2.matchAttributor = matchAttributor;
        exports2.matchBlot = matchBlot;
        exports2.matchNewline = matchNewline;
        exports2.matchSpacing = matchSpacing;
        exports2.matchText = matchText;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Bold = function(_Inline) {
          _inherits(Bold2, _Inline);
          function Bold2() {
            _classCallCheck(this, Bold2);
            return _possibleConstructorReturn(this, (Bold2.__proto__ || Object.getPrototypeOf(Bold2)).apply(this, arguments));
          }
          _createClass(Bold2, [{
            key: "optimize",
            value: function optimize(context) {
              _get(Bold2.prototype.__proto__ || Object.getPrototypeOf(Bold2.prototype), "optimize", this).call(this, context);
              if (this.domNode.tagName !== this.statics.tagName[0]) {
                this.replaceWith(this.statics.blotName);
              }
            }
          }], [{
            key: "create",
            value: function create() {
              return _get(Bold2.__proto__ || Object.getPrototypeOf(Bold2), "create", this).call(this);
            }
          }, {
            key: "formats",
            value: function formats() {
              return true;
            }
          }]);
          return Bold2;
        }(_inline2.default);
        Bold.blotName = "bold";
        Bold.tagName = ["STRONG", "B"];
        exports2.default = Bold;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.addControls = exports2.default = void 0;
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _quillDelta = __webpack_require__(2);
        var _quillDelta2 = _interopRequireDefault(_quillDelta);
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _logger = __webpack_require__(10);
        var _logger2 = _interopRequireDefault(_logger);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var debug = (0, _logger2.default)("quill:toolbar");
        var Toolbar = function(_Module) {
          _inherits(Toolbar2, _Module);
          function Toolbar2(quill2, options2) {
            _classCallCheck(this, Toolbar2);
            var _this = _possibleConstructorReturn(this, (Toolbar2.__proto__ || Object.getPrototypeOf(Toolbar2)).call(this, quill2, options2));
            if (Array.isArray(_this.options.container)) {
              var container = document.createElement("div");
              addControls(container, _this.options.container);
              quill2.container.parentNode.insertBefore(container, quill2.container);
              _this.container = container;
            } else if (typeof _this.options.container === "string") {
              _this.container = document.querySelector(_this.options.container);
            } else {
              _this.container = _this.options.container;
            }
            if (!(_this.container instanceof HTMLElement)) {
              var _ret;
              return _ret = debug.error("Container required for toolbar", _this.options), _possibleConstructorReturn(_this, _ret);
            }
            _this.container.classList.add("ql-toolbar");
            _this.controls = [];
            _this.handlers = {};
            Object.keys(_this.options.handlers).forEach(function(format2) {
              _this.addHandler(format2, _this.options.handlers[format2]);
            });
            [].forEach.call(_this.container.querySelectorAll("button, select"), function(input) {
              _this.attach(input);
            });
            _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type4, range3) {
              if (type4 === _quill2.default.events.SELECTION_CHANGE) {
                _this.update(range3);
              }
            });
            _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
              var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range3 = _this$quill$selection2[0];
              _this.update(range3);
            });
            return _this;
          }
          _createClass(Toolbar2, [{
            key: "addHandler",
            value: function addHandler(format2, handler) {
              this.handlers[format2] = handler;
            }
          }, {
            key: "attach",
            value: function attach(input) {
              var _this2 = this;
              var format2 = [].find.call(input.classList, function(className) {
                return className.indexOf("ql-") === 0;
              });
              if (!format2)
                return;
              format2 = format2.slice("ql-".length);
              if (input.tagName === "BUTTON") {
                input.setAttribute("type", "button");
              }
              if (this.handlers[format2] == null) {
                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format2] == null) {
                  debug.warn("ignoring attaching to disabled format", format2, input);
                  return;
                }
                if (_parchment2.default.query(format2) == null) {
                  debug.warn("ignoring attaching to nonexistent format", format2, input);
                  return;
                }
              }
              var eventName = input.tagName === "SELECT" ? "change" : "click";
              input.addEventListener(eventName, function(e) {
                var value = void 0;
                if (input.tagName === "SELECT") {
                  if (input.selectedIndex < 0)
                    return;
                  var selected = input.options[input.selectedIndex];
                  if (selected.hasAttribute("selected")) {
                    value = false;
                  } else {
                    value = selected.value || false;
                  }
                } else {
                  if (input.classList.contains("ql-active")) {
                    value = false;
                  } else {
                    value = input.value || !input.hasAttribute("value");
                  }
                  e.preventDefault();
                }
                _this2.quill.focus();
                var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range3 = _quill$selection$getR2[0];
                if (_this2.handlers[format2] != null) {
                  _this2.handlers[format2].call(_this2, value);
                } else if (_parchment2.default.query(format2).prototype instanceof _parchment2.default.Embed) {
                  value = prompt("Enter " + format2);
                  if (!value)
                    return;
                  _this2.quill.updateContents(new _quillDelta2.default().retain(range3.index).delete(range3.length).insert(_defineProperty2({}, format2, value)), _quill2.default.sources.USER);
                } else {
                  _this2.quill.format(format2, value, _quill2.default.sources.USER);
                }
                _this2.update(range3);
              });
              this.controls.push([format2, input]);
            }
          }, {
            key: "update",
            value: function update(range3) {
              var formats = range3 == null ? {} : this.quill.getFormat(range3);
              this.controls.forEach(function(pair) {
                var _pair = _slicedToArray(pair, 2), format2 = _pair[0], input = _pair[1];
                if (input.tagName === "SELECT") {
                  var option2 = void 0;
                  if (range3 == null) {
                    option2 = null;
                  } else if (formats[format2] == null) {
                    option2 = input.querySelector("option[selected]");
                  } else if (!Array.isArray(formats[format2])) {
                    var value = formats[format2];
                    if (typeof value === "string") {
                      value = value.replace(/\"/g, '\\"');
                    }
                    option2 = input.querySelector('option[value="' + value + '"]');
                  }
                  if (option2 == null) {
                    input.value = "";
                    input.selectedIndex = -1;
                  } else {
                    option2.selected = true;
                  }
                } else {
                  if (range3 == null) {
                    input.classList.remove("ql-active");
                  } else if (input.hasAttribute("value")) {
                    var isActive = formats[format2] === input.getAttribute("value") || formats[format2] != null && formats[format2].toString() === input.getAttribute("value") || formats[format2] == null && !input.getAttribute("value");
                    input.classList.toggle("ql-active", isActive);
                  } else {
                    input.classList.toggle("ql-active", formats[format2] != null);
                  }
                }
              });
            }
          }]);
          return Toolbar2;
        }(_module2.default);
        Toolbar.DEFAULTS = {};
        function addButton(container, format2, value) {
          var input = document.createElement("button");
          input.setAttribute("type", "button");
          input.classList.add("ql-" + format2);
          if (value != null) {
            input.value = value;
          }
          container.appendChild(input);
        }
        function addControls(container, groups) {
          if (!Array.isArray(groups[0])) {
            groups = [groups];
          }
          groups.forEach(function(controls) {
            var group = document.createElement("span");
            group.classList.add("ql-formats");
            controls.forEach(function(control) {
              if (typeof control === "string") {
                addButton(group, control);
              } else {
                var format2 = Object.keys(control)[0];
                var value = control[format2];
                if (Array.isArray(value)) {
                  addSelect(group, format2, value);
                } else {
                  addButton(group, format2, value);
                }
              }
            });
            container.appendChild(group);
          });
        }
        function addSelect(container, format2, values) {
          var input = document.createElement("select");
          input.classList.add("ql-" + format2);
          values.forEach(function(value) {
            var option2 = document.createElement("option");
            if (value !== false) {
              option2.setAttribute("value", value);
            } else {
              option2.setAttribute("selected", "selected");
            }
            input.appendChild(option2);
          });
          container.appendChild(input);
        }
        Toolbar.DEFAULTS = {
          container: null,
          handlers: {
            clean: function clean() {
              var _this3 = this;
              var range3 = this.quill.getSelection();
              if (range3 == null)
                return;
              if (range3.length == 0) {
                var formats = this.quill.getFormat();
                Object.keys(formats).forEach(function(name) {
                  if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                    _this3.quill.format(name, false);
                  }
                });
              } else {
                this.quill.removeFormat(range3, _quill2.default.sources.USER);
              }
            },
            direction: function direction(value) {
              var align = this.quill.getFormat()["align"];
              if (value === "rtl" && align == null) {
                this.quill.format("align", "right", _quill2.default.sources.USER);
              } else if (!value && align === "right") {
                this.quill.format("align", false, _quill2.default.sources.USER);
              }
              this.quill.format("direction", value, _quill2.default.sources.USER);
            },
            indent: function indent(value) {
              var range3 = this.quill.getSelection();
              var formats = this.quill.getFormat(range3);
              var indent2 = parseInt(formats.indent || 0);
              if (value === "+1" || value === "-1") {
                var modifier = value === "+1" ? 1 : -1;
                if (formats.direction === "rtl")
                  modifier *= -1;
                this.quill.format("indent", indent2 + modifier, _quill2.default.sources.USER);
              }
            },
            link: function link(value) {
              if (value === true) {
                value = prompt("Enter link URL:");
              }
              this.quill.format("link", value, _quill2.default.sources.USER);
            },
            list: function list(value) {
              var range3 = this.quill.getSelection();
              var formats = this.quill.getFormat(range3);
              if (value === "check") {
                if (formats["list"] === "checked" || formats["list"] === "unchecked") {
                  this.quill.format("list", false, _quill2.default.sources.USER);
                } else {
                  this.quill.format("list", "unchecked", _quill2.default.sources.USER);
                }
              } else {
                this.quill.format("list", value, _quill2.default.sources.USER);
              }
            }
          }
        };
        exports2.default = Toolbar;
        exports2.addControls = addControls;
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _picker = __webpack_require__(28);
        var _picker2 = _interopRequireDefault(_picker);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ColorPicker = function(_Picker) {
          _inherits(ColorPicker2, _Picker);
          function ColorPicker2(select, label2) {
            _classCallCheck(this, ColorPicker2);
            var _this = _possibleConstructorReturn(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this, select));
            _this.label.innerHTML = label2;
            _this.container.classList.add("ql-color-picker");
            [].slice.call(_this.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(item) {
              item.classList.add("ql-primary");
            });
            return _this;
          }
          _createClass(ColorPicker2, [{
            key: "buildItem",
            value: function buildItem(option2) {
              var item = _get(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "buildItem", this).call(this, option2);
              item.style.backgroundColor = option2.getAttribute("value") || "";
              return item;
            }
          }, {
            key: "selectItem",
            value: function selectItem(item, trigger) {
              _get(ColorPicker2.prototype.__proto__ || Object.getPrototypeOf(ColorPicker2.prototype), "selectItem", this).call(this, item, trigger);
              var colorLabel = this.label.querySelector(".ql-color-label");
              var value = item ? item.getAttribute("data-value") || "" : "";
              if (colorLabel) {
                if (colorLabel.tagName === "line") {
                  colorLabel.style.stroke = value;
                } else {
                  colorLabel.style.fill = value;
                }
              }
            }
          }]);
          return ColorPicker2;
        }(_picker2.default);
        exports2.default = ColorPicker;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _picker = __webpack_require__(28);
        var _picker2 = _interopRequireDefault(_picker);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var IconPicker = function(_Picker) {
          _inherits(IconPicker2, _Picker);
          function IconPicker2(select, icons) {
            _classCallCheck(this, IconPicker2);
            var _this = _possibleConstructorReturn(this, (IconPicker2.__proto__ || Object.getPrototypeOf(IconPicker2)).call(this, select));
            _this.container.classList.add("ql-icon-picker");
            [].forEach.call(_this.container.querySelectorAll(".ql-picker-item"), function(item) {
              item.innerHTML = icons[item.getAttribute("data-value") || ""];
            });
            _this.defaultItem = _this.container.querySelector(".ql-selected");
            _this.selectItem(_this.defaultItem);
            return _this;
          }
          _createClass(IconPicker2, [{
            key: "selectItem",
            value: function selectItem(item, trigger) {
              _get(IconPicker2.prototype.__proto__ || Object.getPrototypeOf(IconPicker2.prototype), "selectItem", this).call(this, item, trigger);
              item = item || this.defaultItem;
              this.label.innerHTML = item.innerHTML;
            }
          }]);
          return IconPicker2;
        }(_picker2.default);
        exports2.default = IconPicker;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Tooltip2 = function() {
          function Tooltip3(quill2, boundsContainer) {
            var _this = this;
            _classCallCheck(this, Tooltip3);
            this.quill = quill2;
            this.boundsContainer = boundsContainer || document.body;
            this.root = quill2.addContainer("ql-tooltip");
            this.root.innerHTML = this.constructor.TEMPLATE;
            if (this.quill.root === this.quill.scrollingContainer) {
              this.quill.root.addEventListener("scroll", function() {
                _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + "px";
              });
            }
            this.hide();
          }
          _createClass(Tooltip3, [{
            key: "hide",
            value: function hide2() {
              this.root.classList.add("ql-hidden");
            }
          }, {
            key: "position",
            value: function position(reference2) {
              var left2 = reference2.left + reference2.width / 2 - this.root.offsetWidth / 2;
              var top2 = reference2.bottom + this.quill.root.scrollTop;
              this.root.style.left = left2 + "px";
              this.root.style.top = top2 + "px";
              this.root.classList.remove("ql-flip");
              var containerBounds = this.boundsContainer.getBoundingClientRect();
              var rootBounds = this.root.getBoundingClientRect();
              var shift = 0;
              if (rootBounds.right > containerBounds.right) {
                shift = containerBounds.right - rootBounds.right;
                this.root.style.left = left2 + shift + "px";
              }
              if (rootBounds.left < containerBounds.left) {
                shift = containerBounds.left - rootBounds.left;
                this.root.style.left = left2 + shift + "px";
              }
              if (rootBounds.bottom > containerBounds.bottom) {
                var height2 = rootBounds.bottom - rootBounds.top;
                var verticalShift = reference2.bottom - reference2.top + height2;
                this.root.style.top = top2 - verticalShift + "px";
                this.root.classList.add("ql-flip");
              }
              return shift;
            }
          }, {
            key: "show",
            value: function show() {
              this.root.classList.remove("ql-editing");
              this.root.classList.remove("ql-hidden");
            }
          }]);
          return Tooltip3;
        }();
        exports2.default = Tooltip2;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _slicedToArray = function() {
          function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"])
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          return function(arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _emitter = __webpack_require__(8);
        var _emitter2 = _interopRequireDefault(_emitter);
        var _base = __webpack_require__(43);
        var _base2 = _interopRequireDefault(_base);
        var _link = __webpack_require__(27);
        var _link2 = _interopRequireDefault(_link);
        var _selection = __webpack_require__(15);
        var _icons = __webpack_require__(41);
        var _icons2 = _interopRequireDefault(_icons);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var TOOLBAR_CONFIG = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
        var SnowTheme = function(_BaseTheme) {
          _inherits(SnowTheme2, _BaseTheme);
          function SnowTheme2(quill2, options2) {
            _classCallCheck(this, SnowTheme2);
            if (options2.modules.toolbar != null && options2.modules.toolbar.container == null) {
              options2.modules.toolbar.container = TOOLBAR_CONFIG;
            }
            var _this = _possibleConstructorReturn(this, (SnowTheme2.__proto__ || Object.getPrototypeOf(SnowTheme2)).call(this, quill2, options2));
            _this.quill.container.classList.add("ql-snow");
            return _this;
          }
          _createClass(SnowTheme2, [{
            key: "extendToolbar",
            value: function extendToolbar(toolbar) {
              toolbar.container.classList.add("ql-snow");
              this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
              this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
              this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
              if (toolbar.container.querySelector(".ql-link")) {
                this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(range3, context) {
                  toolbar.handlers["link"].call(toolbar, !context.format.link);
                });
              }
            }
          }]);
          return SnowTheme2;
        }(_base2.default);
        SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                link: function link(value) {
                  if (value) {
                    var range3 = this.quill.getSelection();
                    if (range3 == null || range3.length == 0)
                      return;
                    var preview = this.quill.getText(range3);
                    if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                      preview = "mailto:" + preview;
                    }
                    var tooltip = this.quill.theme.tooltip;
                    tooltip.edit("link", preview);
                  } else {
                    this.quill.format("link", false);
                  }
                }
              }
            }
          }
        });
        var SnowTooltip = function(_BaseTooltip) {
          _inherits(SnowTooltip2, _BaseTooltip);
          function SnowTooltip2(quill2, bounds) {
            _classCallCheck(this, SnowTooltip2);
            var _this2 = _possibleConstructorReturn(this, (SnowTooltip2.__proto__ || Object.getPrototypeOf(SnowTooltip2)).call(this, quill2, bounds));
            _this2.preview = _this2.root.querySelector("a.ql-preview");
            return _this2;
          }
          _createClass(SnowTooltip2, [{
            key: "listen",
            value: function listen() {
              var _this3 = this;
              _get(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "listen", this).call(this);
              this.root.querySelector("a.ql-action").addEventListener("click", function(event) {
                if (_this3.root.classList.contains("ql-editing")) {
                  _this3.save();
                } else {
                  _this3.edit("link", _this3.preview.textContent);
                }
                event.preventDefault();
              });
              this.root.querySelector("a.ql-remove").addEventListener("click", function(event) {
                if (_this3.linkRange != null) {
                  var range3 = _this3.linkRange;
                  _this3.restoreFocus();
                  _this3.quill.formatText(range3, "link", false, _emitter2.default.sources.USER);
                  delete _this3.linkRange;
                }
                event.preventDefault();
                _this3.hide();
              });
              this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range3, oldRange, source) {
                if (range3 == null)
                  return;
                if (range3.length === 0 && source === _emitter2.default.sources.USER) {
                  var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range3.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset2 = _quill$scroll$descend2[1];
                  if (link != null) {
                    _this3.linkRange = new _selection.Range(range3.index - offset2, link.length());
                    var preview = _link2.default.formats(link.domNode);
                    _this3.preview.textContent = preview;
                    _this3.preview.setAttribute("href", preview);
                    _this3.show();
                    _this3.position(_this3.quill.getBounds(_this3.linkRange));
                    return;
                  }
                } else {
                  delete _this3.linkRange;
                }
                _this3.hide();
              });
            }
          }, {
            key: "show",
            value: function show() {
              _get(SnowTooltip2.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip2.prototype), "show", this).call(this);
              this.root.removeAttribute("data-mode");
            }
          }]);
          return SnowTooltip2;
        }(_base.BaseTooltip);
        SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
        exports2.default = SnowTheme;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _core = __webpack_require__(29);
        var _core2 = _interopRequireDefault(_core);
        var _align = __webpack_require__(36);
        var _direction = __webpack_require__(38);
        var _indent = __webpack_require__(64);
        var _blockquote = __webpack_require__(65);
        var _blockquote2 = _interopRequireDefault(_blockquote);
        var _header = __webpack_require__(66);
        var _header2 = _interopRequireDefault(_header);
        var _list = __webpack_require__(67);
        var _list2 = _interopRequireDefault(_list);
        var _background = __webpack_require__(37);
        var _color = __webpack_require__(26);
        var _font = __webpack_require__(39);
        var _size = __webpack_require__(40);
        var _bold = __webpack_require__(56);
        var _bold2 = _interopRequireDefault(_bold);
        var _italic = __webpack_require__(68);
        var _italic2 = _interopRequireDefault(_italic);
        var _link = __webpack_require__(27);
        var _link2 = _interopRequireDefault(_link);
        var _script = __webpack_require__(69);
        var _script2 = _interopRequireDefault(_script);
        var _strike = __webpack_require__(70);
        var _strike2 = _interopRequireDefault(_strike);
        var _underline = __webpack_require__(71);
        var _underline2 = _interopRequireDefault(_underline);
        var _image = __webpack_require__(72);
        var _image2 = _interopRequireDefault(_image);
        var _video = __webpack_require__(73);
        var _video2 = _interopRequireDefault(_video);
        var _code = __webpack_require__(13);
        var _code2 = _interopRequireDefault(_code);
        var _formula = __webpack_require__(74);
        var _formula2 = _interopRequireDefault(_formula);
        var _syntax = __webpack_require__(75);
        var _syntax2 = _interopRequireDefault(_syntax);
        var _toolbar = __webpack_require__(57);
        var _toolbar2 = _interopRequireDefault(_toolbar);
        var _icons = __webpack_require__(41);
        var _icons2 = _interopRequireDefault(_icons);
        var _picker = __webpack_require__(28);
        var _picker2 = _interopRequireDefault(_picker);
        var _colorPicker = __webpack_require__(59);
        var _colorPicker2 = _interopRequireDefault(_colorPicker);
        var _iconPicker = __webpack_require__(60);
        var _iconPicker2 = _interopRequireDefault(_iconPicker);
        var _tooltip = __webpack_require__(61);
        var _tooltip2 = _interopRequireDefault(_tooltip);
        var _bubble = __webpack_require__(108);
        var _bubble2 = _interopRequireDefault(_bubble);
        var _snow = __webpack_require__(62);
        var _snow2 = _interopRequireDefault(_snow);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        _core2.default.register({
          "attributors/attribute/direction": _direction.DirectionAttribute,
          "attributors/class/align": _align.AlignClass,
          "attributors/class/background": _background.BackgroundClass,
          "attributors/class/color": _color.ColorClass,
          "attributors/class/direction": _direction.DirectionClass,
          "attributors/class/font": _font.FontClass,
          "attributors/class/size": _size.SizeClass,
          "attributors/style/align": _align.AlignStyle,
          "attributors/style/background": _background.BackgroundStyle,
          "attributors/style/color": _color.ColorStyle,
          "attributors/style/direction": _direction.DirectionStyle,
          "attributors/style/font": _font.FontStyle,
          "attributors/style/size": _size.SizeStyle
        }, true);
        _core2.default.register({
          "formats/align": _align.AlignClass,
          "formats/direction": _direction.DirectionClass,
          "formats/indent": _indent.IndentClass,
          "formats/background": _background.BackgroundStyle,
          "formats/color": _color.ColorStyle,
          "formats/font": _font.FontClass,
          "formats/size": _size.SizeClass,
          "formats/blockquote": _blockquote2.default,
          "formats/code-block": _code2.default,
          "formats/header": _header2.default,
          "formats/list": _list2.default,
          "formats/bold": _bold2.default,
          "formats/code": _code.Code,
          "formats/italic": _italic2.default,
          "formats/link": _link2.default,
          "formats/script": _script2.default,
          "formats/strike": _strike2.default,
          "formats/underline": _underline2.default,
          "formats/image": _image2.default,
          "formats/video": _video2.default,
          "formats/list/item": _list.ListItem,
          "modules/formula": _formula2.default,
          "modules/syntax": _syntax2.default,
          "modules/toolbar": _toolbar2.default,
          "themes/bubble": _bubble2.default,
          "themes/snow": _snow2.default,
          "ui/icons": _icons2.default,
          "ui/picker": _picker2.default,
          "ui/icon-picker": _iconPicker2.default,
          "ui/color-picker": _colorPicker2.default,
          "ui/tooltip": _tooltip2.default
        }, true);
        exports2.default = _core2.default;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.IndentClass = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var IdentAttributor = function(_Parchment$Attributor) {
          _inherits(IdentAttributor2, _Parchment$Attributor);
          function IdentAttributor2() {
            _classCallCheck(this, IdentAttributor2);
            return _possibleConstructorReturn(this, (IdentAttributor2.__proto__ || Object.getPrototypeOf(IdentAttributor2)).apply(this, arguments));
          }
          _createClass(IdentAttributor2, [{
            key: "add",
            value: function add(node, value) {
              if (value === "+1" || value === "-1") {
                var indent = this.value(node) || 0;
                value = value === "+1" ? indent + 1 : indent - 1;
              }
              if (value === 0) {
                this.remove(node);
                return true;
              } else {
                return _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "add", this).call(this, node, value);
              }
            }
          }, {
            key: "canAdd",
            value: function canAdd(node, value) {
              return _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, value) || _get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "canAdd", this).call(this, node, parseInt(value));
            }
          }, {
            key: "value",
            value: function value(node) {
              return parseInt(_get(IdentAttributor2.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor2.prototype), "value", this).call(this, node)) || void 0;
            }
          }]);
          return IdentAttributor2;
        }(_parchment2.default.Attributor.Class);
        var IndentClass = new IdentAttributor("indent", "ql-indent", {
          scope: _parchment2.default.Scope.BLOCK,
          whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
        });
        exports2.IndentClass = IndentClass;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Blockquote = function(_Block) {
          _inherits(Blockquote2, _Block);
          function Blockquote2() {
            _classCallCheck(this, Blockquote2);
            return _possibleConstructorReturn(this, (Blockquote2.__proto__ || Object.getPrototypeOf(Blockquote2)).apply(this, arguments));
          }
          return Blockquote2;
        }(_block2.default);
        Blockquote.blotName = "blockquote";
        Blockquote.tagName = "blockquote";
        exports2.default = Blockquote;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Header = function(_Block) {
          _inherits(Header2, _Block);
          function Header2() {
            _classCallCheck(this, Header2);
            return _possibleConstructorReturn(this, (Header2.__proto__ || Object.getPrototypeOf(Header2)).apply(this, arguments));
          }
          _createClass(Header2, null, [{
            key: "formats",
            value: function formats(domNode) {
              return this.tagName.indexOf(domNode.tagName) + 1;
            }
          }]);
          return Header2;
        }(_block2.default);
        Header.blotName = "header";
        Header.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
        exports2.default = Header;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.ListItem = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _block = __webpack_require__(4);
        var _block2 = _interopRequireDefault(_block);
        var _container = __webpack_require__(25);
        var _container2 = _interopRequireDefault(_container);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _defineProperty2(obj, key2, value) {
          if (key2 in obj) {
            Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key2] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ListItem = function(_Block) {
          _inherits(ListItem2, _Block);
          function ListItem2() {
            _classCallCheck(this, ListItem2);
            return _possibleConstructorReturn(this, (ListItem2.__proto__ || Object.getPrototypeOf(ListItem2)).apply(this, arguments));
          }
          _createClass(ListItem2, [{
            key: "format",
            value: function format2(name, value) {
              if (name === List.blotName && !value) {
                this.replaceWith(_parchment2.default.create(this.statics.scope));
              } else {
                _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "format", this).call(this, name, value);
              }
            }
          }, {
            key: "remove",
            value: function remove2() {
              if (this.prev == null && this.next == null) {
                this.parent.remove();
              } else {
                _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "remove", this).call(this);
              }
            }
          }, {
            key: "replaceWith",
            value: function replaceWith(name, value) {
              this.parent.isolate(this.offset(this.parent), this.length());
              if (name === this.parent.statics.blotName) {
                this.parent.replaceWith(name, value);
                return this;
              } else {
                this.parent.unwrap();
                return _get(ListItem2.prototype.__proto__ || Object.getPrototypeOf(ListItem2.prototype), "replaceWith", this).call(this, name, value);
              }
            }
          }], [{
            key: "formats",
            value: function formats(domNode) {
              return domNode.tagName === this.tagName ? void 0 : _get(ListItem2.__proto__ || Object.getPrototypeOf(ListItem2), "formats", this).call(this, domNode);
            }
          }]);
          return ListItem2;
        }(_block2.default);
        ListItem.blotName = "list-item";
        ListItem.tagName = "LI";
        var List = function(_Container) {
          _inherits(List2, _Container);
          _createClass(List2, null, [{
            key: "create",
            value: function create(value) {
              var tagName = value === "ordered" ? "OL" : "UL";
              var node = _get(List2.__proto__ || Object.getPrototypeOf(List2), "create", this).call(this, tagName);
              if (value === "checked" || value === "unchecked") {
                node.setAttribute("data-checked", value === "checked");
              }
              return node;
            }
          }, {
            key: "formats",
            value: function formats(domNode) {
              if (domNode.tagName === "OL")
                return "ordered";
              if (domNode.tagName === "UL") {
                if (domNode.hasAttribute("data-checked")) {
                  return domNode.getAttribute("data-checked") === "true" ? "checked" : "unchecked";
                } else {
                  return "bullet";
                }
              }
              return void 0;
            }
          }]);
          function List2(domNode) {
            _classCallCheck(this, List2);
            var _this2 = _possibleConstructorReturn(this, (List2.__proto__ || Object.getPrototypeOf(List2)).call(this, domNode));
            var listEventHandler = function listEventHandler2(e) {
              if (e.target.parentNode !== domNode)
                return;
              var format2 = _this2.statics.formats(domNode);
              var blot = _parchment2.default.find(e.target);
              if (format2 === "checked") {
                blot.format("list", "unchecked");
              } else if (format2 === "unchecked") {
                blot.format("list", "checked");
              }
            };
            domNode.addEventListener("touchstart", listEventHandler);
            domNode.addEventListener("mousedown", listEventHandler);
            return _this2;
          }
          _createClass(List2, [{
            key: "format",
            value: function format2(name, value) {
              if (this.children.length > 0) {
                this.children.tail.format(name, value);
              }
            }
          }, {
            key: "formats",
            value: function formats() {
              return _defineProperty2({}, this.statics.blotName, this.statics.formats(this.domNode));
            }
          }, {
            key: "insertBefore",
            value: function insertBefore(blot, ref2) {
              if (blot instanceof ListItem) {
                _get(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "insertBefore", this).call(this, blot, ref2);
              } else {
                var index2 = ref2 == null ? this.length() : ref2.offset(this);
                var after = this.split(index2);
                after.parent.insertBefore(blot, after);
              }
            }
          }, {
            key: "optimize",
            value: function optimize(context) {
              _get(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "optimize", this).call(this, context);
              var next = this.next;
              if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked")) {
                next.moveChildren(this);
                next.remove();
              }
            }
          }, {
            key: "replace",
            value: function replace(target) {
              if (target.statics.blotName !== this.statics.blotName) {
                var item = _parchment2.default.create(this.statics.defaultChild);
                target.moveChildren(item);
                this.appendChild(item);
              }
              _get(List2.prototype.__proto__ || Object.getPrototypeOf(List2.prototype), "replace", this).call(this, target);
            }
          }]);
          return List2;
        }(_container2.default);
        List.blotName = "list";
        List.scope = _parchment2.default.Scope.BLOCK_BLOT;
        List.tagName = ["OL", "UL"];
        List.defaultChild = "list-item";
        List.allowedChildren = [ListItem];
        exports2.ListItem = ListItem;
        exports2.default = List;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _bold = __webpack_require__(56);
        var _bold2 = _interopRequireDefault(_bold);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Italic = function(_Bold) {
          _inherits(Italic2, _Bold);
          function Italic2() {
            _classCallCheck(this, Italic2);
            return _possibleConstructorReturn(this, (Italic2.__proto__ || Object.getPrototypeOf(Italic2)).apply(this, arguments));
          }
          return Italic2;
        }(_bold2.default);
        Italic.blotName = "italic";
        Italic.tagName = ["EM", "I"];
        exports2.default = Italic;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Script = function(_Inline) {
          _inherits(Script2, _Inline);
          function Script2() {
            _classCallCheck(this, Script2);
            return _possibleConstructorReturn(this, (Script2.__proto__ || Object.getPrototypeOf(Script2)).apply(this, arguments));
          }
          _createClass(Script2, null, [{
            key: "create",
            value: function create(value) {
              if (value === "super") {
                return document.createElement("sup");
              } else if (value === "sub") {
                return document.createElement("sub");
              } else {
                return _get(Script2.__proto__ || Object.getPrototypeOf(Script2), "create", this).call(this, value);
              }
            }
          }, {
            key: "formats",
            value: function formats(domNode) {
              if (domNode.tagName === "SUB")
                return "sub";
              if (domNode.tagName === "SUP")
                return "super";
              return void 0;
            }
          }]);
          return Script2;
        }(_inline2.default);
        Script.blotName = "script";
        Script.tagName = ["SUB", "SUP"];
        exports2.default = Script;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Strike = function(_Inline) {
          _inherits(Strike2, _Inline);
          function Strike2() {
            _classCallCheck(this, Strike2);
            return _possibleConstructorReturn(this, (Strike2.__proto__ || Object.getPrototypeOf(Strike2)).apply(this, arguments));
          }
          return Strike2;
        }(_inline2.default);
        Strike.blotName = "strike";
        Strike.tagName = "S";
        exports2.default = Strike;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _inline = __webpack_require__(6);
        var _inline2 = _interopRequireDefault(_inline);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Underline = function(_Inline) {
          _inherits(Underline2, _Inline);
          function Underline2() {
            _classCallCheck(this, Underline2);
            return _possibleConstructorReturn(this, (Underline2.__proto__ || Object.getPrototypeOf(Underline2)).apply(this, arguments));
          }
          return Underline2;
        }(_inline2.default);
        Underline.blotName = "underline";
        Underline.tagName = "U";
        exports2.default = Underline;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _link = __webpack_require__(27);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ATTRIBUTES = ["alt", "height", "width"];
        var Image = function(_Parchment$Embed) {
          _inherits(Image2, _Parchment$Embed);
          function Image2() {
            _classCallCheck(this, Image2);
            return _possibleConstructorReturn(this, (Image2.__proto__ || Object.getPrototypeOf(Image2)).apply(this, arguments));
          }
          _createClass(Image2, [{
            key: "format",
            value: function format2(name, value) {
              if (ATTRIBUTES.indexOf(name) > -1) {
                if (value) {
                  this.domNode.setAttribute(name, value);
                } else {
                  this.domNode.removeAttribute(name);
                }
              } else {
                _get(Image2.prototype.__proto__ || Object.getPrototypeOf(Image2.prototype), "format", this).call(this, name, value);
              }
            }
          }], [{
            key: "create",
            value: function create(value) {
              var node = _get(Image2.__proto__ || Object.getPrototypeOf(Image2), "create", this).call(this, value);
              if (typeof value === "string") {
                node.setAttribute("src", this.sanitize(value));
              }
              return node;
            }
          }, {
            key: "formats",
            value: function formats(domNode) {
              return ATTRIBUTES.reduce(function(formats2, attribute) {
                if (domNode.hasAttribute(attribute)) {
                  formats2[attribute] = domNode.getAttribute(attribute);
                }
                return formats2;
              }, {});
            }
          }, {
            key: "match",
            value: function match(url2) {
              return /\.(jpe?g|gif|png)$/.test(url2) || /^data:image\/.+;base64/.test(url2);
            }
          }, {
            key: "sanitize",
            value: function sanitize(url2) {
              return (0, _link.sanitize)(url2, ["http", "https", "data"]) ? url2 : "//:0";
            }
          }, {
            key: "value",
            value: function value(domNode) {
              return domNode.getAttribute("src");
            }
          }]);
          return Image2;
        }(_parchment2.default.Embed);
        Image.blotName = "image";
        Image.tagName = "IMG";
        exports2.default = Image;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _block = __webpack_require__(4);
        var _link = __webpack_require__(27);
        var _link2 = _interopRequireDefault(_link);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var ATTRIBUTES = ["height", "width"];
        var Video = function(_BlockEmbed) {
          _inherits(Video2, _BlockEmbed);
          function Video2() {
            _classCallCheck(this, Video2);
            return _possibleConstructorReturn(this, (Video2.__proto__ || Object.getPrototypeOf(Video2)).apply(this, arguments));
          }
          _createClass(Video2, [{
            key: "format",
            value: function format2(name, value) {
              if (ATTRIBUTES.indexOf(name) > -1) {
                if (value) {
                  this.domNode.setAttribute(name, value);
                } else {
                  this.domNode.removeAttribute(name);
                }
              } else {
                _get(Video2.prototype.__proto__ || Object.getPrototypeOf(Video2.prototype), "format", this).call(this, name, value);
              }
            }
          }], [{
            key: "create",
            value: function create(value) {
              var node = _get(Video2.__proto__ || Object.getPrototypeOf(Video2), "create", this).call(this, value);
              node.setAttribute("frameborder", "0");
              node.setAttribute("allowfullscreen", true);
              node.setAttribute("src", this.sanitize(value));
              return node;
            }
          }, {
            key: "formats",
            value: function formats(domNode) {
              return ATTRIBUTES.reduce(function(formats2, attribute) {
                if (domNode.hasAttribute(attribute)) {
                  formats2[attribute] = domNode.getAttribute(attribute);
                }
                return formats2;
              }, {});
            }
          }, {
            key: "sanitize",
            value: function sanitize(url2) {
              return _link2.default.sanitize(url2);
            }
          }, {
            key: "value",
            value: function value(domNode) {
              return domNode.getAttribute("src");
            }
          }]);
          return Video2;
        }(_block.BlockEmbed);
        Video.blotName = "video";
        Video.className = "ql-video";
        Video.tagName = "IFRAME";
        exports2.default = Video;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.FormulaBlot = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _embed = __webpack_require__(35);
        var _embed2 = _interopRequireDefault(_embed);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var FormulaBlot = function(_Embed) {
          _inherits(FormulaBlot2, _Embed);
          function FormulaBlot2() {
            _classCallCheck(this, FormulaBlot2);
            return _possibleConstructorReturn(this, (FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2)).apply(this, arguments));
          }
          _createClass(FormulaBlot2, null, [{
            key: "create",
            value: function create(value) {
              var node = _get(FormulaBlot2.__proto__ || Object.getPrototypeOf(FormulaBlot2), "create", this).call(this, value);
              if (typeof value === "string") {
                window.katex.render(value, node, {
                  throwOnError: false,
                  errorColor: "#f00"
                });
                node.setAttribute("data-value", value);
              }
              return node;
            }
          }, {
            key: "value",
            value: function value(domNode) {
              return domNode.getAttribute("data-value");
            }
          }]);
          return FormulaBlot2;
        }(_embed2.default);
        FormulaBlot.blotName = "formula";
        FormulaBlot.className = "ql-formula";
        FormulaBlot.tagName = "SPAN";
        var Formula = function(_Module) {
          _inherits(Formula2, _Module);
          _createClass(Formula2, null, [{
            key: "register",
            value: function register2() {
              _quill2.default.register(FormulaBlot, true);
            }
          }]);
          function Formula2() {
            _classCallCheck(this, Formula2);
            var _this2 = _possibleConstructorReturn(this, (Formula2.__proto__ || Object.getPrototypeOf(Formula2)).call(this));
            if (window.katex == null) {
              throw new Error("Formula module requires KaTeX.");
            }
            return _this2;
          }
          return Formula2;
        }(_module2.default);
        exports2.FormulaBlot = FormulaBlot;
        exports2.default = Formula;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.CodeToken = exports2.CodeBlock = void 0;
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _parchment = __webpack_require__(0);
        var _parchment2 = _interopRequireDefault(_parchment);
        var _quill = __webpack_require__(5);
        var _quill2 = _interopRequireDefault(_quill);
        var _module = __webpack_require__(9);
        var _module2 = _interopRequireDefault(_module);
        var _code = __webpack_require__(13);
        var _code2 = _interopRequireDefault(_code);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var SyntaxCodeBlock = function(_CodeBlock) {
          _inherits(SyntaxCodeBlock2, _CodeBlock);
          function SyntaxCodeBlock2() {
            _classCallCheck(this, SyntaxCodeBlock2);
            return _possibleConstructorReturn(this, (SyntaxCodeBlock2.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2)).apply(this, arguments));
          }
          _createClass(SyntaxCodeBlock2, [{
            key: "replaceWith",
            value: function replaceWith(block) {
              this.domNode.textContent = this.domNode.textContent;
              this.attach();
              _get(SyntaxCodeBlock2.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock2.prototype), "replaceWith", this).call(this, block);
            }
          }, {
            key: "highlight",
            value: function highlight(_highlight) {
              var text = this.domNode.textContent;
              if (this.cachedText !== text) {
                if (text.trim().length > 0 || this.cachedText == null) {
                  this.domNode.innerHTML = _highlight(text);
                  this.domNode.normalize();
                  this.attach();
                }
                this.cachedText = text;
              }
            }
          }]);
          return SyntaxCodeBlock2;
        }(_code2.default);
        SyntaxCodeBlock.className = "ql-syntax";
        var CodeToken = new _parchment2.default.Attributor.Class("token", "hljs", {
          scope: _parchment2.default.Scope.INLINE
        });
        var Syntax = function(_Module) {
          _inherits(Syntax2, _Module);
          _createClass(Syntax2, null, [{
            key: "register",
            value: function register2() {
              _quill2.default.register(CodeToken, true);
              _quill2.default.register(SyntaxCodeBlock, true);
            }
          }]);
          function Syntax2(quill2, options2) {
            _classCallCheck(this, Syntax2);
            var _this2 = _possibleConstructorReturn(this, (Syntax2.__proto__ || Object.getPrototypeOf(Syntax2)).call(this, quill2, options2));
            if (typeof _this2.options.highlight !== "function") {
              throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
            }
            var timer = null;
            _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {
              clearTimeout(timer);
              timer = setTimeout(function() {
                _this2.highlight();
                timer = null;
              }, _this2.options.interval);
            });
            _this2.highlight();
            return _this2;
          }
          _createClass(Syntax2, [{
            key: "highlight",
            value: function highlight() {
              var _this3 = this;
              if (this.quill.selection.composing)
                return;
              this.quill.update(_quill2.default.sources.USER);
              var range3 = this.quill.getSelection();
              this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {
                code.highlight(_this3.options.highlight);
              });
              this.quill.update(_quill2.default.sources.SILENT);
              if (range3 != null) {
                this.quill.setSelection(range3, _quill2.default.sources.SILENT);
              }
            }
          }]);
          return Syntax2;
        }(_module2.default);
        Syntax.DEFAULTS = {
          highlight: function() {
            if (window.hljs == null)
              return null;
            return function(text) {
              var result = window.hljs.highlightAuto(text);
              return result.value;
            };
          }(),
          interval: 1e3
        };
        exports2.CodeBlock = SyntaxCodeBlock;
        exports2.CodeToken = CodeToken;
        exports2.default = Syntax;
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
      },
      function(module2, exports2) {
        module2.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.default = exports2.BubbleTooltip = void 0;
        var _get = function get(object4, property, receiver) {
          if (object4 === null)
            object4 = Function.prototype;
          var desc = Object.getOwnPropertyDescriptor(object4, property);
          if (desc === void 0) {
            var parent = Object.getPrototypeOf(object4);
            if (parent === null) {
              return void 0;
            } else {
              return get(parent, property, receiver);
            }
          } else if ("value" in desc) {
            return desc.value;
          } else {
            var getter = desc.get;
            if (getter === void 0) {
              return void 0;
            }
            return getter.call(receiver);
          }
        };
        var _createClass = function() {
          function defineProperties(target, props2) {
            for (var i = 0; i < props2.length; i++) {
              var descriptor = props2[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var _extend = __webpack_require__(3);
        var _extend2 = _interopRequireDefault(_extend);
        var _emitter = __webpack_require__(8);
        var _emitter2 = _interopRequireDefault(_emitter);
        var _base = __webpack_require__(43);
        var _base2 = _interopRequireDefault(_base);
        var _selection = __webpack_require__(15);
        var _icons = __webpack_require__(41);
        var _icons2 = _interopRequireDefault(_icons);
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _possibleConstructorReturn(self2, call) {
          if (!self2) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return call && (typeof call === "object" || typeof call === "function") ? call : self2;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
          if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
        var BubbleTheme = function(_BaseTheme) {
          _inherits(BubbleTheme2, _BaseTheme);
          function BubbleTheme2(quill2, options2) {
            _classCallCheck(this, BubbleTheme2);
            if (options2.modules.toolbar != null && options2.modules.toolbar.container == null) {
              options2.modules.toolbar.container = TOOLBAR_CONFIG;
            }
            var _this = _possibleConstructorReturn(this, (BubbleTheme2.__proto__ || Object.getPrototypeOf(BubbleTheme2)).call(this, quill2, options2));
            _this.quill.container.classList.add("ql-bubble");
            return _this;
          }
          _createClass(BubbleTheme2, [{
            key: "extendToolbar",
            value: function extendToolbar(toolbar) {
              this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
              this.tooltip.root.appendChild(toolbar.container);
              this.buildButtons([].slice.call(toolbar.container.querySelectorAll("button")), _icons2.default);
              this.buildPickers([].slice.call(toolbar.container.querySelectorAll("select")), _icons2.default);
            }
          }]);
          return BubbleTheme2;
        }(_base2.default);
        BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
          modules: {
            toolbar: {
              handlers: {
                link: function link(value) {
                  if (!value) {
                    this.quill.format("link", false);
                  } else {
                    this.quill.theme.tooltip.edit();
                  }
                }
              }
            }
          }
        });
        var BubbleTooltip = function(_BaseTooltip) {
          _inherits(BubbleTooltip2, _BaseTooltip);
          function BubbleTooltip2(quill2, bounds) {
            _classCallCheck(this, BubbleTooltip2);
            var _this2 = _possibleConstructorReturn(this, (BubbleTooltip2.__proto__ || Object.getPrototypeOf(BubbleTooltip2)).call(this, quill2, bounds));
            _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type4, range3, oldRange, source) {
              if (type4 !== _emitter2.default.events.SELECTION_CHANGE)
                return;
              if (range3 != null && range3.length > 0 && source === _emitter2.default.sources.USER) {
                _this2.show();
                _this2.root.style.left = "0px";
                _this2.root.style.width = "";
                _this2.root.style.width = _this2.root.offsetWidth + "px";
                var lines = _this2.quill.getLines(range3.index, range3.length);
                if (lines.length === 1) {
                  _this2.position(_this2.quill.getBounds(range3));
                } else {
                  var lastLine = lines[lines.length - 1];
                  var index2 = _this2.quill.getIndex(lastLine);
                  var length = Math.min(lastLine.length() - 1, range3.index + range3.length - index2);
                  var _bounds = _this2.quill.getBounds(new _selection.Range(index2, length));
                  _this2.position(_bounds);
                }
              } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
                _this2.hide();
              }
            });
            return _this2;
          }
          _createClass(BubbleTooltip2, [{
            key: "listen",
            value: function listen() {
              var _this3 = this;
              _get(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "listen", this).call(this);
              this.root.querySelector(".ql-close").addEventListener("click", function() {
                _this3.root.classList.remove("ql-editing");
              });
              this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {
                setTimeout(function() {
                  if (_this3.root.classList.contains("ql-hidden"))
                    return;
                  var range3 = _this3.quill.getSelection();
                  if (range3 != null) {
                    _this3.position(_this3.quill.getBounds(range3));
                  }
                }, 1);
              });
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this.show();
            }
          }, {
            key: "position",
            value: function position(reference2) {
              var shift = _get(BubbleTooltip2.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip2.prototype), "position", this).call(this, reference2);
              var arrow2 = this.root.querySelector(".ql-tooltip-arrow");
              arrow2.style.marginLeft = "";
              if (shift === 0)
                return shift;
              arrow2.style.marginLeft = -1 * shift - arrow2.offsetWidth / 2 + "px";
            }
          }]);
          return BubbleTooltip2;
        }(_base.BaseTooltip);
        BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
        exports2.BubbleTooltip = BubbleTooltip;
        exports2.default = BubbleTheme;
      },
      function(module2, exports2, __webpack_require__) {
        module2.exports = __webpack_require__(63);
      }
    ])["default"];
  });
})(quill);
var Quill = /* @__PURE__ */ getDefaultExportFromCjs(quill.exports);
const defaultOptions = {
  theme: "snow",
  boundary: document.body,
  modules: {
    toolbar: [
      ["bold", "italic", "underline", "strike"],
      ["blockquote", "code-block"],
      [{ header: 1 }, { header: 2 }],
      [{ list: "ordered" }, { list: "bullet" }],
      [{ script: "sub" }, { script: "super" }],
      [{ indent: "-1" }, { indent: "+1" }],
      [{ direction: "rtl" }],
      [{ size: ["small", false, "large", "huge"] }],
      [{ header: [1, 2, 3, 4, 5, 6, false] }],
      [{ color: [] }, { background: [] }],
      [{ font: [] }],
      [{ align: [] }],
      ["clean"],
      ["link", "image", "video"]
    ]
  },
  placeholder: "Insert content here ...",
  readOnly: false
};
const _sfc_main$1D = {
  name: "quill-editor",
  props: {
    content: String,
    value: String,
    disabled: {
      type: Boolean,
      default: false
    },
    options: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  emits: ["ready", "change", "input", "blur", "focus", "update:value"],
  setup(props2, context) {
    const state = {
      editorOption: {},
      quill: null
    };
    let _content = "";
    watch(() => props2.value, (val) => {
      if (state.quill) {
        if (val && val !== _content) {
          _content = val;
          state.quill.pasteHTML(val);
        } else if (!val) {
          state.quill.setText("");
        }
      }
    });
    watch(() => props2.content, (val) => {
      if (state.quill) {
        if (val && val !== _content) {
          _content = val;
          state.quill.pasteHTML(val);
        } else if (!val) {
          state.quill.setText("");
        }
      }
    });
    watch(() => props2.disabled, (val) => {
      if (state.quill) {
        state.quill.enable(!val);
      }
    });
    watch(() => props2.options.placeholder, (val) => {
      if (state.quill) {
        state.quill.root.dataset.placeholder = val;
      }
    });
    const editor = ref(null);
    const mergeOptions2 = (def, custom) => {
      for (const key2 in custom) {
        if (!def[key2] || key2 !== "modules") {
          def[key2] = custom[key2];
        } else {
          mergeOptions2(def[key2], custom[key2]);
        }
      }
      return def;
    };
    const initialize = () => {
      if (editor.value) {
        state.editorOption = mergeOptions2(defaultOptions, props2.options);
        state.quill = new Quill(editor.value, state.editorOption);
        if (props2.value) {
          state.quill.pasteHTML(props2.value);
        }
        state.quill.on("selection-change", (range3) => {
          if (!range3) {
            context.emit("blur", state.quill);
          } else {
            context.emit("focus", state.quill);
          }
        });
        state.quill.on("text-change", () => {
          if (props2.disabled) {
            state.quill.enable(false);
          }
          let html = editor.value.children[0].innerHTML;
          const quill2 = state.quill;
          const text = state.quill.getText();
          if (html === "<p><br></p>")
            html = "";
          _content = html;
          context.emit("update:value", _content);
          context.emit("change", { html, text, quill: quill2 });
        });
        context.emit("ready", state.quill);
      }
    };
    onBeforeUnmount(() => {
      const editorToolbar = editor.value.previousSibling;
      if (editorToolbar && editorToolbar.className.indexOf("ql-toolbar") > -1) {
        editorToolbar.parentNode.removeChild(editorToolbar);
      }
    });
    onMounted(() => {
      initialize();
    });
    onUnmounted(() => {
      state.quill = null;
    });
    return { editor };
  }
};
const _hoisted_1$p = { ref: "editor" };
function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", _hoisted_1$p, null, 512);
}
var __unplugin_components_0$4 = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["render", _sfc_render$1D]]);
const _sfc_main$1C = {
  name: "editorRender",
  components: { ElFormItem, quillEditor: __unplugin_components_0$4 },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_quill_editor = __unplugin_components_0$4;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_quill_editor, {
        value: $props.modelValue,
        onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.html)),
        disabled: $props.options.disabled,
        options: { placeholder: $props.options.placeholder, readOnly: false },
        style: normalizeStyle({ height: $props.options.height })
      }, null, 8, ["value", "disabled", "options", "style"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var editorRender = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$1C]]);
var __glob_0_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editorRender
});
const _sfc_main$1B = {
  name: "inputRender",
  components: { ElFormItem, ElInput },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_input, {
        type: "text",
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        "show-password": $props.options.showPassword,
        "prefix-icon": $props.options.prefixIcon,
        "suffix-icon": $props.options.suffixIcon,
        maxlength: $props.options.maxlength,
        "show-word-limit": $props.options.showWordLimit
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "show-password", "prefix-icon", "suffix-icon", "maxlength", "show-word-limit"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var inputRender = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["render", _sfc_render$1B]]);
var __glob_0_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": inputRender
});
var elOption = "";
var elOptionGroup = "";
var elSelect = "";
const _sfc_main$1A = {
  name: "multiSelectRender",
  components: { ElFormItem, ElSelect, ElOption },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;
  const _component_el_select = ElSelect;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_select, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        multiple: true,
        "collapse-tags": $props.options.collapseTags,
        "multiple-limit": $props.options.multipleLimit,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        filterable: $props.options.filterable,
        placeholder: $props.options.placeholder,
        "no-data-text": $props.options.noDataText,
        "no-match-text": $props.options.noMatchText
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_option, {
              key: item.value,
              label: item.label,
              value: item.value
            }, null, 8, ["label", "value"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "collapse-tags", "multiple-limit", "clearable", "disabled", "filterable", "placeholder", "no-data-text", "no-match-text"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var multiSelectRender = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["render", _sfc_render$1A]]);
var __glob_0_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": multiSelectRender
});
var elInputNumber = "";
const _sfc_main$1z = {
  name: "numberRender",
  components: { ElFormItem, ElInputNumber },
  props: {
    path: String,
    modelValue: Number,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_input_number, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        min: $props.options.min,
        max: $props.options.max,
        disabled: $props.options.disabled
      }, null, 8, ["model-value", "min", "max", "disabled"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var numberRender = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["render", _sfc_render$1z]]);
var __glob_0_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": numberRender
});
var elRadioGroup = "";
const _sfc_main$1y = {
  name: "radioRender",
  components: { ElFormItem, ElRadioGroup, ElRadio },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio = ElRadio;
  const _component_el_radio_group = ElRadioGroup;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_group, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_radio, {
              key: item.value,
              label: item.value
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(item.label), 1)
              ]),
              _: 2
            }, 1032, ["label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var radioRender = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["render", _sfc_render$1y]]);
var __glob_0_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": radioRender
});
var elRate = "";
const _sfc_main$1x = {
  name: "rateRender",
  components: { ElFormItem, ElRate },
  props: {
    path: String,
    modelValue: Number,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_rate = ElRate;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_rate, {
        class: "form-rate",
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled,
        "allow-half": $props.options.allowHalf,
        max: $props.options.max
      }, null, 8, ["model-value", "disabled", "allow-half", "max"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var rateRender = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["render", _sfc_render$1x]]);
var __glob_0_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rateRender
});
const _sfc_main$1w = {
  name: "selectRender",
  components: { ElFormItem, ElSelect, ElOption },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;
  const _component_el_select = ElSelect;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_select, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        filterable: $props.options.filterable,
        placeholder: $props.options.placeholder,
        "no-data-text": $props.options.noDataText,
        "no-match-text": $props.options.noMatchText
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_option, {
              key: item.value,
              label: item.label,
              value: item.value
            }, null, 8, ["label", "value"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "clearable", "disabled", "filterable", "placeholder", "no-data-text", "no-match-text"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var selectRender = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$1w]]);
var __glob_0_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": selectRender
});
var elSlider = "";
const _sfc_main$1v = {
  name: "sliderRender",
  components: { ElFormItem, ElSlider },
  props: {
    path: String,
    modelValue: Number,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_slider, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled,
        min: $props.options.min,
        max: $props.options.max,
        step: $props.options.step,
        "show-stops": $props.options.showStops,
        "show-input": $props.options.showInput,
        "show-tooltip": $props.options.showToolTip
      }, null, 8, ["model-value", "disabled", "min", "max", "step", "show-stops", "show-input", "show-tooltip"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var sliderRender = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$1v]]);
var __glob_0_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sliderRender
});
var elSwitch = "";
const _sfc_main$1u = {
  name: "switchRender",
  components: { ElFormItem, ElSwitch },
  props: {
    path: String,
    modelValue: Boolean,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_switch = ElSwitch;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_switch, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        disabled: $props.options.disabled,
        "active-text": $props.options.activeText,
        "inactive-text": $props.options.inactiveText,
        "active-color": $props.options.activeColor,
        "inactive-color": $props.options.inactiveColor
      }, null, 8, ["model-value", "disabled", "active-text", "inactive-text", "active-color", "inactive-color"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var switchRender = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$1u]]);
var __glob_0_15 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": switchRender
});
var elTableColumn = "";
var elTable = "";
var elDialog = "";
var elOverlay = "";
var tableRender_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1t = {
  name: "tableRender",
  components: {
    ElFormItem,
    ElButton,
    ElTable,
    ElTableColumn,
    ElDialog,
    FormRender: defineAsyncComponent(() => Promise.resolve().then(function() {
      return index$2;
    }))
  },
  props: {
    path: String,
    modelValue: Array,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const state = inject("state");
    const data = reactive({
      items: []
    });
    const formRender = ref(null);
    const formDialog = reactive({
      title: "",
      isShow: false
    });
    const setInternal = () => {
      data.items = deepClone(props2.modelValue);
    };
    onMounted(setInternal);
    watch(() => props2.modelValue, setInternal);
    const add = () => {
      formDialog.title = "\u6DFB\u52A0";
      formDialog.isShow = true;
      nextTick(() => {
        formRender.value && formRender.value.init(Object.assign({}, state.formDesign, { items: props2.items }));
      });
    };
    const edit = (item) => {
      formDialog.title = "\u7F16\u8F91";
      formDialog.isShow = true;
      nextTick(() => {
        formRender.value && formRender.value.init(Object.assign({}, state.formDesign, { items: props2.items }), item);
      });
    };
    const remove2 = (index2) => {
      data.items.splice(index2, 1);
      emit2("update:modelValue", data.items);
    };
    const save2 = (result) => {
      data.items.push(result);
      formDialog.isShow = false;
      emit2("update:modelValue", data.items);
    };
    return {
      data,
      formRender,
      formDialog,
      add,
      edit,
      remove: remove2,
      save: save2
    };
  }
};
const _hoisted_1$o = { class: "tools" };
const _hoisted_2$k = /* @__PURE__ */ createTextVNode("\u6DFB\u52A0");
function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = ElButton;
  const _component_el_table_column = ElTableColumn;
  const _component_el_table = ElTable;
  const _component_el_form_item = ElFormItem;
  const _component_form_render = FormRender;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_el_form_item, {
      prop: $props.path,
      label: $props.options.label,
      rules: $props.options.rules
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$o, [
          createVNode(_component_el_button, {
            class: "add-btn",
            type: "primary",
            icon: "el-icon-plus",
            onClick: $setup.add
          }, {
            default: withCtx(() => [
              _hoisted_2$k
            ]),
            _: 1
          }, 8, ["onClick"])
        ]),
        createVNode(_component_el_table, {
          class: "edit-table",
          data: $setup.data.items,
          style: { "width": "100%" },
          border: ""
        }, {
          default: withCtx(() => [
            createVNode(_component_el_table_column, {
              type: "index",
              width: "50",
              label: "\u5E8F\u53F7",
              align: "center"
            }),
            (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, index2) => {
              return openBlock(), createBlock(_component_el_table_column, {
                key: index2,
                prop: item.options.key,
                label: item.options.label
              }, null, 8, ["prop", "label"]);
            }), 128)),
            createVNode(_component_el_table_column, {
              label: "\u64CD\u4F5C",
              align: "center",
              width: "120",
              "class-name": "small-padding"
            }, {
              default: withCtx((scope) => [
                createVNode(_component_el_button, {
                  type: "primary",
                  icon: "el-icon-edit",
                  circle: "",
                  onClick: ($event) => $setup.edit(scope.row)
                }, null, 8, ["onClick"]),
                createVNode(_component_el_button, {
                  type: "danger",
                  icon: "el-icon-delete",
                  circle: "",
                  onClick: ($event) => $setup.remove(scope.$index)
                }, null, 8, ["onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["data"])
      ]),
      _: 1
    }, 8, ["prop", "label", "rules"]),
    createVNode(_component_el_dialog, {
      title: $setup.formDialog.title,
      modelValue: $setup.formDialog.isShow,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.formDialog.isShow = $event),
      "close-on-click-modal": false,
      width: "750px"
    }, {
      default: withCtx(() => [
        createVNode(_component_form_render, {
          ref: "formRender",
          onSubmit: $setup.save
        }, null, 8, ["onSubmit"])
      ]),
      _: 1
    }, 8, ["title", "modelValue"])
  ], 64);
}
var tableRender = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["render", _sfc_render$1t], ["__scopeId", "data-v-2d959615"]]);
var __glob_0_16 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tableRender
});
var elTabPane = "";
var elTabs = "";
const _sfc_main$1s = {
  name: "tabsRender",
  components: { ElFormItem, ElTabs, ElTabPane, objectRender: __unplugin_components_0$5 },
  props: {
    path: String,
    modelValue: Object,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const tabsValue = ref("");
    const emitter = inject("emitter");
    const update = (key2, value) => {
      emit2("update:modelValue", Object.assign({}, props2.modelValue, { [key2]: value }));
    };
    onMounted(() => {
      tabsValue.value = props2.items.length ? props2.items[0].options.key : "";
      emitter.on("validateError", (path) => {
        for (let i = 0; i < props2.items.length; i++) {
          const item = props2.items[i];
          if (path.indexOf(props2.path + "." + item.options.key) > -1) {
            return tabsValue.value = item.options.key;
          }
        }
      });
    });
    return {
      tabsValue,
      update
    };
  }
};
function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_object_render = __unplugin_components_0$5;
  const _component_el_tab_pane = ElTabPane;
  const _component_el_tabs = ElTabs;
  return openBlock(), createBlock(_component_el_tabs, {
    modelValue: $setup.tabsValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.tabsValue = $event),
    type: $props.options.tabType,
    "tab-position": $props.options.tabPosition
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item) => {
        return openBlock(), createBlock(_component_el_tab_pane, {
          key: item.name,
          label: item.options.label,
          name: item.options.key
        }, {
          default: withCtx(() => [
            createVNode(_component_object_render, {
              items: item.items,
              options: item.options,
              path: $props.path + "." + item.options.key,
              "model-value": $props.modelValue[item.options.key],
              "onUpdate:modelValue": ($event) => $setup.update(item.options.key, $event)
            }, null, 8, ["items", "options", "path", "model-value", "onUpdate:modelValue"])
          ]),
          _: 2
        }, 1032, ["label", "name"]);
      }), 128))
    ]),
    _: 1
  }, 8, ["modelValue", "type", "tab-position"]);
}
var tabsRender = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["render", _sfc_render$1s]]);
var __glob_0_17 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tabsRender
});
const _sfc_main$1r = {
  name: "textareaRender",
  components: { ElFormItem, ElInput },
  props: {
    path: String,
    modelValue: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_input, {
        type: "textarea",
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        rows: $props.options.rows,
        disabled: $props.options.disabled,
        maxlength: $props.options.maxlength,
        "show-word-limit": $props.options.showWordLimit
      }, null, 8, ["model-value", "placeholder", "rows", "disabled", "maxlength", "show-word-limit"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var textareaRender = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["render", _sfc_render$1r]]);
var __glob_0_18 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": textareaRender
});
var elTimePicker = "";
const _sfc_main$1q = {
  name: "timePickerRender",
  components: { ElFormItem, ElTimePicker },
  props: {
    path: String,
    modelValue: Date,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_time_picker = ElTimePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_time_picker, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var timePickerRender = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["render", _sfc_render$1q]]);
var __glob_0_19 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": timePickerRender
});
const _sfc_main$1p = {
  name: "timeRangePickerRender",
  components: { ElFormItem, ElTimePicker },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_time_picker = ElTimePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_time_picker, {
        "is-range": "",
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var timeRangePickerRender = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$1p]]);
var __glob_0_20 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": timeRangePickerRender
});
var elUpload = "";
var elProgress = "";
const _sfc_main$1o = {
  name: "uploadRender",
  components: { ElFormItem, ElUpload, ElButton },
  props: {
    path: String,
    modelValue: Array,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const data = reactive({
      fileList: []
    });
    const setInternal = () => {
      data.fileList = deepClone(props2.modelValue);
    };
    onMounted(setInternal);
    watch(() => props2.modelValue, setInternal);
    const beforeUpload = (file) => {
      const uploadSize2 = props2.options.uploadSize;
      const size2 = parseFloat(uploadSize2);
      const unitMap = { KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };
      const unit = unitMap[uploadSize2.substr(uploadSize2.length - 2)];
      const isOverLimit = file.size / unit < size2;
      if (!isOverLimit) {
        ElMessage.error(`\u4E0A\u4F20\u6587\u4EF6\u5927\u5C0F\u4E0D\u80FD\u8D85\u8FC7 ${uploadSize2}!`);
      }
      return isOverLimit;
    };
    const handleChange = (file, fileList) => {
      const files = [];
      fileList.forEach((item) => {
        files.push(__spreadValues({
          name: item.name
        }, item.response));
      });
      emit2("update:modelValue", files);
    };
    const beforeRemove = (file, fileList) => {
      return ElMessageBox.confirm(`\u786E\u5B9A\u79FB\u9664 ${file.name}\uFF1F`);
    };
    const handleError = () => {
      ElMessage.error(`\u4E0A\u4F20\u5931\u8D25!`);
    };
    return {
      data,
      beforeUpload,
      handleChange,
      beforeRemove,
      handleError
    };
  }
};
const _hoisted_1$n = { class: "el-upload__tip" };
function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = ElButton;
  const _component_el_upload = ElUpload;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_el_upload, {
        action: $props.options.uploadUrl,
        name: $props.options.uploadName,
        multiple: $props.options.multiple,
        data: $props.options.uploadData,
        headers: $props.options.uploadHeaders,
        "show-file-list": $props.options.showFileList,
        limit: $props.options.limit,
        "file-list": $setup.data.fileList,
        disabled: $props.options.disabled,
        "before-upload": $setup.beforeUpload,
        "on-success": $setup.handleChange,
        "on-remove": $setup.handleChange,
        "before-remove": $setup.beforeRemove,
        "on-error": $setup.handleError
      }, createSlots({
        default: withCtx(() => [
          createVNode(_component_el_button, {
            size: "small",
            type: "primary"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.options.buttonText), 1)
            ]),
            _: 1
          })
        ]),
        _: 2
      }, [
        $props.options.showToolTip ? {
          name: "tip",
          fn: withCtx(() => [
            createElementVNode("div", _hoisted_1$n, toDisplayString($props.options.tip), 1)
          ])
        } : void 0
      ]), 1032, ["action", "name", "multiple", "data", "headers", "show-file-list", "limit", "file-list", "disabled", "before-upload", "on-success", "on-remove", "before-remove", "on-error"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var uploadRender = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$1o]]);
var __glob_0_21 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadRender
});
const components$2 = {};
Object.values({ "./components/card-render.vue": __glob_0_0, "./components/cascader-render.vue": __glob_0_1, "./components/checkbox-render.vue": __glob_0_2, "./components/color-picker-render.vue": __glob_0_3, "./components/date-picker-render.vue": __glob_0_4, "./components/date-range-picker-render.vue": __glob_0_5, "./components/editor-render.vue": __glob_0_6, "./components/input-render.vue": __glob_0_7, "./components/multi-select-render.vue": __glob_0_8, "./components/number-render.vue": __glob_0_9, "./components/object-render.vue": __glob_0_10, "./components/radio-render.vue": __glob_0_11, "./components/rate-render.vue": __glob_0_12, "./components/select-render.vue": __glob_0_13, "./components/slider-render.vue": __glob_0_14, "./components/switch-render.vue": __glob_0_15, "./components/table-render.vue": __glob_0_16, "./components/tabs-render.vue": __glob_0_17, "./components/textarea-render.vue": __glob_0_18, "./components/time-picker-render.vue": __glob_0_19, "./components/time-range-picker-render.vue": __glob_0_20, "./components/upload-render.vue": __glob_0_21 }).forEach(({ default: component }) => components$2[component.name] = component);
const _sfc_main$1n = {
  name: "formRenderItem",
  components: __spreadValues({}, components$2),
  props: {
    path: {
      type: String,
      default: ""
    },
    component: String,
    modelValue: [String, Number, Boolean, Date, Object, Array],
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  return !$props.options.hidden ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "form-item",
    style: normalizeStyle({ width: $props.options.width })
  }, [
    (openBlock(), createBlock(resolveDynamicComponent($props.component + "-render"), {
      items: $props.items,
      options: $props.options,
      "model-value": $props.modelValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
      path: $props.path
    }, null, 8, ["items", "options", "model-value", "path"]))
  ], 4)) : createCommentVNode("", true);
}
var __unplugin_components_0$3 = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$1n]]);
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __unplugin_components_0$3
});
var elForm = "";
function mitt(n) {
  return { all: n = n || new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
const _sfc_main$1m = {
  name: "formRender",
  components: { ElForm, FormRenderItem: __unplugin_components_0$3, ElButton },
  props: {},
  setup(props2, { emit: emit2 }) {
    const formRef = ref(null);
    const formDesign = reactive({
      uuid: "",
      items: [],
      options: {}
    });
    const formData = reactive({
      root: {}
    });
    const emitter = mitt();
    const traverse = (items, form2, data = {}) => {
      items.forEach((item) => {
        const key2 = item.options.key;
        form2[key2] = data[key2] || item.options.defaultValue;
        for (let option2 in item.options) {
          if (validateInterpolation(item.options[option2])) {
            const functionBody = new Function("root", "options", `try {
                return ${getInterpolation(item.options[option2])}
              } catch(e) {
                console.log(e)
              }`);
            item.options[option2] = computed({
              get() {
                return functionBody(formData.root, item.options);
              }
            });
          }
        }
        if (item.items) {
          traverse(item.items, form2[key2], data[key2]);
        }
      });
    };
    const init = (config, data) => {
      formDesign.component = config.component;
      formDesign.uuid = config.uuid;
      formDesign.items = config.items;
      formDesign.options = config.options;
      formDesign.options.key = "root";
      formDesign.options.defaultValue = {};
      traverse([formDesign], formData, data);
      formRef.value && formRef.value.clearValidate();
    };
    const submit = () => {
      formRef.value.validate((valid, error) => {
        if (valid) {
          emit2("submit", toRaw(formData.root));
        } else {
          emitter.emit("validateError", Object.keys(error)[0]);
        }
      });
    };
    const reset = () => {
      formRef.value.resetFields();
    };
    provide("emitter", emitter);
    return {
      formRef,
      formDesign,
      formData,
      init,
      submit,
      reset
    };
  }
};
const _hoisted_1$m = { class: "btn-submit" };
const _hoisted_2$j = /* @__PURE__ */ createTextVNode("\u63D0\u4EA4");
const _hoisted_3$g = /* @__PURE__ */ createTextVNode("\u91CD\u7F6E");
function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_form_render_item = __unplugin_components_0$3;
  const _component_el_button = ElButton;
  const _component_el_form = ElForm;
  return openBlock(), createBlock(_component_el_form, {
    class: "form-render",
    ref: "formRef",
    "label-width": $setup.formDesign.options.labelWidth,
    "label-position": $setup.formDesign.options.labelPosition,
    "hide-required-asterisk": $setup.formDesign.options.hideRequiredAsterisk,
    "status-icon": $setup.formDesign.options.statusIcon,
    inline: $setup.formDesign.options.inline,
    size: $setup.formDesign.options.size,
    model: $setup.formData
  }, {
    default: withCtx(() => [
      createVNode(_component_form_render_item, {
        class: "root",
        modelValue: $setup.formData.root,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.formData.root = $event),
        component: $setup.formDesign.component,
        items: $setup.formDesign.items,
        options: $setup.formDesign.options,
        path: "root"
      }, null, 8, ["modelValue", "component", "items", "options"]),
      createElementVNode("div", _hoisted_1$m, [
        createVNode(_component_el_button, {
          type: "primary",
          onClick: $setup.submit
        }, {
          default: withCtx(() => [
            _hoisted_2$j
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_el_button, {
          type: "default",
          onClick: $setup.reset
        }, {
          default: withCtx(() => [
            _hoisted_3$g
          ]),
          _: 1
        }, 8, ["onClick"])
      ])
    ]),
    _: 1
  }, 8, ["label-width", "label-position", "hide-required-asterisk", "status-icon", "inline", "size", "model"]);
}
var FormRender = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$1m]]);
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": FormRender
});
var codemirror$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var userAgent2 = navigator.userAgent;
    var platform = navigator.platform;
    var gecko = /gecko\/\d/i.test(userAgent2);
    var ie_upto10 = /MSIE \d/.test(userAgent2);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent2);
    var edge = /Edge\/(\d+)/.exec(userAgent2);
    var ie = ie_upto10 || ie_11up || edge;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent2);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent2);
    var chrome = !edge && /Chrome\//.test(userAgent2);
    var presto = /Opera\//.test(userAgent2);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent2);
    var phantom = /PhantomJS/.test(userAgent2);
    var ios = safari && (/Mobile\/\w+/.test(userAgent2) || navigator.maxTouchPoints > 2);
    var android = /Android/.test(userAgent2);
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent2);
    var mac = ios || /Mac/.test(platform);
    var chromeOS = /\bCrOS\b/.test(userAgent2);
    var windows = /win/i.test(platform);
    var presto_version = presto && userAgent2.match(/Version\/(\d*\.\d*)/);
    if (presto_version) {
      presto_version = Number(presto_version[1]);
    }
    if (presto_version && presto_version >= 15) {
      presto = false;
      webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie && ie_version >= 9;
    function classTest(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
      var current = node.className;
      var match = classTest(cls).exec(current);
      if (match) {
        var after = current.slice(match.index + match[0].length);
        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
      }
    };
    function removeChildren(e) {
      for (var count = e.childNodes.length; count > 0; --count) {
        e.removeChild(e.firstChild);
      }
      return e;
    }
    function removeChildrenAndAdd(parent, e) {
      return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) {
        e.className = className;
      }
      if (style) {
        e.style.cssText = style;
      }
      if (typeof content == "string") {
        e.appendChild(document.createTextNode(content));
      } else if (content) {
        for (var i2 = 0; i2 < content.length; ++i2) {
          e.appendChild(content[i2]);
        }
      }
      return e;
    }
    function eltP(tag, content, className, style) {
      var e = elt(tag, content, className, style);
      e.setAttribute("role", "presentation");
      return e;
    }
    var range3;
    if (document.createRange) {
      range3 = function(node, start2, end2, endNode) {
        var r = document.createRange();
        r.setEnd(endNode || node, end2);
        r.setStart(node, start2);
        return r;
      };
    } else {
      range3 = function(node, start2, end2) {
        var r = document.body.createTextRange();
        try {
          r.moveToElementText(node.parentNode);
        } catch (e) {
          return r;
        }
        r.collapse(true);
        r.moveEnd("character", end2);
        r.moveStart("character", start2);
        return r;
      };
    }
    function contains2(parent, child) {
      if (child.nodeType == 3) {
        child = child.parentNode;
      }
      if (parent.contains) {
        return parent.contains(child);
      }
      do {
        if (child.nodeType == 11) {
          child = child.host;
        }
        if (child == parent) {
          return true;
        }
      } while (child = child.parentNode);
    }
    function activeElt() {
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch (e) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }
    function addClass2(node, cls) {
      var current = node.className;
      if (!classTest(cls).test(current)) {
        node.className += (current ? " " : "") + cls;
      }
    }
    function joinClasses(a2, b2) {
      var as = a2.split(" ");
      for (var i2 = 0; i2 < as.length; i2++) {
        if (as[i2] && !classTest(as[i2]).test(b2)) {
          b2 += " " + as[i2];
        }
      }
      return b2;
    }
    var selectInput = function(node) {
      node.select();
    };
    if (ios) {
      selectInput = function(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie) {
      selectInput = function(node) {
        try {
          node.select();
        } catch (_e) {
        }
      };
    }
    function bind(f2) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        return f2.apply(null, args);
      };
    }
    function copyObj(obj, target, overwrite) {
      if (!target) {
        target = {};
      }
      for (var prop2 in obj) {
        if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
          target[prop2] = obj[prop2];
        }
      }
      return target;
    }
    function countColumn(string3, end2, tabSize, startIndex, startValue) {
      if (end2 == null) {
        end2 = string3.search(/[^\s\u00a0]/);
        if (end2 == -1) {
          end2 = string3.length;
        }
      }
      for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
        var nextTab = string3.indexOf("	", i2);
        if (nextTab < 0 || nextTab >= end2) {
          return n + (end2 - i2);
        }
        n += nextTab - i2;
        n += tabSize - n % tabSize;
        i2 = nextTab + 1;
      }
    }
    var Delayed = function() {
      this.id = null;
      this.f = null;
      this.time = 0;
      this.handler = bind(this.onTimeout, this);
    };
    Delayed.prototype.onTimeout = function(self2) {
      self2.id = 0;
      if (self2.time <= +new Date()) {
        self2.f();
      } else {
        setTimeout(self2.handler, self2.time - +new Date());
      }
    };
    Delayed.prototype.set = function(ms, f2) {
      this.f = f2;
      var time = +new Date() + ms;
      if (!this.id || time < this.time) {
        clearTimeout(this.id);
        this.id = setTimeout(this.handler, ms);
        this.time = time;
      }
    };
    function indexOf(array4, elt2) {
      for (var i2 = 0; i2 < array4.length; ++i2) {
        if (array4[i2] == elt2) {
          return i2;
        }
      }
      return -1;
    }
    var scrollerGap = 50;
    var Pass = { toString: function() {
      return "CodeMirror.Pass";
    } };
    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
    function findColumn(string3, goal, tabSize) {
      for (var pos = 0, col = 0; ; ) {
        var nextTab = string3.indexOf("	", pos);
        if (nextTab == -1) {
          nextTab = string3.length;
        }
        var skipped = nextTab - pos;
        if (nextTab == string3.length || col + skipped >= goal) {
          return pos + Math.min(skipped, goal - col);
        }
        col += nextTab - pos;
        col += tabSize - col % tabSize;
        pos = nextTab + 1;
        if (col >= goal) {
          return pos;
        }
      }
    }
    var spaceStrs = [""];
    function spaceStr(n) {
      while (spaceStrs.length <= n) {
        spaceStrs.push(lst(spaceStrs) + " ");
      }
      return spaceStrs[n];
    }
    function lst(arr) {
      return arr[arr.length - 1];
    }
    function map(array4, f2) {
      var out = [];
      for (var i2 = 0; i2 < array4.length; i2++) {
        out[i2] = f2(array4[i2], i2);
      }
      return out;
    }
    function insertSorted(array4, value, score) {
      var pos = 0, priority = score(value);
      while (pos < array4.length && score(array4[pos]) <= priority) {
        pos++;
      }
      array4.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base2, props2) {
      var inst;
      if (Object.create) {
        inst = Object.create(base2);
      } else {
        nothing.prototype = base2;
        inst = new nothing();
      }
      if (props2) {
        copyObj(props2, inst);
      }
      return inst;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function isWordChar(ch, helper) {
      if (!helper) {
        return isWordCharBasic(ch);
      }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
        return true;
      }
      return helper.test(ch);
    }
    function isEmpty2(obj) {
      for (var n in obj) {
        if (obj.hasOwnProperty(n) && obj[n]) {
          return false;
        }
      }
      return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
      return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function skipExtendingChars(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
        pos += dir;
      }
      return pos;
    }
    function findFirst(pred, from, to) {
      var dir = from > to ? -1 : 1;
      for (; ; ) {
        if (from == to) {
          return from;
        }
        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid == from) {
          return pred(mid) ? from : to;
        }
        if (pred(mid)) {
          to = mid;
        } else {
          from = mid + dir;
        }
      }
    }
    function iterateBidiSections(order2, from, to, f2) {
      if (!order2) {
        return f2(from, to, "ltr", 0);
      }
      var found = false;
      for (var i2 = 0; i2 < order2.length; ++i2) {
        var part = order2[i2];
        if (part.from < to && part.to > from || from == to && part.to == from) {
          f2(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
          found = true;
        }
      }
      if (!found) {
        f2(from, to, "ltr");
      }
    }
    var bidiOther = null;
    function getBidiPartAt(order2, ch, sticky) {
      var found;
      bidiOther = null;
      for (var i2 = 0; i2 < order2.length; ++i2) {
        var cur = order2[i2];
        if (cur.from < ch && cur.to > ch) {
          return i2;
        }
        if (cur.to == ch) {
          if (cur.from != cur.to && sticky == "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
        if (cur.from == ch) {
          if (cur.from != cur.to && sticky != "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
      }
      return found != null ? found : bidiOther;
    }
    var bidiOrdering = function() {
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code) {
        if (code <= 247) {
          return lowTypes.charAt(code);
        } else if (1424 <= code && code <= 1524) {
          return "R";
        } else if (1536 <= code && code <= 1785) {
          return arabicTypes.charAt(code - 1536);
        } else if (1774 <= code && code <= 2220) {
          return "r";
        } else if (8192 <= code && code <= 8203) {
          return "w";
        } else if (code == 8204) {
          return "b";
        } else {
          return "L";
        }
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from;
        this.to = to;
      }
      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";
        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
          return false;
        }
        var len = str.length, types2 = [];
        for (var i2 = 0; i2 < len; ++i2) {
          types2.push(charType(str.charCodeAt(i2)));
        }
        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
          var type4 = types2[i$12];
          if (type4 == "m") {
            types2[i$12] = prev;
          } else {
            prev = type4;
          }
        }
        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
          var type$12 = types2[i$22];
          if (type$12 == "1" && cur == "r") {
            types2[i$22] = "n";
          } else if (isStrong.test(type$12)) {
            cur = type$12;
            if (type$12 == "r") {
              types2[i$22] = "R";
            }
          }
        }
        for (var i$3 = 1, prev$1 = types2[0]; i$3 < len - 1; ++i$3) {
          var type$2 = types2[i$3];
          if (type$2 == "+" && prev$1 == "1" && types2[i$3 + 1] == "1") {
            types2[i$3] = "1";
          } else if (type$2 == "," && prev$1 == types2[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
            types2[i$3] = prev$1;
          }
          prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len; ++i$4) {
          var type$3 = types2[i$4];
          if (type$3 == ",") {
            types2[i$4] = "N";
          } else if (type$3 == "%") {
            var end2 = void 0;
            for (end2 = i$4 + 1; end2 < len && types2[end2] == "%"; ++end2) {
            }
            var replace = i$4 && types2[i$4 - 1] == "!" || end2 < len && types2[end2] == "1" ? "1" : "N";
            for (var j = i$4; j < end2; ++j) {
              types2[j] = replace;
            }
            i$4 = end2 - 1;
          }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
          var type$4 = types2[i$5];
          if (cur$1 == "L" && type$4 == "1") {
            types2[i$5] = "L";
          } else if (isStrong.test(type$4)) {
            cur$1 = type$4;
          }
        }
        for (var i$6 = 0; i$6 < len; ++i$6) {
          if (isNeutral.test(types2[i$6])) {
            var end$1 = void 0;
            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types2[end$1]); ++end$1) {
            }
            var before = (i$6 ? types2[i$6 - 1] : outerType) == "L";
            var after = (end$1 < len ? types2[end$1] : outerType) == "L";
            var replace$1 = before == after ? before ? "L" : "R" : outerType;
            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
              types2[j$1] = replace$1;
            }
            i$6 = end$1 - 1;
          }
        }
        var order2 = [], m2;
        for (var i$7 = 0; i$7 < len; ) {
          if (countsAsLeft.test(types2[i$7])) {
            var start2 = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types2[i$7]); ++i$7) {
            }
            order2.push(new BidiSpan(0, start2, i$7));
          } else {
            var pos = i$7, at = order2.length, isRTL = direction == "rtl" ? 1 : 0;
            for (++i$7; i$7 < len && types2[i$7] != "L"; ++i$7) {
            }
            for (var j$2 = pos; j$2 < i$7; ) {
              if (countsAsNum.test(types2[j$2])) {
                if (pos < j$2) {
                  order2.splice(at, 0, new BidiSpan(1, pos, j$2));
                  at += isRTL;
                }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types2[j$2]); ++j$2) {
                }
                order2.splice(at, 0, new BidiSpan(2, nstart, j$2));
                at += isRTL;
                pos = j$2;
              } else {
                ++j$2;
              }
            }
            if (pos < i$7) {
              order2.splice(at, 0, new BidiSpan(1, pos, i$7));
            }
          }
        }
        if (direction == "ltr") {
          if (order2[0].level == 1 && (m2 = str.match(/^\s+/))) {
            order2[0].from = m2[0].length;
            order2.unshift(new BidiSpan(0, 0, m2[0].length));
          }
          if (lst(order2).level == 1 && (m2 = str.match(/\s+$/))) {
            lst(order2).to -= m2[0].length;
            order2.push(new BidiSpan(0, len - m2[0].length, len));
          }
        }
        return direction == "rtl" ? order2.reverse() : order2;
      };
    }();
    function getOrder(line, direction) {
      var order2 = line.order;
      if (order2 == null) {
        order2 = line.order = bidiOrdering(line.text, direction);
      }
      return order2;
    }
    var noHandlers = [];
    var on2 = function(emitter, type4, f2) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type4, f2, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type4, f2);
      } else {
        var map2 = emitter._handlers || (emitter._handlers = {});
        map2[type4] = (map2[type4] || noHandlers).concat(f2);
      }
    };
    function getHandlers(emitter, type4) {
      return emitter._handlers && emitter._handlers[type4] || noHandlers;
    }
    function off2(emitter, type4, f2) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type4, f2, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type4, f2);
      } else {
        var map2 = emitter._handlers, arr = map2 && map2[type4];
        if (arr) {
          var index2 = indexOf(arr, f2);
          if (index2 > -1) {
            map2[type4] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
          }
        }
      }
    }
    function signal(emitter, type4) {
      var handlers = getHandlers(emitter, type4);
      if (!handlers.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i2 = 0; i2 < handlers.length; ++i2) {
        handlers[i2].apply(null, args);
      }
    }
    function signalDOMEvent(cm, e, override) {
      if (typeof e == "string") {
        e = { type: e, preventDefault: function() {
          this.defaultPrevented = true;
        } };
      }
      signal(cm, override || e.type, cm, e);
      return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) {
        return;
      }
      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i2 = 0; i2 < arr.length; ++i2) {
        if (indexOf(set, arr[i2]) == -1) {
          set.push(arr[i2]);
        }
      }
    }
    function hasHandler(emitter, type4) {
      return getHandlers(emitter, type4).length > 0;
    }
    function eventMixin(ctor) {
      ctor.prototype.on = function(type4, f2) {
        on2(this, type4, f2);
      };
      ctor.prototype.off = function(type4, f2) {
        off2(this, type4, f2);
      };
    }
    function e_preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function e_stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    function e_defaultPrevented(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop(e) {
      e_preventDefault(e);
      e_stopPropagation(e);
    }
    function e_target(e) {
      return e.target || e.srcElement;
    }
    function e_button(e) {
      var b2 = e.which;
      if (b2 == null) {
        if (e.button & 1) {
          b2 = 1;
        } else if (e.button & 2) {
          b2 = 3;
        } else if (e.button & 4) {
          b2 = 2;
        }
      }
      if (mac && e.ctrlKey && b2 == 1) {
        b2 = 3;
      }
      return b2;
    }
    var dragAndDrop = function() {
      if (ie && ie_version < 9) {
        return false;
      }
      var div = elt("div");
      return "draggable" in div || "dragDrop" in div;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test = elt("span", "\u200B");
        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0) {
          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
      }
      var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) {
        return badBidiRects;
      }
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
      var r0 = range3(txt, 0, 1).getBoundingClientRect();
      var r1 = range3(txt, 1, 2).getBoundingClientRect();
      removeChildren(measure);
      if (!r0 || r0.left == r0.right) {
        return false;
      }
      return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string3) {
      var pos = 0, result = [], l2 = string3.length;
      while (pos <= l2) {
        var nl = string3.indexOf("\n", pos);
        if (nl == -1) {
          nl = string3.length;
        }
        var line = string3.slice(pos, string3.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function(string3) {
      return string3.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function(te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function(te) {
      var range4;
      try {
        range4 = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range4 || range4.parentElement() != te) {
        return false;
      }
      return range4.compareEndPoints("StartToEnd", range4) != 0;
    };
    var hasCopyEvent = function() {
      var e = elt("div");
      if ("oncopy" in e) {
        return true;
      }
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function";
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) {
        return badZoomedRects;
      }
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range3(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes = {}, mimeModes = {};
    function defineMode(name, mode) {
      if (arguments.length > 2) {
        mode.dependencies = Array.prototype.slice.call(arguments, 2);
      }
      modes[name] = mode;
    }
    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") {
          found = { name: found };
        }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml");
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json");
      }
      if (typeof spec == "string") {
        return { name: spec };
      } else {
        return spec || { name: "null" };
      }
    }
    function getMode(options2, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) {
        return getMode(options2, "text/plain");
      }
      var modeObj = mfactory(options2, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop2 in exts) {
          if (!exts.hasOwnProperty(prop2)) {
            continue;
          }
          if (modeObj.hasOwnProperty(prop2)) {
            modeObj["_" + prop2] = modeObj[prop2];
          }
          modeObj[prop2] = exts[prop2];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) {
        modeObj.helperType = spec.helperType;
      }
      if (spec.modeProps) {
        for (var prop$1 in spec.modeProps) {
          modeObj[prop$1] = spec.modeProps[prop$1];
        }
      }
      return modeObj;
    }
    var modeExtensions = {};
    function extendMode(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
      copyObj(properties, exts);
    }
    function copyState(mode, state) {
      if (state === true) {
        return state;
      }
      if (mode.copyState) {
        return mode.copyState(state);
      }
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array) {
          val = val.concat([]);
        }
        nstate[n] = val;
      }
      return nstate;
    }
    function innerMode(mode, state) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state);
        if (!info || info.mode == mode) {
          break;
        }
        state = info.state;
        mode = info.mode;
      }
      return info || { mode, state };
    }
    function startState(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    }
    var StringStream = function(string3, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string3;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };
    StringStream.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    StringStream.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    StringStream.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    StringStream.prototype.next = function() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    };
    StringStream.prototype.eat = function(match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") {
        ok = ch == match;
      } else {
        ok = ch && (match.test ? match.test(ch) : match(ch));
      }
      if (ok) {
        ++this.pos;
        return ch;
      }
    };
    StringStream.prototype.eatWhile = function(match) {
      var start2 = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start2;
    };
    StringStream.prototype.eatSpace = function() {
      var start2 = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this.pos;
      }
      return this.pos > start2;
    };
    StringStream.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    StringStream.prototype.skipTo = function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    };
    StringStream.prototype.backUp = function(n) {
      this.pos -= n;
    };
    StringStream.prototype.column = function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.indentation = function() {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.match = function(pattern4, consume, caseInsensitive) {
      if (typeof pattern4 == "string") {
        var cased = function(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern4.length);
        if (cased(substr) == cased(pattern4)) {
          if (consume !== false) {
            this.pos += pattern4.length;
          }
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern4);
        if (match && match.index > 0) {
          return null;
        }
        if (match && consume !== false) {
          this.pos += match[0].length;
        }
        return match;
      }
    };
    StringStream.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    StringStream.prototype.hideFirstChars = function(n, inner) {
      this.lineStart += n;
      try {
        return inner();
      } finally {
        this.lineStart -= n;
      }
    };
    StringStream.prototype.lookAhead = function(n) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n);
    };
    StringStream.prototype.baseToken = function() {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos);
    };
    function getLine(doc, n) {
      n -= doc.first;
      if (n < 0 || n >= doc.size) {
        throw new Error("There is no line " + (n + doc.first) + " in the document.");
      }
      var chunk = doc;
      while (!chunk.lines) {
        for (var i2 = 0; ; ++i2) {
          var child = chunk.children[i2], sz = child.chunkSize();
          if (n < sz) {
            chunk = child;
            break;
          }
          n -= sz;
        }
      }
      return chunk.lines[n];
    }
    function getBetween(doc, start2, end2) {
      var out = [], n = start2.line;
      doc.iter(start2.line, end2.line + 1, function(line) {
        var text = line.text;
        if (n == end2.line) {
          text = text.slice(0, end2.ch);
        }
        if (n == start2.line) {
          text = text.slice(start2.ch);
        }
        out.push(text);
        ++n;
      });
      return out;
    }
    function getLines(doc, from, to) {
      var out = [];
      doc.iter(from, to, function(line) {
        out.push(line.text);
      });
      return out;
    }
    function updateLineHeight(line, height2) {
      var diff = height2 - line.height;
      if (diff) {
        for (var n = line; n; n = n.parent) {
          n.height += diff;
        }
      }
    }
    function lineNo(line) {
      if (line.parent == null) {
        return null;
      }
      var cur = line.parent, no = indexOf(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i2 = 0; ; ++i2) {
          if (chunk.children[i2] == cur) {
            break;
          }
          no += chunk.children[i2].chunkSize();
        }
      }
      return no + cur.first;
    }
    function lineAtHeight(chunk, h2) {
      var n = chunk.first;
      outer:
        do {
          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
            var child = chunk.children[i$12], ch = child.height;
            if (h2 < ch) {
              chunk = child;
              continue outer;
            }
            h2 -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
      var i2 = 0;
      for (; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2], lh = line.height;
        if (h2 < lh) {
          break;
        }
        h2 -= lh;
      }
      return n + i2;
    }
    function isLine(doc, l2) {
      return l2 >= doc.first && l2 < doc.first + doc.size;
    }
    function lineNumberFor(options2, i2) {
      return String(options2.lineNumberFormatter(i2 + options2.firstLineNumber));
    }
    function Pos(line, ch, sticky) {
      if (sticky === void 0)
        sticky = null;
      if (!(this instanceof Pos)) {
        return new Pos(line, ch, sticky);
      }
      this.line = line;
      this.ch = ch;
      this.sticky = sticky;
    }
    function cmp(a2, b2) {
      return a2.line - b2.line || a2.ch - b2.ch;
    }
    function equalCursorPos(a2, b2) {
      return a2.sticky == b2.sticky && cmp(a2, b2) == 0;
    }
    function copyPos(x2) {
      return Pos(x2.line, x2.ch);
    }
    function maxPos(a2, b2) {
      return cmp(a2, b2) < 0 ? b2 : a2;
    }
    function minPos(a2, b2) {
      return cmp(a2, b2) < 0 ? a2 : b2;
    }
    function clipLine(doc, n) {
      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
      if (pos.line < doc.first) {
        return Pos(doc.first, 0);
      }
      var last = doc.first + doc.size - 1;
      if (pos.line > last) {
        return Pos(last, getLine(doc, last).text.length);
      }
      return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) {
        return Pos(pos.line, linelen);
      } else if (ch < 0) {
        return Pos(pos.line, 0);
      } else {
        return pos;
      }
    }
    function clipPosArray(doc, array4) {
      var out = [];
      for (var i2 = 0; i2 < array4.length; i2++) {
        out[i2] = clipPos(doc, array4[i2]);
      }
      return out;
    }
    var SavedContext = function(state, lookAhead) {
      this.state = state;
      this.lookAhead = lookAhead;
    };
    var Context = function(doc, state, line, lookAhead) {
      this.state = state;
      this.doc = doc;
      this.line = line;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Context.prototype.lookAhead = function(n) {
      var line = this.doc.getLine(this.line + n);
      if (line != null && n > this.maxLookAhead) {
        this.maxLookAhead = n;
      }
      return line;
    };
    Context.prototype.baseToken = function(n) {
      if (!this.baseTokens) {
        return null;
      }
      while (this.baseTokens[this.baseTokenPos] <= n) {
        this.baseTokenPos += 2;
      }
      var type4 = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: type4 && type4.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - n
      };
    };
    Context.prototype.nextLine = function() {
      this.line++;
      if (this.maxLookAhead > 0) {
        this.maxLookAhead--;
      }
    };
    Context.fromSaved = function(doc, saved, line) {
      if (saved instanceof SavedContext) {
        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
      } else {
        return new Context(doc, copyState(doc.mode, saved), line);
      }
    };
    Context.prototype.save = function(copy2) {
      var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
    };
    function highlightLine(cm, line, context, forceToEnd) {
      var st = [cm.state.modeGen], lineClasses = {};
      runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {
        return st.push(end2, style);
      }, lineClasses, forceToEnd);
      var state = context.state;
      var loop = function(o3) {
        context.baseTokens = st;
        var overlay = cm.state.overlays[o3], i2 = 1, at = 0;
        context.state = true;
        runMode(cm, line.text, overlay.mode, context, function(end2, style) {
          var start2 = i2;
          while (at < end2) {
            var i_end = st[i2];
            if (i_end > end2) {
              st.splice(i2, 1, end2, st[i2 + 1], i_end);
            }
            i2 += 2;
            at = Math.min(end2, i_end);
          }
          if (!style) {
            return;
          }
          if (overlay.opaque) {
            st.splice(start2, i2 - start2, end2, "overlay " + style);
            i2 = start2 + 2;
          } else {
            for (; start2 < i2; start2 += 2) {
              var cur = st[start2 + 1];
              st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
            }
          }
        }, lineClasses);
        context.state = state;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };
      for (var o2 = 0; o2 < cm.state.overlays.length; ++o2)
        loop(o2);
      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
    }
    function getLineStyles(cm, line, updateFrontier) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var context = getContextBefore(cm, lineNo(line));
        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
        var result = highlightLine(cm, line, context);
        if (resetState) {
          context.state = resetState;
        }
        line.stateAfter = context.save(!resetState);
        line.styles = result.styles;
        if (result.classes) {
          line.styleClasses = result.classes;
        } else if (line.styleClasses) {
          line.styleClasses = null;
        }
        if (updateFrontier === cm.doc.highlightFrontier) {
          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
      }
      return line.styles;
    }
    function getContextBefore(cm, n, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) {
        return new Context(doc, true, n);
      }
      var start2 = findStartLine(cm, n, precise);
      var saved = start2 > doc.first && getLine(doc, start2 - 1).stateAfter;
      var context = saved ? Context.fromSaved(doc, saved, start2) : new Context(doc, startState(doc.mode), start2);
      doc.iter(start2, n, function(line) {
        processLine(cm, line.text, context);
        var pos = context.line;
        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) {
        doc.modeFrontier = context.line;
      }
      return context;
    }
    function processLine(cm, text, context, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream(text, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text == "") {
        callBlankLine(mode, context.state);
      }
      while (!stream.eol()) {
        readToken(mode, stream, context.state);
        stream.start = stream.pos;
      }
    }
    function callBlankLine(mode, state) {
      if (mode.blankLine) {
        return mode.blankLine(state);
      }
      if (!mode.innerMode) {
        return;
      }
      var inner = innerMode(mode, state);
      if (inner.mode.blankLine) {
        return inner.mode.blankLine(inner.state);
      }
    }
    function readToken(mode, stream, state, inner) {
      for (var i2 = 0; i2 < 10; i2++) {
        if (inner) {
          inner[0] = innerMode(mode, state).mode;
        }
        var style = mode.token(stream, state);
        if (stream.pos > stream.start) {
          return style;
        }
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    var Token = function(stream, type4, state) {
      this.start = stream.start;
      this.end = stream.pos;
      this.string = stream.current();
      this.type = type4 || null;
      this.state = state;
    };
    function takeToken(cm, pos, precise, asArray) {
      var doc = cm.doc, mode = doc.mode, style;
      pos = clipPos(doc, pos);
      var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
      if (asArray) {
        tokens = [];
      }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style = readToken(mode, stream, context.state);
        if (asArray) {
          tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
        }
      }
      return asArray ? tokens : new Token(stream, style, context.state);
    }
    function extractLineClasses(type4, output) {
      if (type4) {
        for (; ; ) {
          var lineClass = type4.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) {
            break;
          }
          type4 = type4.slice(0, lineClass.index) + type4.slice(lineClass.index + lineClass[0].length);
          var prop2 = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop2] == null) {
            output[prop2] = lineClass[2];
          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
            output[prop2] += " " + lineClass[2];
          }
        }
      }
      return type4;
    }
    function runMode(cm, text, mode, context, f2, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) {
        flattenSpans = cm.options.flattenSpans;
      }
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text, cm.options.tabSize, context), style;
      var inner = cm.options.addModeClass && [null];
      if (text == "") {
        extractLineClasses(callBlankLine(mode, context.state), lineClasses);
      }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) {
            processLine(cm, text, context, stream.pos);
          }
          stream.pos = text.length;
          style = null;
        } else {
          style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) {
            style = "m-" + (style ? mName + " " + style : mName);
          }
        }
        if (!flattenSpans || curStyle != style) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5e3);
            f2(curStart, curStyle);
          }
          curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        var pos = Math.min(stream.pos, curStart + 5e3);
        f2(pos, curStyle);
        curStart = pos;
      }
    }
    function findStartLine(cm, n, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
      for (var search = n; search > lim; --search) {
        if (search <= doc.first) {
          return doc.first;
        }
        var line = getLine(doc, search - 1), after = line.stateAfter;
        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
          return search;
        }
        var indented = countColumn(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function retreatFrontier(doc, n) {
      doc.modeFrontier = Math.min(doc.modeFrontier, n);
      if (doc.highlightFrontier < n - 10) {
        return;
      }
      var start2 = doc.first;
      for (var line = n - 1; line > start2; line--) {
        var saved = getLine(doc, line).stateAfter;
        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
          start2 = line + 1;
          break;
        }
      }
      doc.highlightFrontier = Math.min(doc.highlightFrontier, start2);
    }
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
      sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
      sawCollapsedSpans = true;
    }
    function MarkedSpan(marker, from, to) {
      this.marker = marker;
      this.from = from;
      this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
      if (spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if (span.marker == marker) {
            return span;
          }
        }
      }
    }
    function removeMarkedSpan(spans, span) {
      var r;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2] != span) {
          (r || (r = [])).push(spans[i2]);
        }
      }
      return r;
    }
    function addMarkedSpan(line, span, op) {
      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
      if (inThisOp && inThisOp.has(line.markedSpans)) {
        line.markedSpans.push(span);
      } else {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        if (inThisOp) {
          inThisOp.add(line.markedSpans);
        }
      }
      span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
          }
        }
      }
      return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
          }
        }
      }
      return nw;
    }
    function stretchSpansOverChange(doc, change) {
      if (change.full) {
        return null;
      }
      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) {
        return null;
      }
      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);
      var sameLine = change.text.length == 1, offset2 = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        for (var i2 = 0; i2 < first.length; ++i2) {
          var span = first[i2];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) {
              span.to = startCh;
            } else if (sameLine) {
              span.to = found.to == null ? null : found.to + offset2;
            }
          }
        }
      }
      if (last) {
        for (var i$12 = 0; i$12 < last.length; ++i$12) {
          var span$1 = last[i$12];
          if (span$1.to != null) {
            span$1.to += offset2;
          }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset2;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          } else {
            span$1.from += offset2;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        }
      }
      if (first) {
        first = clearEmptySpans(first);
      }
      if (last && last != first) {
        last = clearEmptySpans(last);
      }
      var newMarkers = [first];
      if (!sameLine) {
        var gap = change.text.length - 2, gapMarkers;
        if (gap > 0 && first) {
          for (var i$22 = 0; i$22 < first.length; ++i$22) {
            if (first[i$22].to == null) {
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
            }
          }
        }
        for (var i$3 = 0; i$3 < gap; ++i$3) {
          newMarkers.push(gapMarkers);
        }
        newMarkers.push(last);
      }
      return newMarkers;
    }
    function clearEmptySpans(spans) {
      for (var i2 = 0; i2 < spans.length; ++i2) {
        var span = spans[i2];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
          spans.splice(i2--, 1);
        }
      }
      if (!spans.length) {
        return null;
      }
      return spans;
    }
    function removeReadOnlyRanges(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function(line) {
        if (line.markedSpans) {
          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
            var mark = line.markedSpans[i3].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
              (markers || (markers = [])).push(mark);
            }
          }
        }
      });
      if (!markers) {
        return null;
      }
      var parts = [{ from, to }];
      for (var i2 = 0; i2 < markers.length; ++i2) {
        var mk = markers[i2], m2 = mk.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p2 = parts[j];
          if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
            continue;
          }
          var newParts = [j, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
            newParts.push({ from: p2.from, to: m2.from });
          }
          if (dto > 0 || !mk.inclusiveRight && !dto) {
            newParts.push({ from: m2.to, to: p2.to });
          }
          parts.splice.apply(parts, newParts);
          j += newParts.length - 3;
        }
      }
      return parts;
    }
    function detachMarkedSpans(line) {
      var spans = line.markedSpans;
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.detachLine(line);
      }
      line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.attachLine(line);
      }
      line.markedSpans = spans;
    }
    function extraLeft(marker) {
      return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
      return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a2, b2) {
      var lenDiff = a2.lines.length - b2.lines.length;
      if (lenDiff != 0) {
        return lenDiff;
      }
      var aPos = a2.find(), bPos = b2.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a2) - extraLeft(b2);
      if (fromCmp) {
        return -fromCmp;
      }
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a2) - extraRight(b2);
      if (toCmp) {
        return toCmp;
      }
      return b2.id - a2.id;
    }
    function collapsedSpanAtSide(line, start2) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function collapsedSpanAtStart(line) {
      return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
      return collapsedSpanAtSide(line, false);
    }
    function collapsedSpanAround(line, ch) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
      var line = getLine(doc, lineNo2);
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          var found = sp.marker.find(0);
          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
            continue;
          }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
            return true;
          }
        }
      }
    }
    function visualLine(line) {
      var merged;
      while (merged = collapsedSpanAtStart(line)) {
        line = merged.find(-1, true).line;
      }
      return line;
    }
    function visualLineEnd(line) {
      var merged;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return line;
    }
    function visualLineContinued(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
        (lines || (lines = [])).push(line);
      }
      return lines;
    }
    function visualLineNo(doc, lineN) {
      var line = getLine(doc, lineN), vis = visualLine(line);
      if (line == vis) {
        return lineN;
      }
      return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
      if (lineN > doc.lastLine()) {
        return lineN;
      }
      var line = getLine(doc, lineN), merged;
      if (!lineIsHidden(doc, line)) {
        return lineN;
      }
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          if (sp.from == null) {
            return true;
          }
          if (sp.marker.widgetNode) {
            continue;
          }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      }
    }
    function lineIsHiddenInner(doc, line, span) {
      if (span.to == null) {
        var end2 = span.marker.find(1, true);
        return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line.text.length) {
        return true;
      }
      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
        sp = line.markedSpans[i2];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);
      var h2 = 0, chunk = lineObj.parent;
      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2];
        if (line == lineObj) {
          break;
        } else {
          h2 += line.height;
        }
      }
      for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
        for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {
          var cur = p2.children[i$12];
          if (cur == chunk) {
            break;
          } else {
            h2 += cur.height;
          }
        }
      }
      return h2;
    }
    function lineLength(line) {
      if (line.height == 0) {
        return 0;
      }
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found$1 = merged.find(0, true);
        len -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len += cur.text.length - found$1.to.ch;
      }
      return len;
    }
    function findMaxLine(cm) {
      var d2 = cm.display, doc = cm.doc;
      d2.maxLine = getLine(doc, doc.first);
      d2.maxLineLength = lineLength(d2.maxLine);
      d2.maxLineChanged = true;
      doc.iter(function(line) {
        var len = lineLength(line);
        if (len > d2.maxLineLength) {
          d2.maxLineLength = len;
          d2.maxLine = line;
        }
      });
    }
    var Line = function(text, markedSpans, estimateHeight2) {
      this.text = text;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight2 ? estimateHeight2(this) : 1;
    };
    Line.prototype.lineNo = function() {
      return lineNo(this);
    };
    eventMixin(Line);
    function updateLine(line, text, markedSpans, estimateHeight2) {
      line.text = text;
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
      if (line.order != null) {
        line.order = null;
      }
      detachMarkedSpans(line);
      attachMarkedSpans(line, markedSpans);
      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    }
    function cleanUpLine(line) {
      line.parent = null;
      detachMarkedSpans(line);
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options2) {
      if (!style || /^\s*$/.test(style)) {
        return null;
      }
      var cache = options2.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {
        pre: eltP("pre", [content], "CodeMirror-line"),
        content,
        col: 0,
        pos: 0,
        cm,
        trailingSpace: false,
        splitSpaces: cm.getOption("lineWrapping")
      };
      lineView.measure = {};
      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order2 = void 0;
        builder.pos = 0;
        builder.addToken = buildToken;
        if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction))) {
          builder.addToken = buildTokenBadBidi(builder.addToken, order2);
        }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass) {
            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
          }
          if (line.styleClasses.textClass) {
            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
          }
        }
        if (builder.map.length == 0) {
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
        }
        if (i2 == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }
      if (webkit) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
          builder.content.className = "cm-tab-wrap-hack";
        }
      }
      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className) {
        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
      }
      return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
      var token = elt("span", "\u2022", "cm-invalidchar");
      token.title = "\\u" + ch.charCodeAt(0).toString(16);
      token.setAttribute("aria-label", token.title);
      return token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, css2, attributes) {
      if (!text) {
        return;
      }
      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text)) {
        builder.col += text.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text.length, content);
        if (ie && ie_version < 9) {
          mustWrap = true;
        }
        builder.pos += text.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m2 = special.exec(text);
          var skipped = m2 ? m2.index - pos : text.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie && ie_version < 9) {
              content.appendChild(elt("span", [txt]));
            } else {
              content.appendChild(txt);
            }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m2) {
            break;
          }
          pos += skipped + 1;
          var txt$1 = void 0;
          if (m2[0] == "	") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "	");
            builder.col += tabWidth;
          } else if (m2[0] == "\r" || m2[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m2[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
            txt$1.setAttribute("cm-text", m2[0]);
            if (ie && ie_version < 9) {
              content.appendChild(elt("span", [txt$1]));
            } else {
              content.appendChild(txt$1);
            }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
      if (style || startStyle || endStyle || mustWrap || css2 || attributes) {
        var fullStyle = style || "";
        if (startStyle) {
          fullStyle += startStyle;
        }
        if (endStyle) {
          fullStyle += endStyle;
        }
        var token = elt("span", [content], fullStyle, css2);
        if (attributes) {
          for (var attr in attributes) {
            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
              token.setAttribute(attr, attributes[attr]);
            }
          }
        }
        return builder.content.appendChild(token);
      }
      builder.content.appendChild(content);
    }
    function splitSpaces(text, trailingBefore) {
      if (text.length > 1 && !/  /.test(text)) {
        return text;
      }
      var spaceBefore = trailingBefore, result = "";
      for (var i2 = 0; i2 < text.length; i2++) {
        var ch = text.charAt(i2);
        if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
          ch = "\xA0";
        }
        result += ch;
        spaceBefore = ch == " ";
      }
      return result;
    }
    function buildTokenBadBidi(inner, order2) {
      return function(builder, text, style, startStyle, endStyle, css2, attributes) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start2 = builder.pos, end2 = start2 + text.length;
        for (; ; ) {
          var part = void 0;
          for (var i2 = 0; i2 < order2.length; i2++) {
            part = order2[i2];
            if (part.to > start2 && part.from <= start2) {
              break;
            }
          }
          if (part.to >= end2) {
            return inner(builder, text, style, startStyle, endStyle, css2, attributes);
          }
          inner(builder, text.slice(0, part.to - start2), style, startStyle, null, css2, attributes);
          startStyle = null;
          text = text.slice(part.to - start2);
          start2 = part.to;
        }
      };
    }
    function buildCollapsedSpan(builder, size2, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size2, widget);
      }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget) {
          widget = builder.content.appendChild(document.createElement("span"));
        }
        widget.setAttribute("cm-marker", marker.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size2;
      builder.trailingSpace = false;
    }
    function insertLineContent(line, builder, styles) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
          builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
        }
        return;
      }
      var len = allText.length, pos = 0, i2 = 1, text = "", style, css2;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
      for (; ; ) {
        if (nextChange == pos) {
          spanStyle = spanEndStyle = spanStartStyle = css2 = "";
          attributes = null;
          collapsed = null;
          nextChange = Infinity;
          var foundBookmarks = [], endStyles = void 0;
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m2 = sp.marker;
            if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
              foundBookmarks.push(m2);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m2.className) {
                spanStyle += " " + m2.className;
              }
              if (m2.css) {
                css2 = (css2 ? css2 + ";" : "") + m2.css;
              }
              if (m2.startStyle && sp.from == pos) {
                spanStartStyle += " " + m2.startStyle;
              }
              if (m2.endStyle && sp.to == nextChange) {
                (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
              }
              if (m2.title) {
                (attributes || (attributes = {})).title = m2.title;
              }
              if (m2.attributes) {
                for (var attr in m2.attributes) {
                  (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                }
              }
              if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                collapsed = sp;
              }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) {
            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
              if (endStyles[j$1 + 1] == nextChange) {
                spanEndStyle += " " + endStyles[j$1];
              }
            }
          }
          if (!collapsed || collapsed.from == pos) {
            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
            }
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) {
              return;
            }
            if (collapsed.to == pos) {
              collapsed = false;
            }
          }
        }
        if (pos >= len) {
          break;
        }
        var upto = Math.min(len, nextChange);
        while (true) {
          if (text) {
            var end2 = pos + text.length;
            if (!collapsed) {
              var tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css2, attributes);
            }
            if (end2 >= upto) {
              text = text.slice(upto - pos);
              pos = upto;
              break;
            }
            pos = end2;
            spanStartStyle = "";
          }
          text = allText.slice(at, at = styles[i2++]);
          style = interpretTokenStyle(styles[i2++], builder.cm.options);
        }
      }
    }
    function LineView(doc, line, lineN) {
      this.line = line;
      this.rest = visualLineContinued(line);
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
      var array4 = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array4.push(view);
      }
      return array4;
    }
    var operationGroup = null;
    function pushOperation(op) {
      if (operationGroup) {
        operationGroup.ops.push(op);
      } else {
        op.ownsGroup = operationGroup = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }
    function fireCallbacksForOps(group) {
      var callbacks = group.delayedCallbacks, i2 = 0;
      do {
        for (; i2 < callbacks.length; i2++) {
          callbacks[i2].call(null);
        }
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers) {
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
          }
        }
      } while (i2 < callbacks.length);
    }
    function finishOperation(op, endCb) {
      var group = op.ownsGroup;
      if (!group) {
        return;
      }
      try {
        fireCallbacksForOps(group);
      } finally {
        operationGroup = null;
        endCb(group);
      }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type4) {
      var arr = getHandlers(emitter, type4);
      if (!arr.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2), list;
      if (operationGroup) {
        list = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list = orphanDelayedCallbacks;
      } else {
        list = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      var loop = function(i3) {
        list.push(function() {
          return arr[i3].apply(null, args);
        });
      };
      for (var i2 = 0; i2 < arr.length; ++i2)
        loop(i2);
    }
    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i2 = 0; i2 < delayed.length; ++i2) {
        delayed[i2]();
      }
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type4 = lineView.changes[j];
        if (type4 == "text") {
          updateLineText(cm, lineView);
        } else if (type4 == "gutter") {
          updateLineGutter(cm, lineView, lineN, dims);
        } else if (type4 == "class") {
          updateLineClasses(cm, lineView);
        } else if (type4 == "widget") {
          updateLineWidgets(cm, lineView, dims);
        }
      }
      lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode) {
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        }
        lineView.node.appendChild(lineView.text);
        if (ie && ie_version < 8) {
          lineView.node.style.zIndex = 2;
        }
      }
      return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) {
        cls += " CodeMirror-linebackground";
      }
      if (lineView.background) {
        if (cls) {
          lineView.background.className = cls;
        } else {
          lineView.background.parentNode.removeChild(lineView.background);
          lineView.background = null;
        }
      } else if (cls) {
        var wrap = ensureLineWrapped(lineView);
        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) {
        lineView.node = built.pre;
      }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }
    function updateLineClasses(cm, lineView) {
      updateLineBackground(cm, lineView);
      if (lineView.line.wrapClass) {
        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
      } else if (lineView.node != lineView.text) {
        lineView.node.className = "";
      }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap = ensureLineWrapped(lineView);
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$1 = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
        gutterWrap.setAttribute("aria-hidden", "true");
        cm.display.input.setUneditable(gutterWrap);
        wrap$1.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass) {
          gutterWrap.className += " " + lineView.line.gutterClass;
        }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
        }
        if (markers) {
          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
            var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
            if (found) {
              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"));
            }
          }
        }
      }
    }
    function updateLineWidgets(cm, lineView, dims) {
      if (lineView.alignable) {
        lineView.alignable = null;
      }
      var isWidget = classTest("CodeMirror-linewidget");
      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
        next = node.nextSibling;
        if (isWidget.test(node.className)) {
          lineView.node.removeChild(node);
        }
      }
      insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) {
        lineView.bgClass = built.bgClass;
      }
      if (built.textClass) {
        lineView.textClass = built.textClass;
      }
      updateLineClasses(cm, lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(cm, lineView, dims);
      return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
        }
      }
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
      if (!line.widgets) {
        return;
      }
      var wrap = ensureLineWrapped(lineView);
      for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
        var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
        if (!widget.handleMouseEvents) {
          node.setAttribute("cm-ignore-events", "true");
        }
        positionLineWidget(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above) {
          wrap.insertBefore(node, lineView.gutter || lineView.text);
        } else {
          wrap.appendChild(node);
        }
        signalLater(widget, "redraw");
      }
    }
    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width2 = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width2 -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width2 + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) {
          node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
    }
    function widgetHeight(widget) {
      if (widget.height != null) {
        return widget.height;
      }
      var cm = widget.doc.cm;
      if (!cm) {
        return 0;
      }
      if (!contains2(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter) {
          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
        }
        if (widget.noHScroll) {
          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
        }
        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
          return true;
        }
      }
    }
    function paddingTop(display) {
      return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
      if (display.cachedPaddingH) {
        return display.cachedPaddingH;
      }
      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
      if (!isNaN(data.left) && !isNaN(data.right)) {
        display.cachedPaddingH = data;
      }
      return data;
    }
    function scrollGap(cm) {
      return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i2 = 0; i2 < rects.length - 1; i2++) {
            var cur = rects[i2], next = rects[i2 + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2) {
              heights.push((cur.bottom + next.top) / 2 - rect.top);
            }
          }
        }
        heights.push(rect.bottom - rect.top);
      }
    }
    function mapFromLineView(lineView, line, lineN) {
      if (lineView.line == line) {
        return { map: lineView.measure.map, cache: lineView.measure.cache };
      }
      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
        if (lineView.rest[i2] == line) {
          return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
        }
      }
      for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
        if (lineNo(lineView.rest[i$12]) > lineN) {
          return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
        }
      }
    }
    function updateExternalMeasurement(cm, line) {
      line = visualLine(line);
      var lineN = lineNo(line);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view;
    }
    function measureChar(cm, line, ch, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
        return cm.display.view[findViewIndex(cm, lineN)];
      }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
        return ext;
      }
    }
    function prepareMeasureForLine(cm, line) {
      var lineN = lineNo(line);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges(cm, view, lineN, getDimensions(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view) {
        view = updateExternalMeasurement(cm, line);
      }
      var info = mapFromLineView(view, line, lineN);
      return {
        line,
        view,
        rect: null,
        map: info.map,
        cache: info.cache,
        before: info.before,
        hasHeights: false
      };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) {
        ch = -1;
      }
      var key2 = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key2)) {
        found = prepared.cache[key2];
      } else {
        if (!prepared.rect) {
          prepared.rect = prepared.view.text.getBoundingClientRect();
        }
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch, bias);
        if (!found.bogus) {
          prepared.cache[key2] = found;
        }
      }
      return {
        left: found.left,
        right: found.right,
        top: varHeight ? found.rtop : found.top,
        bottom: varHeight ? found.rbottom : found.bottom
      };
    }
    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
    function nodeAndOffsetInLineMap(map2, ch, bias) {
      var node, start2, end2, collapse, mStart, mEnd;
      for (var i2 = 0; i2 < map2.length; i2 += 3) {
        mStart = map2[i2];
        mEnd = map2[i2 + 1];
        if (ch < mStart) {
          start2 = 0;
          end2 = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start2 = ch - mStart;
          end2 = start2 + 1;
        } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
          end2 = mEnd - mStart;
          start2 = end2 - 1;
          if (ch >= mEnd) {
            collapse = "right";
          }
        }
        if (start2 != null) {
          node = map2[i2 + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
            collapse = bias;
          }
          if (bias == "left" && start2 == 0) {
            while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
              node = map2[(i2 -= 3) + 2];
              collapse = "left";
            }
          }
          if (bias == "right" && start2 == mEnd - mStart) {
            while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
              node = map2[(i2 += 3) + 2];
              collapse = "right";
            }
          }
          break;
        }
      }
      return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
    }
    function getUsefulRect(rects, bias) {
      var rect = nullRect;
      if (bias == "left") {
        for (var i2 = 0; i2 < rects.length; i2++) {
          if ((rect = rects[i2]).left != rect.right) {
            break;
          }
        }
      } else {
        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
          if ((rect = rects[i$12]).left != rect.right) {
            break;
          }
        }
      }
      return rect;
    }
    function measureCharInner(cm, prepared, ch, bias) {
      var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
      var node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;
      var rect;
      if (node.nodeType == 3) {
        for (var i$12 = 0; i$12 < 4; i$12++) {
          while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {
            --start2;
          }
          while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {
            ++end2;
          }
          if (ie && ie_version < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart) {
            rect = node.parentNode.getBoundingClientRect();
          } else {
            rect = getUsefulRect(range3(node, start2, end2).getClientRects(), bias);
          }
          if (rect.left || rect.right || start2 == 0) {
            break;
          }
          end2 = start2;
          start2 = start2 - 1;
          collapse = "right";
        }
        if (ie && ie_version < 11) {
          rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        }
      } else {
        if (start2 > 0) {
          collapse = bias = "right";
        }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        } else {
          rect = node.getBoundingClientRect();
        }
      }
      if (ie && ie_version < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan) {
          rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
        } else {
          rect = nullRect;
        }
      }
      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
      var mid = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i2 = 0;
      for (; i2 < heights.length - 1; i2++) {
        if (mid < heights[i2]) {
          break;
        }
      }
      var top2 = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
      var result = {
        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
        top: top2,
        bottom: bot
      };
      if (!rect.left && !rect.right) {
        result.bogus = true;
      }
      if (!cm.options.singleCursorHeightPerLine) {
        result.rtop = rtop;
        result.rbottom = rbot;
      }
      return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
        return rect;
      }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {
        left: rect.left * scaleX,
        right: rect.right * scaleX,
        top: rect.top * scaleY,
        bottom: rect.bottom * scaleY
      };
    }
    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            lineView.measure.caches[i2] = {};
          }
        }
      }
    }
    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        clearLineMeasurementCacheFor(cm.display.view[i2]);
      }
    }
    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) {
        cm.display.maxLineChanged = true;
      }
      cm.display.lineNumChars = null;
    }
    function pageScrollX() {
      if (chrome && android) {
        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
      }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
      if (chrome && android) {
        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
      }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
      var height2 = 0;
      if (lineObj.widgets) {
        for (var i2 = 0; i2 < lineObj.widgets.length; ++i2) {
          if (lineObj.widgets[i2].above) {
            height2 += widgetHeight(lineObj.widgets[i2]);
          }
        }
      }
      return height2;
    }
    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
      if (!includeWidgets) {
        var height2 = widgetTopHeight(lineObj);
        rect.top += height2;
        rect.bottom += height2;
      }
      if (context == "line") {
        return rect;
      }
      if (!context) {
        context = "local";
      }
      var yOff = heightAtLine(lineObj);
      if (context == "local") {
        yOff += paddingTop(cm.display);
      } else {
        yOff -= cm.display.viewOffset;
      }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect.left += xOff;
        rect.right += xOff;
      }
      rect.top += yOff;
      rect.bottom += yOff;
      return rect;
    }
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") {
        return coords;
      }
      var left2 = coords.left, top2 = coords.top;
      if (context == "page") {
        left2 -= pageScrollX();
        top2 -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left2 += localBox.left;
        top2 += localBox.top;
      }
      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return { left: left2 - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) {
        lineObj = getLine(cm.doc, pos.line);
      }
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine(cm.doc, pos.line);
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      function get(ch2, right2) {
        var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right2 ? "right" : "left", varHeight);
        if (right2) {
          m2.left = m2.right;
        } else {
          m2.right = m2.left;
        }
        return intoCoordSystem(cm, lineObj, m2, context);
      }
      var order2 = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
      if (ch >= lineObj.text.length) {
        ch = lineObj.text.length;
        sticky = "before";
      } else if (ch <= 0) {
        ch = 0;
        sticky = "after";
      }
      if (!order2) {
        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
      }
      function getBidi(ch2, partPos2, invert) {
        var part = order2[partPos2], right2 = part.level == 1;
        return get(invert ? ch2 - 1 : ch2, right2 != invert);
      }
      var partPos = getBidiPartAt(order2, ch, sticky);
      var other = bidiOther;
      var val = getBidi(ch, partPos, sticky == "before");
      if (other != null) {
        val.other = getBidi(ch, other, sticky != "before");
      }
      return val;
    }
    function estimateCoords(cm, pos) {
      var left2 = 0;
      pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) {
        left2 = charWidth(cm.display) * pos.ch;
      }
      var lineObj = getLine(cm.doc, pos.line);
      var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
      return { left: left2, right: left2, top: top2, bottom: top2 + lineObj.height };
    }
    function PosWithInfo(line, ch, sticky, outside, xRel) {
      var pos = Pos(line, ch, sticky);
      pos.xRel = xRel;
      if (outside) {
        pos.outside = outside;
      }
      return pos;
    }
    function coordsChar(cm, x2, y) {
      var doc = cm.doc;
      y += cm.display.viewOffset;
      if (y < 0) {
        return PosWithInfo(doc.first, 0, null, -1, -1);
      }
      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
      if (lineN > last) {
        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
      }
      if (x2 < 0) {
        x2 = 0;
      }
      var lineObj = getLine(doc, lineN);
      for (; ; ) {
        var found = coordsCharInner(cm, lineObj, lineN, x2, y);
        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) {
          return found;
        }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) {
          return rangeEnd;
        }
        lineObj = getLine(doc, lineN = rangeEnd.line);
      }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
      y -= widgetTopHeight(lineObj);
      var end2 = lineObj.text.length;
      var begin = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
      }, end2, 0);
      end2 = findFirst(function(ch) {
        return measureCharPrepared(cm, preparedMeasure, ch).top > y;
      }, begin, end2);
      return { begin, end: end2 };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x2, y, left2) {
      return box.bottom <= y ? false : box.top > y ? true : (left2 ? box.left : box.right) > x2;
    }
    function coordsCharInner(cm, lineObj, lineNo2, x2, y) {
      y -= heightAtLine(lineObj);
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
      var widgetHeight2 = widgetTopHeight(lineObj);
      var begin = 0, end2 = lineObj.text.length, ltr = true;
      var order2 = getOrder(lineObj, cm.doc.direction);
      if (order2) {
        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y);
        ltr = part.level != 1;
        begin = ltr ? part.from : part.to - 1;
        end2 = ltr ? part.to : part.from - 1;
      }
      var chAround = null, boxAround = null;
      var ch = findFirst(function(ch2) {
        var box = measureCharPrepared(cm, preparedMeasure, ch2);
        box.top += widgetHeight2;
        box.bottom += widgetHeight2;
        if (!boxIsAfter(box, x2, y, false)) {
          return false;
        }
        if (box.top <= y && box.left <= x2) {
          chAround = ch2;
          boxAround = box;
        }
        return true;
      }, begin, end2);
      var baseX, sticky, outside = false;
      if (boxAround) {
        var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
        ch = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        if (!ltr && (ch == end2 || ch == begin)) {
          ch++;
        }
        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
        var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
      }
      ch = skipExtendingChars(lineObj.text, ch, 1);
      return PosWithInfo(lineNo2, ch, sticky, outside, x2 - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y) {
      var index2 = findFirst(function(i2) {
        var part2 = order2[i2], ltr2 = part2.level != 1;
        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x2, y, true);
      }, 0, order2.length - 1);
      var part = order2[index2];
      if (index2 > 0) {
        var ltr = part.level != 1;
        var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
        if (boxIsAfter(start2, x2, y, true) && start2.top > y) {
          part = order2[index2 - 1];
        }
      }
      return part;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y) {
      var ref2 = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
      var begin = ref2.begin;
      var end2 = ref2.end;
      if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
        end2--;
      }
      var part = null, closestDist = null;
      for (var i2 = 0; i2 < order2.length; i2++) {
        var p2 = order2[i2];
        if (p2.from >= end2 || p2.to <= begin) {
          continue;
        }
        var ltr = p2.level != 1;
        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p2.to) - 1 : Math.max(begin, p2.from)).right;
        var dist = endX < x2 ? x2 - endX + 1e9 : endX - x2;
        if (!part || closestDist > dist) {
          part = p2;
          closestDist = dist;
        }
      }
      if (!part) {
        part = order2[order2.length - 1];
      }
      if (part.from < begin) {
        part = { from: begin, to: part.to, level: part.level };
      }
      if (part.to > end2) {
        part = { from: part.from, to: end2, level: part.level };
      }
      return part;
    }
    var measureText;
    function textHeight(display) {
      if (display.cachedTextHeight != null) {
        return display.cachedTextHeight;
      }
      if (measureText == null) {
        measureText = elt("pre", null, "CodeMirror-line-like");
        for (var i2 = 0; i2 < 49; ++i2) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height2 = measureText.offsetHeight / 50;
      if (height2 > 3) {
        display.cachedTextHeight = height2;
      }
      removeChildren(display.measure);
      return height2 || 1;
    }
    function charWidth(display) {
      if (display.cachedCharWidth != null) {
        return display.cachedCharWidth;
      }
      var anchor = elt("span", "xxxxxxxxxx");
      var pre = elt("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd(display.measure, pre);
      var rect = anchor.getBoundingClientRect(), width2 = (rect.right - rect.left) / 10;
      if (width2 > 2) {
        display.cachedCharWidth = width2;
      }
      return width2 || 10;
    }
    function getDimensions(cm) {
      var d2 = cm.display, left2 = {}, width2 = {};
      var gutterLeft = d2.gutters.clientLeft;
      for (var n = d2.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
        var id2 = cm.display.gutterSpecs[i2].className;
        left2[id2] = n.offsetLeft + n.clientLeft + gutterLeft;
        width2[id2] = n.clientWidth;
      }
      return {
        fixedPos: compensateForHScroll(d2),
        gutterTotalWidth: d2.gutters.offsetWidth,
        gutterLeft: left2,
        gutterWidth: width2,
        wrapperWidth: d2.wrapper.clientWidth
      };
    }
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function(line) {
        if (lineIsHidden(cm.doc, line)) {
          return 0;
        }
        var widgetsHeight = 0;
        if (line.widgets) {
          for (var i2 = 0; i2 < line.widgets.length; i2++) {
            if (line.widgets[i2].height) {
              widgetsHeight += line.widgets[i2].height;
            }
          }
        }
        if (wrapping) {
          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
        } else {
          return widgetsHeight + th;
        }
      };
    }
    function estimateLineHeights(cm) {
      var doc = cm.doc, est = estimateHeight(cm);
      doc.iter(function(line) {
        var estHeight = est(line);
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      });
    }
    function posFromMouse(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
        return null;
      }
      var x2, y, space = display.lineSpace.getBoundingClientRect();
      try {
        x2 = e.clientX - space.left;
        y = e.clientY - space.top;
      } catch (e$1) {
        return null;
      }
      var coords = coordsChar(cm, x2, y), line;
      if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords;
    }
    function findViewIndex(cm, n) {
      if (n >= cm.display.viewTo) {
        return null;
      }
      n -= cm.display.viewFrom;
      if (n < 0) {
        return null;
      }
      var view = cm.display.view;
      for (var i2 = 0; i2 < view.length; i2++) {
        n -= view[i2].size;
        if (n < 0) {
          return i2;
        }
      }
    }
    function regChange(cm, from, to, lendiff) {
      if (from == null) {
        from = cm.doc.first;
      }
      if (to == null) {
        to = cm.doc.first + cm.doc.size;
      }
      if (!lendiff) {
        lendiff = 0;
      }
      var display = cm.display;
      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
        display.updateLineNumbers = from;
      }
      cm.curOp.viewChanged = true;
      if (from >= display.viewTo) {
        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
          resetView(cm);
        }
      } else if (to <= display.viewFrom) {
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) {
        resetView(cm);
      } else if (from <= display.viewFrom) {
        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to >= display.viewTo) {
        var cut$1 = viewCuttingPoint(cm, from, from, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView(cm);
        }
      } else {
        var cutTop = viewCuttingPoint(cm, from, from, -1);
        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }
      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN) {
          ext.lineN += lendiff;
        } else if (from < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
      }
    }
    function regLineChange(cm, line, type4) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
      if (line < display.viewFrom || line >= display.viewTo) {
        return;
      }
      var lineView = display.view[findViewIndex(cm, line)];
      if (lineView.node == null) {
        return;
      }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf(arr, type4) == -1) {
        arr.push(type4);
      }
    }
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index2 = findViewIndex(cm, oldN), diff, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
        return { index: index2, lineN: newN };
      }
      var n = cm.display.viewFrom;
      for (var i2 = 0; i2 < index2; i2++) {
        n += view[i2].size;
      }
      if (n != oldN) {
        if (dir > 0) {
          if (index2 == view.length - 1) {
            return null;
          }
          diff = n + view[index2].size - oldN;
          index2++;
        } else {
          diff = n - oldN;
        }
        oldN += diff;
        newN += diff;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index2 == (dir < 0 ? 0 : view.length - 1)) {
          return null;
        }
        newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
        index2 += dir;
      }
      return { index: index2, lineN: newN };
    }
    function adjustView(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from) {
          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
        } else if (display.viewFrom < from) {
          display.view = display.view.slice(findViewIndex(cm, from));
        }
        display.viewFrom = from;
        if (display.viewTo < to) {
          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
        } else if (display.viewTo > to) {
          display.view = display.view.slice(0, findViewIndex(cm, to));
        }
      }
      display.viewTo = to;
    }
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
          ++dirty;
        }
      }
      return dirty;
    }
    function updateSelection(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
      if (primary === void 0)
        primary = true;
      var doc = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        if (!primary && i2 == doc.sel.primIndex) {
          continue;
        }
        var range4 = doc.sel.ranges[i2];
        if (range4.from().line >= cm.display.viewTo || range4.to().line < cm.display.viewFrom) {
          continue;
        }
        var collapsed = range4.empty();
        if (collapsed || cm.options.showCursorWhenSelecting) {
          drawSelectionCursor(cm, range4.head, curFragment);
        }
        if (!collapsed) {
          drawSelectionRange(cm, range4, selFragment);
        }
      }
      return result;
    }
    function drawSelectionCursor(cm, head, output) {
      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
      var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
        var charPos = charCoords(cm, head, "div", null, null);
        if (charPos.right - charPos.left > 0) {
          cursor.style.width = charPos.right - charPos.left + "px";
        }
      }
      if (pos.other) {
        var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
      }
    }
    function cmpCoords(a2, b2) {
      return a2.top - b2.top || a2.left - b2.left;
    }
    function drawSelectionRange(cm, range4, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding2 = paddingH(cm.display), leftSide = padding2.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding2.right;
      var docLTR = doc.direction == "ltr";
      function add(left2, top2, width2, bottom2) {
        if (top2 < 0) {
          top2 = 0;
        }
        top2 = Math.round(top2);
        bottom2 = Math.round(bottom2);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left2 + "px;\n                             top: " + top2 + "px; width: " + (width2 == null ? rightSide - left2 : width2) + "px;\n                             height: " + (bottom2 - top2) + "px"));
      }
      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine(doc, line);
        var lineLen = lineObj.text.length;
        var start2, end2;
        function coords(ch, bias) {
          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
        }
        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
          var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch, prop2)[prop2];
        }
        var order2 = getOrder(lineObj, doc.direction);
        iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
          var ltr = dir == "ltr";
          var fromPos = coords(from, ltr ? "left" : "right");
          var toPos = coords(to - 1, ltr ? "right" : "left");
          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
          var first = i2 == 0, last = !order2 || i2 == order2.length - 1;
          if (toPos.top - fromPos.top <= 3) {
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left2 = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right2 = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add(left2, fromPos.top, right2 - left2, fromPos.bottom);
          } else {
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
            }
            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) {
              add(leftSide, fromPos.bottom, null, toPos.top);
            }
            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }
          if (!start2 || cmpCoords(fromPos, start2) < 0) {
            start2 = fromPos;
          }
          if (cmpCoords(toPos, start2) < 0) {
            start2 = toPos;
          }
          if (!end2 || cmpCoords(fromPos, end2) < 0) {
            end2 = fromPos;
          }
          if (cmpCoords(toPos, end2) < 0) {
            end2 = toPos;
          }
        });
        return { start: start2, end: end2 };
      }
      var sFrom = range4.from(), sTo = range4.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top) {
          add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
      }
      output.appendChild(fragment);
    }
    function restartBlink(cm) {
      if (!cm.state.focused) {
        return;
      }
      var display = cm.display;
      clearInterval(display.blinker);
      var on3 = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0) {
        display.blinker = setInterval(function() {
          if (!cm.hasFocus()) {
            onBlur(cm);
          }
          display.cursorDiv.style.visibility = (on3 = !on3) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      } else if (cm.options.cursorBlinkRate < 0) {
        display.cursorDiv.style.visibility = "hidden";
      }
    }
    function ensureFocus(cm) {
      if (!cm.hasFocus()) {
        cm.display.input.focus();
        if (!cm.state.focused) {
          onFocus(cm);
        }
      }
    }
    function delayBlurEvent(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          if (cm.state.focused) {
            onBlur(cm);
          }
        }
      }, 100);
    }
    function onFocus(cm, e) {
      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
        cm.state.delayingBlurEvent = false;
      }
      if (cm.options.readOnly == "nocursor") {
        return;
      }
      if (!cm.state.focused) {
        signal(cm, "focus", cm, e);
        cm.state.focused = true;
        addClass2(cm.display.wrapper, "CodeMirror-focused");
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit) {
            setTimeout(function() {
              return cm.display.input.reset(true);
            }, 20);
          }
        }
        cm.display.input.receivedFocus();
      }
      restartBlink(cm);
    }
    function onBlur(cm, e) {
      if (cm.state.delayingBlurEvent) {
        return;
      }
      if (cm.state.focused) {
        signal(cm, "blur", cm, e);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {
        if (!cm.state.focused) {
          cm.display.shift = false;
        }
      }, 150);
    }
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
      var oldHeight = display.lineDiv.getBoundingClientRect().top;
      var mustScroll = 0;
      for (var i2 = 0; i2 < display.view.length; i2++) {
        var cur = display.view[i2], wrapping = cm.options.lineWrapping;
        var height2 = void 0, width2 = 0;
        if (cur.hidden) {
          continue;
        }
        oldHeight += cur.line.height;
        if (ie && ie_version < 8) {
          var bot = cur.node.offsetTop + cur.node.offsetHeight;
          height2 = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = cur.node.getBoundingClientRect();
          height2 = box.bottom - box.top;
          if (!wrapping && cur.text.firstChild) {
            width2 = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
          }
        }
        var diff = cur.line.height - height2;
        if (diff > 5e-3 || diff < -5e-3) {
          if (oldHeight < viewTop) {
            mustScroll -= diff;
          }
          updateLineHeight(cur.line, height2);
          updateWidgetHeight(cur.line);
          if (cur.rest) {
            for (var j = 0; j < cur.rest.length; j++) {
              updateWidgetHeight(cur.rest[j]);
            }
          }
        }
        if (width2 > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width2 / charWidth(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (Math.abs(mustScroll) > 2) {
        display.scroller.scrollTop += mustScroll;
      }
    }
    function updateWidgetHeight(line) {
      if (line.widgets) {
        for (var i2 = 0; i2 < line.widgets.length; ++i2) {
          var w2 = line.widgets[i2], parent = w2.node.parentNode;
          if (parent) {
            w2.height = parent.offsetHeight;
          }
        }
      }
    }
    function visibleLines(display, doc, viewport2) {
      var top2 = viewport2 && viewport2.top != null ? Math.max(0, viewport2.top) : display.scroller.scrollTop;
      top2 = Math.floor(top2 - paddingTop(display));
      var bottom2 = viewport2 && viewport2.bottom != null ? viewport2.bottom : top2 + display.wrapper.clientHeight;
      var from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);
      if (viewport2 && viewport2.ensure) {
        var ensureFrom = viewport2.ensure.from.line, ensureTo = viewport2.ensure.to.line;
        if (ensureFrom < from) {
          from = ensureFrom;
          to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
          from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
          to = ensureTo;
        }
      }
      return { from, to: Math.max(to, from + 1) };
    }
    function maybeScrollWindow(cm, rect) {
      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
        return;
      }
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect.top + box.top < 0) {
        doScroll = true;
      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
        doScroll = false;
      }
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }
    function scrollPosIntoView(cm, pos, end2, margin) {
      if (margin == null) {
        margin = 0;
      }
      var rect;
      if (!cm.options.lineWrapping && pos == end2) {
        end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      }
      for (var limit2 = 0; limit2 < 5; limit2++) {
        var changed = false;
        var coords = cursorCoords(cm, pos);
        var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
        rect = {
          left: Math.min(coords.left, endCoords.left),
          top: Math.min(coords.top, endCoords.top) - margin,
          right: Math.max(coords.left, endCoords.left),
          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
        };
        var scrollPos = calculateScrollPos(cm, rect);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
            changed = true;
          }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
            changed = true;
          }
        }
        if (!changed) {
          break;
        }
      }
      return rect;
    }
    function scrollIntoView2(cm, rect) {
      var scrollPos = calculateScrollPos(cm, rect);
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
      }
    }
    function calculateScrollPos(cm, rect) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (rect.top < 0) {
        rect.top = 0;
      }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen2 = displayHeight(cm), result = {};
      if (rect.bottom - rect.top > screen2) {
        rect.bottom = rect.top + screen2;
      }
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
      if (rect.top < screentop) {
        result.scrollTop = atTop ? 0 : rect.top;
      } else if (rect.bottom > screentop + screen2) {
        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
        if (newTop != screentop) {
          result.scrollTop = newTop;
        }
      }
      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
      var tooWide = rect.right - rect.left > screenw;
      if (tooWide) {
        rect.right = rect.left + screenw;
      }
      if (rect.left < 10) {
        result.scrollLeft = 0;
      } else if (rect.left < screenleft) {
        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
      } else if (rect.right > screenw + screenleft - 3) {
        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
      }
      return result;
    }
    function addToScrollTop(cm, top2) {
      if (top2 == null) {
        return;
      }
      resolveScrollToPos(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
    }
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
    }
    function scrollToCoords(cm, x2, y) {
      if (x2 != null || y != null) {
        resolveScrollToPos(cm);
      }
      if (x2 != null) {
        cm.curOp.scrollLeft = x2;
      }
      if (y != null) {
        cm.curOp.scrollTop = y;
      }
    }
    function scrollToRange(cm, range4) {
      resolveScrollToPos(cm);
      cm.curOp.scrollToPos = range4;
    }
    function resolveScrollToPos(cm) {
      var range4 = cm.curOp.scrollToPos;
      if (range4) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords(cm, range4.from), to = estimateCoords(cm, range4.to);
        scrollToCoordsRange(cm, from, to, range4.margin);
      }
    }
    function scrollToCoordsRange(cm, from, to, margin) {
      var sPos = calculateScrollPos(cm, {
        left: Math.min(from.left, to.left),
        top: Math.min(from.top, to.top) - margin,
        right: Math.max(from.right, to.right),
        bottom: Math.max(from.bottom, to.bottom) + margin
      });
      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) {
        return;
      }
      if (!gecko) {
        updateDisplaySimple(cm, { top: val });
      }
      setScrollTop(cm, val, true);
      if (gecko) {
        updateDisplaySimple(cm);
      }
      startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
      if (cm.display.scroller.scrollTop == val && !forceScroll) {
        return;
      }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) {
        cm.display.scroller.scrollTop = val;
      }
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
        return;
      }
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) {
        cm.display.scroller.scrollLeft = val;
      }
      cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars(cm) {
      var d2 = cm.display, gutterW = d2.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
      return {
        clientHeight: d2.scroller.clientHeight,
        viewHeight: d2.wrapper.clientHeight,
        scrollWidth: d2.scroller.scrollWidth,
        clientWidth: d2.scroller.clientWidth,
        viewWidth: d2.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap(cm) + d2.barHeight,
        nativeBarWidth: d2.nativeBarWidth,
        gutterWidth: gutterW
      };
    }
    var NativeScrollbars = function(place, scroll, cm) {
      this.cm = cm;
      var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert.tabIndex = horiz.tabIndex = -1;
      place(vert);
      place(horiz);
      on2(vert, "scroll", function() {
        if (vert.clientHeight) {
          scroll(vert.scrollTop, "vertical");
        }
      });
      on2(horiz, "scroll", function() {
        if (horiz.clientWidth) {
          scroll(horiz.scrollLeft, "horizontal");
        }
      });
      this.checkedZeroWidth = false;
      if (ie && ie_version < 8) {
        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
    };
    NativeScrollbars.prototype.update = function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;
      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }
      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }
      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }
      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
    };
    NativeScrollbars.prototype.setScrollLeft = function(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }
    };
    NativeScrollbars.prototype.setScrollTop = function(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }
    };
    NativeScrollbars.prototype.zeroWidthHack = function() {
      var w2 = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w2;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed();
      this.disableVert = new Delayed();
    };
    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type4) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        var box = bar.getBoundingClientRect();
        var elt2 = type4 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt2 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1e3, maybeDisable);
        }
      }
      delay.set(1e3, maybeDisable);
    };
    NativeScrollbars.prototype.clear = function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {
    };
    NullScrollbars.prototype.update = function() {
      return { bottom: 0, right: 0 };
    };
    NullScrollbars.prototype.setScrollLeft = function() {
    };
    NullScrollbars.prototype.setScrollTop = function() {
    };
    NullScrollbars.prototype.clear = function() {
    };
    function updateScrollbars(cm, measure) {
      if (!measure) {
        measure = measureForScrollbars(cm);
      }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner(cm, measure);
      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
          updateHeightsInViewport(cm);
        }
        updateScrollbarsInner(cm, measureForScrollbars(cm));
        startWidth = cm.display.barWidth;
        startHeight = cm.display.barHeight;
      }
    }
    function updateScrollbarsInner(cm, measure) {
      var d2 = cm.display;
      var sizes2 = d2.scrollbars.update(measure);
      d2.sizer.style.paddingRight = (d2.barWidth = sizes2.right) + "px";
      d2.sizer.style.paddingBottom = (d2.barHeight = sizes2.bottom) + "px";
      d2.heightForcer.style.borderBottom = sizes2.bottom + "px solid transparent";
      if (sizes2.right && sizes2.bottom) {
        d2.scrollbarFiller.style.display = "block";
        d2.scrollbarFiller.style.height = sizes2.bottom + "px";
        d2.scrollbarFiller.style.width = sizes2.right + "px";
      } else {
        d2.scrollbarFiller.style.display = "";
      }
      if (sizes2.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d2.gutterFiller.style.display = "block";
        d2.gutterFiller.style.height = sizes2.bottom + "px";
        d2.gutterFiller.style.width = measure.gutterWidth + "px";
      } else {
        d2.gutterFiller.style.display = "";
      }
    }
    var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
    function initScrollbars(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass) {
          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        on2(node, "mousedown", function() {
          if (cm.state.focused) {
            setTimeout(function() {
              return cm.display.input.focus();
            }, 0);
          }
        });
        node.setAttribute("cm-not-content", "true");
      }, function(pos, axis) {
        if (axis == "horizontal") {
          setScrollLeft(cm, pos);
        } else {
          updateScrollTop(cm, pos);
        }
      }, cm);
      if (cm.display.scrollbars.addClass) {
        addClass2(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    var nextOpId = 0;
    function startOperation(cm) {
      cm.curOp = {
        cm,
        viewChanged: false,
        startHeight: cm.doc.height,
        forceUpdate: false,
        updateInput: 0,
        typing: false,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: false,
        updateMaxLine: false,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: false,
        id: ++nextOpId,
        markArrays: null
      };
      pushOperation(cm.curOp);
    }
    function endOperation(cm) {
      var op = cm.curOp;
      if (op) {
        finishOperation(op, function(group) {
          for (var i2 = 0; i2 < group.ops.length; i2++) {
            group.ops[i2].cm.curOp = null;
          }
          endOperations(group);
        });
      }
    }
    function endOperations(group) {
      var ops = group.ops;
      for (var i2 = 0; i2 < ops.length; i2++) {
        endOperation_R1(ops[i2]);
      }
      for (var i$12 = 0; i$12 < ops.length; i$12++) {
        endOperation_W1(ops[i$12]);
      }
      for (var i$22 = 0; i$22 < ops.length; i$22++) {
        endOperation_R2(ops[i$22]);
      }
      for (var i$3 = 0; i$3 < ops.length; i$3++) {
        endOperation_W2(ops[i$3]);
      }
      for (var i$4 = 0; i$4 < ops.length; i$4++) {
        endOperation_finish(ops[i$4]);
      }
    }
    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars(cm);
      if (op.updateMaxLine) {
        findMaxLine(cm);
      }
      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
    }
    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) {
        updateHeightsInViewport(cm);
      }
      op.barMeasure = measureForScrollbars(cm);
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
      }
      if (op.updatedDisplay || op.selectionChanged) {
        op.preparedSelection = display.input.prepareSelection();
      }
    }
    function endOperation_W2(op) {
      var cm = op.cm;
      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft) {
          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        }
        cm.display.maxLineChanged = false;
      }
      var takeFocus = op.focus && op.focus == activeElt();
      if (op.preparedSelection) {
        cm.display.input.showSelection(op.preparedSelection, takeFocus);
      }
      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
        updateScrollbars(cm, op.barMeasure);
      }
      if (op.updatedDisplay) {
        setDocumentHeight(cm, op.barMeasure);
      }
      if (op.selectionChanged) {
        restartBlink(cm);
      }
      if (cm.state.focused && op.updateInput) {
        cm.display.input.reset(op.typing);
      }
      if (takeFocus) {
        ensureFocus(op.cm);
      }
    }
    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;
      if (op.updatedDisplay) {
        postUpdateDisplay(cm, op.update);
      }
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
        display.wheelStartX = display.wheelStartY = null;
      }
      if (op.scrollTop != null) {
        setScrollTop(cm, op.scrollTop, op.forceScroll);
      }
      if (op.scrollLeft != null) {
        setScrollLeft(cm, op.scrollLeft, true, true);
      }
      if (op.scrollToPos) {
        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow(cm, rect);
      }
      var hidden2 = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden2) {
        for (var i2 = 0; i2 < hidden2.length; ++i2) {
          if (!hidden2[i2].lines.length) {
            signal(hidden2[i2], "hide");
          }
        }
      }
      if (unhidden) {
        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
          if (unhidden[i$12].lines.length) {
            signal(unhidden[i$12], "unhide");
          }
        }
      }
      if (display.wrapper.offsetHeight) {
        doc.scrollTop = cm.display.scroller.scrollTop;
      }
      if (op.changeObjs) {
        signal(cm, "changes", cm, op.changeObjs);
      }
      if (op.update) {
        op.update.finish();
      }
    }
    function runInOp(cm, f2) {
      if (cm.curOp) {
        return f2();
      }
      startOperation(cm);
      try {
        return f2();
      } finally {
        endOperation(cm);
      }
    }
    function operation(cm, f2) {
      return function() {
        if (cm.curOp) {
          return f2.apply(cm, arguments);
        }
        startOperation(cm);
        try {
          return f2.apply(cm, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function methodOp(f2) {
      return function() {
        if (this.curOp) {
          return f2.apply(this, arguments);
        }
        startOperation(this);
        try {
          return f2.apply(this, arguments);
        } finally {
          endOperation(this);
        }
      };
    }
    function docMethodOp(f2) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) {
          return f2.apply(this, arguments);
        }
        startOperation(cm);
        try {
          return f2.apply(this, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function startWorker(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo) {
        cm.state.highlight.set(time, bind(highlightWorker, cm));
      }
    }
    function highlightWorker(cm) {
      var doc = cm.doc;
      if (doc.highlightFrontier >= cm.display.viewTo) {
        return;
      }
      var end2 = +new Date() + cm.options.workTime;
      var context = getContextBefore(cm, doc.highlightFrontier);
      var changedLines = [];
      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
        if (context.line >= cm.display.viewFrom) {
          var oldStyles = line.styles;
          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
          var highlighted = highlightLine(cm, line, context, true);
          if (resetState) {
            context.state = resetState;
          }
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) {
            line.styleClasses = newCls;
          } else if (oldCls) {
            line.styleClasses = null;
          }
          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
            ischange = oldStyles[i2] != line.styles[i2];
          }
          if (ischange) {
            changedLines.push(context.line);
          }
          line.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line.text.length <= cm.options.maxHighlightLength) {
            processLine(cm, line.text, context);
          }
          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date() > end2) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
      doc.highlightFrontier = context.line;
      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
      if (changedLines.length) {
        runInOp(cm, function() {
          for (var i2 = 0; i2 < changedLines.length; i2++) {
            regLineChange(cm, changedLines[i2], "text");
          }
        });
      }
    }
    var DisplayUpdate = function(cm, viewport2, force) {
      var display = cm.display;
      this.viewport = viewport2;
      this.visible = visibleLines(display, cm.doc, viewport2);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth(cm);
      this.force = force;
      this.dims = getDimensions(cm);
      this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type4) {
      if (hasHandler(emitter, type4)) {
        this.events.push(arguments);
      }
    };
    DisplayUpdate.prototype.finish = function() {
      for (var i2 = 0; i2 < this.events.length; i2++) {
        signal.apply(null, this.events[i2]);
      }
    };
    function maybeClipScrollbars(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }
    function selectionSnapshot(cm) {
      if (cm.hasFocus()) {
        return null;
      }
      var active = activeElt();
      if (!active || !contains2(cm.display.lineDiv, active)) {
        return null;
      }
      var result = { activeElt: active };
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
          result.anchorNode = sel.anchorNode;
          result.anchorOffset = sel.anchorOffset;
          result.focusNode = sel.focusNode;
          result.focusOffset = sel.focusOffset;
        }
      }
      return result;
    }
    function restoreSelection(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
        return;
      }
      snapshot.activeElt.focus();
      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range4 = document.createRange();
        range4.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range4.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range4);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }
    function updateDisplayIfNeeded(cm, update) {
      var display = cm.display, doc = cm.doc;
      if (update.editorIsHidden) {
        resetView(cm);
        return false;
      }
      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
        return false;
      }
      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update.dims = getDimensions(cm);
      }
      var end2 = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) {
        from = Math.max(doc.first, display.viewFrom);
      }
      if (display.viewTo > to && display.viewTo - to < 20) {
        to = Math.min(end2, display.viewTo);
      }
      if (sawCollapsedSpans) {
        from = visualLineNo(cm.doc, from);
        to = visualLineEndNo(cm.doc, to);
      }
      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
      adjustView(cm, from, to);
      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
      cm.display.mover.style.top = display.viewOffset + "px";
      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
        return false;
      }
      var selSnapshot = selectionSnapshot(cm);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "none";
      }
      patchDisplay(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "";
      }
      display.renderedView = display.view;
      restoreSelection(selSnapshot);
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;
      if (different) {
        display.lastWrapHeight = update.wrapperHeight;
        display.lastWrapWidth = update.wrapperWidth;
        startWorker(cm, 400);
      }
      display.updateLineNumbers = null;
      return true;
    }
    function postUpdateDisplay(cm, update) {
      var viewport2 = update.viewport;
      for (var first = true; ; first = false) {
        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
          if (viewport2 && viewport2.top != null) {
            viewport2 = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport2.top) };
          }
          update.visible = visibleLines(cm.display, cm.doc, viewport2);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
            break;
          }
        } else if (first) {
          update.visible = visibleLines(cm.display, cm.doc, viewport2);
        }
        if (!updateDisplayIfNeeded(cm, update)) {
          break;
        }
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.force = false;
      }
      update.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom;
        cm.display.reportedViewTo = cm.display.viewTo;
      }
    }
    function updateDisplaySimple(cm, viewport2) {
      var update = new DisplayUpdate(cm, viewport2);
      if (updateDisplayIfNeeded(cm, update)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.finish();
      }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;
      function rm(node2) {
        var next = node2.nextSibling;
        if (webkit && mac && cm.display.currentWheelTarget == node2) {
          node2.style.display = "none";
        } else {
          node2.parentNode.removeChild(node2);
        }
        return next;
      }
      var view = display.view, lineN = display.viewFrom;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (lineView.hidden)
          ;
        else if (!lineView.node || lineView.node.parentNode != container) {
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else {
          while (cur != lineView.node) {
            cur = rm(cur);
          }
          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf(lineView.changes, "gutter") > -1) {
              updateNumber = false;
            }
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) {
        cur = rm(cur);
      }
    }
    function updateGutterSpace(display) {
      var width2 = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width2 + "px";
      signalLater(display, "gutterChanged", display);
    }
    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
        return;
      }
      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left2 = comp + "px";
      for (var i2 = 0; i2 < view.length; i2++) {
        if (!view[i2].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i2].gutter) {
              view[i2].gutter.style.left = left2;
            }
            if (view[i2].gutterBackground) {
              view[i2].gutterBackground.style.left = left2;
            }
          }
          var align = view[i2].alignable;
          if (align) {
            for (var j = 0; j < align.length; j++) {
              align[j].style.left = left2;
            }
          }
        }
      }
      if (cm.options.fixedGutter) {
        display.gutters.style.left = comp + gutterW + "px";
      }
    }
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) {
        return false;
      }
      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test.firstChild.offsetWidth, padding2 = test.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding2) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding2;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm.display);
        return true;
      }
      return false;
    }
    function getGutters(gutters, lineNumbers) {
      var result = [], sawLineNumbers = false;
      for (var i2 = 0; i2 < gutters.length; i2++) {
        var name = gutters[i2], style = null;
        if (typeof name != "string") {
          style = name.style;
          name = name.className;
        }
        if (name == "CodeMirror-linenumbers") {
          if (!lineNumbers) {
            continue;
          } else {
            sawLineNumbers = true;
          }
        }
        result.push({ className: name, style });
      }
      if (lineNumbers && !sawLineNumbers) {
        result.push({ className: "CodeMirror-linenumbers", style: null });
      }
      return result;
    }
    function renderGutters(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren(gutters);
      display.lineGutter = null;
      for (var i2 = 0; i2 < specs.length; ++i2) {
        var ref2 = specs[i2];
        var className = ref2.className;
        var style = ref2.style;
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
        if (style) {
          gElt.style.cssText = style;
        }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace(display);
    }
    function updateGutters(cm) {
      renderGutters(cm.display);
      regChange(cm);
      alignHorizontally(cm);
    }
    function Display(place, doc, input, options2) {
      var d2 = this;
      this.input = input;
      d2.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      d2.scrollbarFiller.setAttribute("cm-not-content", "true");
      d2.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      d2.gutterFiller.setAttribute("cm-not-content", "true");
      d2.lineDiv = eltP("div", null, "CodeMirror-code");
      d2.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d2.cursorDiv = elt("div", null, "CodeMirror-cursors");
      d2.measure = elt("div", null, "CodeMirror-measure");
      d2.lineMeasure = elt("div", null, "CodeMirror-measure");
      d2.lineSpace = eltP("div", [d2.measure, d2.lineMeasure, d2.selectionDiv, d2.cursorDiv, d2.lineDiv], null, "position: relative; outline: none");
      var lines = eltP("div", [d2.lineSpace], "CodeMirror-lines");
      d2.mover = elt("div", [lines], null, "position: relative");
      d2.sizer = elt("div", [d2.mover], "CodeMirror-sizer");
      d2.sizerWidth = null;
      d2.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
      d2.gutters = elt("div", null, "CodeMirror-gutters");
      d2.lineGutter = null;
      d2.scroller = elt("div", [d2.sizer, d2.heightForcer, d2.gutters], "CodeMirror-scroll");
      d2.scroller.setAttribute("tabIndex", "-1");
      d2.wrapper = elt("div", [d2.scrollbarFiller, d2.gutterFiller, d2.scroller], "CodeMirror");
      d2.wrapper.setAttribute("translate", "no");
      if (ie && ie_version < 8) {
        d2.gutters.style.zIndex = -1;
        d2.scroller.style.paddingRight = 0;
      }
      if (!webkit && !(gecko && mobile)) {
        d2.scroller.draggable = true;
      }
      if (place) {
        if (place.appendChild) {
          place.appendChild(d2.wrapper);
        } else {
          place(d2.wrapper);
        }
      }
      d2.viewFrom = d2.viewTo = doc.first;
      d2.reportedViewFrom = d2.reportedViewTo = doc.first;
      d2.view = [];
      d2.renderedView = null;
      d2.externalMeasured = null;
      d2.viewOffset = 0;
      d2.lastWrapHeight = d2.lastWrapWidth = 0;
      d2.updateLineNumbers = null;
      d2.nativeBarWidth = d2.barHeight = d2.barWidth = 0;
      d2.scrollbarsClipped = false;
      d2.lineNumWidth = d2.lineNumInnerWidth = d2.lineNumChars = null;
      d2.alignWidgets = false;
      d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
      d2.maxLine = null;
      d2.maxLineLength = 0;
      d2.maxLineChanged = false;
      d2.wheelDX = d2.wheelDY = d2.wheelStartX = d2.wheelStartY = null;
      d2.shift = false;
      d2.selForContextMenu = null;
      d2.activeTouch = null;
      d2.gutterSpecs = getGutters(options2.gutters, options2.lineNumbers);
      renderGutters(d2);
      input.init(d2);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie) {
      wheelPixelsPerUnit = -0.53;
    } else if (gecko) {
      wheelPixelsPerUnit = 15;
    } else if (chrome) {
      wheelPixelsPerUnit = -0.7;
    } else if (safari) {
      wheelPixelsPerUnit = -1 / 3;
    }
    function wheelEventDelta(e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
        dx = e.detail;
      }
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
        dy = e.detail;
      } else if (dy == null) {
        dy = e.wheelDelta;
      }
      return { x: dx, y: dy };
    }
    function wheelEventPixels(e) {
      var delta = wheelEventDelta(e);
      delta.x *= wheelPixelsPerUnit;
      delta.y *= wheelPixelsPerUnit;
      return delta;
    }
    function onScrollWheel(cm, e) {
      var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
      var pixelsPerUnit = wheelPixelsPerUnit;
      if (e.deltaMode === 0) {
        dx = e.deltaX;
        dy = e.deltaY;
        pixelsPerUnit = 1;
      }
      var display = cm.display, scroll = display.scroller;
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) {
        return;
      }
      if (dy && mac && webkit) {
        outer:
          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i2 = 0; i2 < view.length; i2++) {
              if (view[i2].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
      }
      if (dx && !gecko && !presto && pixelsPerUnit != null) {
        if (dy && canScrollY) {
          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
        }
        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
        if (!dy || dy && canScrollY) {
          e_preventDefault(e);
        }
        display.wheelStartX = null;
        return;
      }
      if (dy && pixelsPerUnit != null) {
        var pixels = dy * pixelsPerUnit;
        var top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
        if (pixels < 0) {
          top2 = Math.max(0, top2 + pixels - 50);
        } else {
          bot = Math.min(cm.doc.height, bot + pixels + 50);
        }
        updateDisplaySimple(cm, { top: top2, bottom: bot });
      }
      if (wheelSamples < 20 && e.deltaMode !== 0) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft;
          display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx;
          display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) {
              return;
            }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) {
              return;
            }
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx;
          display.wheelDY += dy;
        }
      }
    }
    var Selection = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };
    Selection.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    Selection.prototype.equals = function(other) {
      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var here = this.ranges[i2], there = other.ranges[i2];
        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
          return false;
        }
      }
      return true;
    };
    Selection.prototype.deepCopy = function() {
      var out = [];
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
      }
      return new Selection(out, this.primIndex);
    };
    Selection.prototype.somethingSelected = function() {
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        if (!this.ranges[i2].empty()) {
          return true;
        }
      }
      return false;
    };
    Selection.prototype.contains = function(pos, end2) {
      if (!end2) {
        end2 = pos;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var range4 = this.ranges[i2];
        if (cmp(end2, range4.from()) >= 0 && cmp(pos, range4.to()) <= 0) {
          return i2;
        }
      }
      return -1;
    };
    var Range = function(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    Range.prototype.from = function() {
      return minPos(this.anchor, this.head);
    };
    Range.prototype.to = function() {
      return maxPos(this.anchor, this.head);
    };
    Range.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function(a2, b2) {
        return cmp(a2.from(), b2.from());
      });
      primIndex = indexOf(ranges, prim);
      for (var i2 = 1; i2 < ranges.length; i2++) {
        var cur = ranges[i2], prev = ranges[i2 - 1];
        var diff = cmp(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i2 <= primIndex) {
            --primIndex;
          }
          ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
      return new Selection([new Range(anchor, head || anchor)], 0);
    }
    function changeEnd(change) {
      if (!change.text) {
        return change.to;
      }
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) {
        return pos;
      }
      if (cmp(pos, change.to) <= 0) {
        return changeEnd(change);
      }
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) {
        ch += changeEnd(change).ch - change.to.ch;
      }
      return Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
      var out = [];
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        var range4 = doc.sel.ranges[i2];
        out.push(new Range(adjustForChange(range4.anchor, change), adjustForChange(range4.head, change)));
      }
      return normalizeSelection(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
      if (pos.line == old.line) {
        return Pos(nw.line, pos.ch - old.ch + nw.ch);
      } else {
        return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
    }
    function computeReplacedSel(doc, changes, hint) {
      var out = [];
      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
      for (var i2 = 0; i2 < changes.length; i2++) {
        var change = changes[i2];
        var from = offsetPos(change.from, oldPrev, newPrev);
        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint == "around") {
          var range4 = doc.sel.ranges[i2], inv = cmp(range4.head, range4.anchor) < 0;
          out[i2] = new Range(inv ? to : from, inv ? from : to);
        } else {
          out[i2] = new Range(from, from);
        }
      }
      return new Selection(out, doc.sel.primIndex);
    }
    function loadMode(cm) {
      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }
    function resetModeState(cm) {
      cm.doc.iter(function(line) {
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) {
        regChange(cm);
      }
    }
    function isWholeLineUpdate(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight2) {
      function spansFor(n) {
        return markedSpans ? markedSpans[n] : null;
      }
      function update(line, text2, spans) {
        updateLine(line, text2, spans, estimateHeight2);
        signalLater(line, "change", line, change);
      }
      function linesFor(start2, end2) {
        var result = [];
        for (var i2 = start2; i2 < end2; ++i2) {
          result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
        }
        return result;
      }
      var from = change.from, to = change.to, text = change.text;
      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
      var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
      if (change.full) {
        doc.insert(0, linesFor(0, text.length));
        doc.remove(text.length, doc.size - text.length);
      } else if (isWholeLineUpdate(doc, change)) {
        var added = linesFor(0, text.length - 1);
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) {
          doc.remove(from.line, nlines);
        }
        if (added.length) {
          doc.insert(from.line, added);
        }
      } else if (firstLine == lastLine) {
        if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text.length - 1);
          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          doc.insert(from.line + 1, added$1);
        }
      } else if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        var added$2 = linesFor(1, text.length - 1);
        if (nlines > 1) {
          doc.remove(from.line + 1, nlines - 1);
        }
        doc.insert(from.line + 1, added$2);
      }
      signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f2, sharedHistOnly) {
      function propagate(doc2, skip, sharedHist) {
        if (doc2.linked) {
          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
            var rel = doc2.linked[i2];
            if (rel.doc == skip) {
              continue;
            }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) {
              continue;
            }
            f2(rel.doc, shared);
            propagate(rel.doc, doc2, shared);
          }
        }
      }
      propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
      if (doc.cm) {
        throw new Error("This document is already in use.");
      }
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      setDirectionClass(cm);
      cm.options.direction = doc.direction;
      if (!cm.options.lineWrapping) {
        findMaxLine(cm);
      }
      cm.options.mode = doc.modeOption;
      regChange(cm);
    }
    function setDirectionClass(cm) {
      (cm.doc.direction == "rtl" ? addClass2 : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged(cm) {
      runInOp(cm, function() {
        setDirectionClass(cm);
        regChange(cm);
      });
    }
    function History(prev) {
      this.done = [];
      this.undone = [];
      this.undoDepth = prev ? prev.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange(doc, change) {
      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc, function(doc2) {
        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
      }, true);
      return histChange;
    }
    function clearSelectionEvents(array4) {
      while (array4.length) {
        var last = lst(array4);
        if (last.ranges) {
          array4.pop();
        } else {
          break;
        }
      }
    }
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done);
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done);
      }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date(), cur;
      var last;
      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          last.to = changeEnd(change);
        } else {
          cur.changes.push(historyChangeFromChange(doc, change));
        }
      } else {
        var before = lst(hist.done);
        if (!before || !before.ranges) {
          pushSelectionToHistory(doc.sel, hist.done);
        }
        cur = {
          changes: [historyChangeFromChange(doc, change)],
          generation: hist.generation
        };
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) {
            hist.done.shift();
          }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;
      if (!last) {
        signal(doc, "historyAdded");
      }
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options2) {
      var hist = doc.history, origin = options2 && options2.origin;
      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
        hist.done[hist.done.length - 1] = sel;
      } else {
        pushSelectionToHistory(sel, hist.done);
      }
      hist.lastSelTime = +new Date();
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options2 && options2.clearRedo !== false) {
        clearSelectionEvents(hist.undone);
      }
    }
    function pushSelectionToHistory(sel, dest) {
      var top2 = lst(dest);
      if (!(top2 && top2.ranges && top2.equals(sel))) {
        dest.push(sel);
      }
    }
    function attachLocalSpans(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
        if (line.markedSpans) {
          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
        }
        ++n;
      });
    }
    function removeClearedSpans(spans) {
      if (!spans) {
        return null;
      }
      var out;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2].marker.explicitlyCleared) {
          if (!out) {
            out = spans.slice(0, i2);
          }
        } else if (out) {
          out.push(spans[i2]);
        }
      }
      return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) {
        return null;
      }
      var nw = [];
      for (var i2 = 0; i2 < change.text.length; ++i2) {
        nw.push(removeClearedSpans(found[i2]));
      }
      return nw;
    }
    function mergeOldSpans(doc, change) {
      var old = getOldSpans(doc, change);
      var stretched = stretchSpansOverChange(doc, change);
      if (!old) {
        return stretched;
      }
      if (!stretched) {
        return old;
      }
      for (var i2 = 0; i2 < old.length; ++i2) {
        var oldCur = old[i2], stretchCur = stretched[i2];
        if (oldCur && stretchCur) {
          spans:
            for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
        } else if (stretchCur) {
          old[i2] = stretchCur;
        }
      }
      return old;
    }
    function copyHistoryArray(events2, newGroup, instantiateSel) {
      var copy2 = [];
      for (var i2 = 0; i2 < events2.length; ++i2) {
        var event = events2[i2];
        if (event.ranges) {
          copy2.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
          continue;
        }
        var changes = event.changes, newChanges = [];
        copy2.push({ changes: newChanges });
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m2 = void 0;
          newChanges.push({ from: change.from, to: change.to, text: change.text });
          if (newGroup) {
            for (var prop2 in change) {
              if (m2 = prop2.match(/^spans_(\d+)$/)) {
                if (indexOf(newGroup, Number(m2[1])) > -1) {
                  lst(newChanges)[prop2] = change[prop2];
                  delete change[prop2];
                }
              }
            }
          }
        }
      }
      return copy2;
    }
    function extendRange(range4, head, other, extend2) {
      if (extend2) {
        var anchor = range4.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != cmp(other, anchor) < 0) {
            anchor = head;
            head = other;
          } else if (posBefore != cmp(head, other) < 0) {
            head = other;
          }
        }
        return new Range(anchor, head);
      } else {
        return new Range(other || head, head);
      }
    }
    function extendSelection(doc, head, other, options2, extend2) {
      if (extend2 == null) {
        extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      }
      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend2)], 0), options2);
    }
    function extendSelections(doc, heads, options2) {
      var out = [];
      var extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend2);
      }
      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
      setSelection(doc, newSel, options2);
    }
    function replaceOneSelection(doc, i2, range4, options2) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i2] = range4;
      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options2);
    }
    function setSimpleSelection(doc, anchor, head, options2) {
      setSelection(doc, simpleSelection(anchor, head), options2);
    }
    function filterSelectionChange(doc, sel, options2) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            this.ranges[i2] = new Range(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
          }
        },
        origin: options2 && options2.origin
      };
      signal(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
      }
      if (obj.ranges != sel.ranges) {
        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
      } else {
        return sel;
      }
    }
    function setSelectionReplaceHistory(doc, sel, options2) {
      var done = doc.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc, sel, options2);
      } else {
        setSelection(doc, sel, options2);
      }
    }
    function setSelection(doc, sel, options2) {
      setSelectionNoUndo(doc, sel, options2);
      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options2);
    }
    function setSelectionNoUndo(doc, sel, options2) {
      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
        sel = filterSelectionChange(doc, sel, options2);
      }
      var bias = options2 && options2.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
      if (!(options2 && options2.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
        ensureCursorVisible(doc.cm);
      }
    }
    function setSelectionInner(doc, sel) {
      if (sel.equals(doc.sel)) {
        return;
      }
      doc.sel = sel;
      if (doc.cm) {
        doc.cm.curOp.updateInput = 1;
        doc.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc.cm);
      }
      signalLater(doc, "cursorActivity", doc);
    }
    function reCheckSelection(doc) {
      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
      var out;
      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
        var range4 = sel.ranges[i2];
        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
        var newAnchor = skipAtomic(doc, range4.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic(doc, range4.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range4.anchor || newHead != range4.head) {
          if (!out) {
            out = sel.ranges.slice(0, i2);
          }
          out[i2] = new Range(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
      var line = getLine(doc, pos.line);
      if (line.markedSpans) {
        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
          var sp = line.markedSpans[i2], m2 = sp.marker;
          var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
          var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal(m2, "beforeCursorEnter");
              if (m2.explicitlyCleared) {
                if (!line.markedSpans) {
                  break;
                } else {
                  --i2;
                  continue;
                }
              }
            }
            if (!m2.atomic) {
              continue;
            }
            if (oldPos) {
              var near = m2.find(dir < 0 ? 1 : -1), diff = void 0;
              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
              }
              if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                return skipAtomicInner(doc, near, pos, dir, mayClear);
              }
            }
            var far = m2.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
              far = movePos(doc, far, dir, far.line == pos.line ? line : null);
            }
            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
          }
        }
      }
      return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
      if (!found) {
        doc.cantEdit = true;
        return Pos(doc.first, 0);
      }
      return found;
    }
    function movePos(doc, pos, dir, line) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc.first) {
          return clipPos(doc, Pos(pos.line - 1));
        } else {
          return null;
        }
      } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
        if (pos.line < doc.first + doc.size - 1) {
          return Pos(pos.line + 1, 0);
        } else {
          return null;
        }
      } else {
        return new Pos(pos.line, pos.ch + dir);
      }
    }
    function selectAll(cm) {
      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() {
          return obj.canceled = true;
        }
      };
      if (update) {
        obj.update = function(from, to, text, origin) {
          if (from) {
            obj.from = clipPos(doc, from);
          }
          if (to) {
            obj.to = clipPos(doc, to);
          }
          if (text) {
            obj.text = text;
          }
          if (origin !== void 0) {
            obj.origin = origin;
          }
        };
      }
      signal(doc, "beforeChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeChange", doc.cm, obj);
      }
      if (obj.canceled) {
        if (doc.cm) {
          doc.cm.curOp.updateInput = 2;
        }
        return null;
      }
      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
    }
    function makeChange(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) {
          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
        }
        if (doc.cm.state.suppressEdits) {
          return;
        }
      }
      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
        change = filterChange(doc, change, true);
        if (!change) {
          return;
        }
      }
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
      if (split) {
        for (var i2 = split.length - 1; i2 >= 0; --i2) {
          makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
        }
      } else {
        makeChangeInner(doc, change);
      }
    }
    function makeChangeInner(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
        return;
      }
      var selAfter = computeSelAfterChange(doc, change);
      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
      var rebased = [];
      linkedDocs(doc, function(doc2, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
          rebaseHist(doc2.history, change);
          rebased.push(doc2.history);
        }
        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
      });
    }
    function makeChangeFromHistory(doc, type4, allowSelectionOnly) {
      var suppress = doc.cm && doc.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) {
        return;
      }
      var hist = doc.history, event, selAfter = doc.sel;
      var source = type4 == "undo" ? hist.done : hist.undone, dest = type4 == "undo" ? hist.undone : hist.done;
      var i2 = 0;
      for (; i2 < source.length; i2++) {
        event = source[i2];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
          break;
        }
      }
      if (i2 == source.length) {
        return;
      }
      hist.lastOrigin = hist.lastSelOrigin = null;
      for (; ; ) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc.sel)) {
            setSelection(doc, event, { clearRedo: false });
            return;
          }
          selAfter = event;
        } else if (suppress) {
          source.push(event);
          return;
        } else {
          break;
        }
      }
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({ changes: antiChanges, generation: hist.generation });
      hist.generation = event.generation || ++hist.maxGeneration;
      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
      var loop = function(i3) {
        var change = event.changes[i3];
        change.origin = type4;
        if (filter && !filterChange(doc, change, false)) {
          source.length = 0;
          return {};
        }
        antiChanges.push(historyChangeFromChange(doc, change));
        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);
        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
        if (!i3 && doc.cm) {
          doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
        }
        var rebased = [];
        linkedDocs(doc, function(doc2, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
            rebaseHist(doc2.history, change);
            rebased.push(doc2.history);
          }
          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
        });
      };
      for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
        var returned = loop(i$12);
        if (returned)
          return returned.v;
      }
    }
    function shiftDoc(doc, distance) {
      if (distance == 0) {
        return;
      }
      doc.first += distance;
      doc.sel = new Selection(map(doc.sel.ranges, function(range4) {
        return new Range(Pos(range4.anchor.line + distance, range4.anchor.ch), Pos(range4.head.line + distance, range4.head.ch));
      }), doc.sel.primIndex);
      if (doc.cm) {
        regChange(doc.cm, doc.first, doc.first - distance, distance);
        for (var d2 = doc.cm.display, l2 = d2.viewFrom; l2 < d2.viewTo; l2++) {
          regLineChange(doc.cm, l2, "gutter");
        }
      }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
      }
      if (change.to.line < doc.first) {
        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc.lastLine()) {
        return;
      }
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc(doc, shift);
        change = {
          from: Pos(doc.first, 0),
          to: Pos(change.to.line + shift, change.to.ch),
          text: [lst(change.text)],
          origin: change.origin
        };
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {
          from: change.from,
          to: Pos(last, getLine(doc, last).text.length),
          text: [change.text[0]],
          origin: change.origin
        };
      }
      change.removed = getBetween(doc, change.from, change.to);
      if (!selAfter) {
        selAfter = computeSelAfterChange(doc, change);
      }
      if (doc.cm) {
        makeChangeSingleDocInEditor(doc.cm, change, spans);
      } else {
        updateDoc(doc, change, spans);
      }
      setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
        doc.cantEdit = false;
      }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function(line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }
      if (doc.sel.contains(change.from, change.to) > -1) {
        signalCursorActivity(cm);
      }
      updateDoc(doc, change, spans, estimateHeight(cm));
      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
          var len = lineLength(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          cm.curOp.updateMaxLine = true;
        }
      }
      retreatFrontier(doc, from.line);
      startWorker(cm, 400);
      var lendiff = change.text.length - (to.line - from.line) - 1;
      if (change.full) {
        regChange(cm);
      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
        regLineChange(cm, from.line, "text");
      } else {
        regChange(cm, from.line, to.line + 1, lendiff);
      }
      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from,
          to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) {
          signalLater(cm, "change", cm, obj);
        }
        if (changesHandler) {
          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
      }
      cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
      var assign;
      if (!to) {
        to = from;
      }
      if (cmp(to, from) < 0) {
        assign = [to, from], from = assign[0], to = assign[1];
      }
      if (typeof code == "string") {
        code = doc.splitLines(code);
      }
      makeChange(doc, { from, to, text: code, origin });
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
      if (to < pos.line) {
        pos.line += diff;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }
    function rebaseHistArray(array4, from, to, diff) {
      for (var i2 = 0; i2 < array4.length; ++i2) {
        var sub = array4[i2], ok = true;
        if (sub.ranges) {
          if (!sub.copied) {
            sub = array4[i2] = sub.deepCopy();
            sub.copied = true;
          }
          for (var j = 0; j < sub.ranges.length; j++) {
            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
          }
          continue;
        }
        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
          var cur = sub.changes[j$1];
          if (to < cur.from.line) {
            cur.from = Pos(cur.from.line + diff, cur.from.ch);
            cur.to = Pos(cur.to.line + diff, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          array4.splice(0, i2 + 1);
          i2 = 0;
        }
      }
    }
    function rebaseHist(hist, change) {
      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
      rebaseHistArray(hist.done, from, to, diff);
      rebaseHistArray(hist.undone, from, to, diff);
    }
    function changeLine(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") {
        line = getLine(doc, clipLine(doc, handle));
      } else {
        no = lineNo(handle);
      }
      if (no == null) {
        return null;
      }
      if (op(line, no) && doc.cm) {
        regLineChange(doc.cm, no, changeType);
      }
      return line;
    }
    function LeafChunk(lines) {
      this.lines = lines;
      this.parent = null;
      var height2 = 0;
      for (var i2 = 0; i2 < lines.length; ++i2) {
        lines[i2].parent = this;
        height2 += lines[i2].height;
      }
      this.height = height2;
    }
    LeafChunk.prototype = {
      chunkSize: function() {
        return this.lines.length;
      },
      removeInner: function(at, n) {
        for (var i2 = at, e = at + n; i2 < e; ++i2) {
          var line = this.lines[i2];
          this.height -= line.height;
          cleanUpLine(line);
          signalLater(line, "delete");
        }
        this.lines.splice(at, n);
      },
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      insertInner: function(at, lines, height2) {
        this.height += height2;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i2 = 0; i2 < lines.length; ++i2) {
          lines[i2].parent = this;
        }
      },
      iterN: function(at, n, op) {
        for (var e = at + n; at < e; ++at) {
          if (op(this.lines[at])) {
            return true;
          }
        }
      }
    };
    function BranchChunk(children) {
      this.children = children;
      var size2 = 0, height2 = 0;
      for (var i2 = 0; i2 < children.length; ++i2) {
        var ch = children[i2];
        size2 += ch.chunkSize();
        height2 += ch.height;
        ch.parent = this;
      }
      this.size = size2;
      this.height = height2;
      this.parent = null;
    }
    BranchChunk.prototype = {
      chunkSize: function() {
        return this.size;
      },
      removeInner: function(at, n) {
        this.size -= n;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) {
              this.children.splice(i2--, 1);
              child.parent = null;
            }
            if ((n -= rm) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          this.children[i2].collapse(lines);
        }
      },
      insertInner: function(at, lines, height2) {
        this.size += lines.length;
        this.height += height2;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height2);
            if (child.lines && child.lines.length > 50) {
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length; ) {
                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this.children.splice(++i2, 0, leaf);
                leaf.parent = this;
              }
              child.lines = child.lines.slice(0, remaining);
              this.maybeSpill();
            }
            break;
          }
          at -= sz;
        }
      },
      maybeSpill: function() {
        if (this.children.length <= 10) {
          return;
        }
        var me = this;
        do {
          var spilled = me.children.splice(me.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me.parent) {
            var copy2 = new BranchChunk(me.children);
            copy2.parent = me;
            me.children = [copy2, sibling];
            me = copy2;
          } else {
            me.size -= sibling.size;
            me.height -= sibling.height;
            var myIndex = indexOf(me.parent.children, me);
            me.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me.parent;
        } while (me.children.length > 10);
        me.parent.maybeSpill();
      },
      iterN: function(at, n, op) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n, sz - at);
            if (child.iterN(at, used, op)) {
              return true;
            }
            if ((n -= used) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
      }
    };
    var LineWidget = function(doc, node, options2) {
      if (options2) {
        for (var opt in options2) {
          if (options2.hasOwnProperty(opt)) {
            this[opt] = options2[opt];
          }
        }
      }
      this.doc = doc;
      this.node = node;
    };
    LineWidget.prototype.clear = function() {
      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
      if (no == null || !ws) {
        return;
      }
      for (var i2 = 0; i2 < ws.length; ++i2) {
        if (ws[i2] == this) {
          ws.splice(i2--, 1);
        }
      }
      if (!ws.length) {
        line.widgets = null;
      }
      var height2 = widgetHeight(this);
      updateLineHeight(line, Math.max(0, line.height - height2));
      if (cm) {
        runInOp(cm, function() {
          adjustScrollWhenAboveVisible(cm, line, -height2);
          regLineChange(cm, no, "widget");
        });
        signalLater(cm, "lineWidgetCleared", cm, this, no);
      }
    };
    LineWidget.prototype.changed = function() {
      var this$1$1 = this;
      var oldH = this.height, cm = this.doc.cm, line = this.line;
      this.height = null;
      var diff = widgetHeight(this) - oldH;
      if (!diff) {
        return;
      }
      if (!lineIsHidden(this.doc, line)) {
        updateLineHeight(line, line.height + diff);
      }
      if (cm) {
        runInOp(cm, function() {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible(cm, line, diff);
          signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
        });
      }
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
        addToScrollTop(cm, diff);
      }
    }
    function addLineWidget(doc, handle, node, options2) {
      var widget = new LineWidget(doc, node, options2);
      var cm = doc.cm;
      if (cm && widget.noHScroll) {
        cm.display.alignWidgets = true;
      }
      changeLine(doc, handle, "widget", function(line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) {
          widgets.push(widget);
        } else {
          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
        }
        widget.line = line;
        if (cm && !lineIsHidden(doc, line)) {
          var aboveVisible = heightAtLine(line) < doc.scrollTop;
          updateLineHeight(line, line.height + widgetHeight(widget));
          if (aboveVisible) {
            addToScrollTop(cm, widget.height);
          }
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      if (cm) {
        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
      }
      return widget;
    }
    var nextMarkerId = 0;
    var TextMarker = function(doc, type4) {
      this.lines = [];
      this.type = type4;
      this.doc = doc;
      this.id = ++nextMarkerId;
    };
    TextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) {
        startOperation(cm);
      }
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) {
          signalLater(this, "clear", found.from, found.to);
        }
      }
      var min2 = null, max2 = null;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (cm && !this.collapsed) {
          regLineChange(cm, lineNo(line), "text");
        } else if (cm) {
          if (span.to != null) {
            max2 = lineNo(line);
          }
          if (span.from != null) {
            min2 = lineNo(line);
          }
        }
        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
          updateLineHeight(line, textHeight(cm.display));
        }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) {
        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (min2 != null && cm && this.collapsed) {
        regChange(cm, min2, max2 + 1);
      }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) {
          reCheckSelection(cm.doc);
        }
      }
      if (cm) {
        signalLater(cm, "markerCleared", cm, this, min2, max2);
      }
      if (withOp) {
        endOperation(cm);
      }
      if (this.parent) {
        this.parent.clear();
      }
    };
    TextMarker.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") {
        side = 1;
      }
      var from, to;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (span.from != null) {
          from = Pos(lineObj ? line : lineNo(line), span.from);
          if (side == -1) {
            return from;
          }
        }
        if (span.to != null) {
          to = Pos(lineObj ? line : lineNo(line), span.to);
          if (side == 1) {
            return to;
          }
        }
      }
      return from && { from, to };
    };
    TextMarker.prototype.changed = function() {
      var this$1$1 = this;
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) {
        return;
      }
      runInOp(cm, function() {
        var line = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight) {
            updateLineHeight(line, line.height + dHeight);
          }
        }
        signalLater(cm, "markerChanged", cm, this$1$1);
      });
    };
    TextMarker.prototype.attachLine = function(line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
      }
      this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function(line) {
      this.lines.splice(indexOf(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin(TextMarker);
    function markText(doc, from, to, options2, type4) {
      if (options2 && options2.shared) {
        return markTextShared(doc, from, to, options2, type4);
      }
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, markText)(doc, from, to, options2, type4);
      }
      var marker = new TextMarker(doc, type4), diff = cmp(from, to);
      if (options2) {
        copyObj(options2, marker, false);
      }
      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
        return marker;
      }
      if (marker.replacedWith) {
        marker.collapsed = true;
        marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
        if (!options2.handleMouseEvents) {
          marker.widgetNode.setAttribute("cm-ignore-events", "true");
        }
        if (options2.insertLeft) {
          marker.widgetNode.insertLeft = true;
        }
      }
      if (marker.collapsed) {
        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        }
        seeCollapsedSpans();
      }
      if (marker.addToHistory) {
        addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
      }
      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function(line) {
        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
          updateMaxLine = true;
        }
        if (marker.collapsed && curLine != from.line) {
          updateLineHeight(line, 0);
        }
        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
        ++curLine;
      });
      if (marker.collapsed) {
        doc.iter(from.line, to.line + 1, function(line) {
          if (lineIsHidden(doc, line)) {
            updateLineHeight(line, 0);
          }
        });
      }
      if (marker.clearOnEnter) {
        on2(marker, "beforeCursorEnter", function() {
          return marker.clear();
        });
      }
      if (marker.readOnly) {
        seeReadOnlySpans();
        if (doc.history.done.length || doc.history.undone.length) {
          doc.clearHistory();
        }
      }
      if (marker.collapsed) {
        marker.id = ++nextMarkerId;
        marker.atomic = true;
      }
      if (cm) {
        if (updateMaxLine) {
          cm.curOp.updateMaxLine = true;
        }
        if (marker.collapsed) {
          regChange(cm, from.line, to.line + 1);
        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
          for (var i2 = from.line; i2 <= to.line; i2++) {
            regLineChange(cm, i2, "text");
          }
        }
        if (marker.atomic) {
          reCheckSelection(cm.doc);
        }
        signalLater(cm, "markerAdded", cm, marker);
      }
      return marker;
    }
    var SharedTextMarker = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i2 = 0; i2 < markers.length; ++i2) {
        markers[i2].parent = this;
      }
    };
    SharedTextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      this.explicitlyCleared = true;
      for (var i2 = 0; i2 < this.markers.length; ++i2) {
        this.markers[i2].clear();
      }
      signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };
    eventMixin(SharedTextMarker);
    function markTextShared(doc, from, to, options2, type4) {
      options2 = copyObj(options2);
      options2.shared = false;
      var markers = [markText(doc, from, to, options2, type4)], primary = markers[0];
      var widget = options2.widgetNode;
      linkedDocs(doc, function(doc2) {
        if (widget) {
          options2.widgetNode = widget.cloneNode(true);
        }
        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options2, type4));
        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
          if (doc2.linked[i2].isParent) {
            return;
          }
        }
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m2) {
        return m2.parent;
      });
    }
    function copySharedMarkers(doc, markers) {
      for (var i2 = 0; i2 < markers.length; i2++) {
        var marker = markers[i2], pos = marker.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
          marker.markers.push(subMark);
          subMark.parent = marker;
        }
      }
    }
    function detachSharedMarkers(markers) {
      var loop = function(i3) {
        var marker = markers[i3], linked = [marker.primary.doc];
        linkedDocs(marker.primary.doc, function(d2) {
          return linked.push(d2);
        });
        for (var j = 0; j < marker.markers.length; j++) {
          var subMarker = marker.markers[j];
          if (indexOf(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker.markers.splice(j--, 1);
          }
        }
      };
      for (var i2 = 0; i2 < markers.length; i2++)
        loop(i2);
    }
    var nextDocId = 0;
    var Doc = function(text, mode, firstLine, lineSep, direction) {
      if (!(this instanceof Doc)) {
        return new Doc(text, mode, firstLine, lineSep, direction);
      }
      if (firstLine == null) {
        firstLine = 0;
      }
      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start2 = Pos(firstLine, 0);
      this.sel = simpleSelection(start2);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;
      this.lineSep = lineSep;
      this.direction = direction == "rtl" ? "rtl" : "ltr";
      this.extend = false;
      if (typeof text == "string") {
        text = this.splitLines(text);
      }
      updateDoc(this, { from: start2, to: start2, text });
      setSelection(this, simpleSelection(start2), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      iter: function(from, to, op) {
        if (op) {
          this.iterN(from - this.first, to - from, op);
        } else {
          this.iterN(this.first, this.first + this.size, from);
        }
      },
      insert: function(at, lines) {
        var height2 = 0;
        for (var i2 = 0; i2 < lines.length; ++i2) {
          height2 += lines[i2].height;
        }
        this.insertInner(at - this.first, lines, height2);
      },
      remove: function(at, n) {
        this.removeInner(at - this.first, n);
      },
      getValue: function(lineSep) {
        var lines = getLines(this, this.first, this.first + this.size);
        if (lineSep === false) {
          return lines;
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      setValue: docMethodOp(function(code) {
        var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {
          from: top2,
          to: Pos(last, getLine(this, last).text.length),
          text: this.splitLines(code),
          origin: "setValue",
          full: true
        }, true);
        if (this.cm) {
          scrollToCoords(this.cm, 0, 0);
        }
        setSelection(this, simpleSelection(top2), sel_dontScroll);
      }),
      replaceRange: function(code, from, to, origin) {
        from = clipPos(this, from);
        to = to ? clipPos(this, to) : from;
        replaceRange(this, code, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
        if (lineSep === false) {
          return lines;
        }
        if (lineSep === "") {
          return lines.join("");
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      getLine: function(line) {
        var l2 = this.getLineHandle(line);
        return l2 && l2.text;
      },
      getLineHandle: function(line) {
        if (isLine(this, line)) {
          return getLine(this, line);
        }
      },
      getLineNumber: function(line) {
        return lineNo(line);
      },
      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") {
          line = getLine(this, line);
        }
        return visualLine(line);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(pos) {
        return clipPos(this, pos);
      },
      getCursor: function(start2) {
        var range4 = this.sel.primary(), pos;
        if (start2 == null || start2 == "head") {
          pos = range4.head;
        } else if (start2 == "anchor") {
          pos = range4.anchor;
        } else if (start2 == "end" || start2 == "to" || start2 === false) {
          pos = range4.to();
        } else {
          pos = range4.from();
        }
        return pos;
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: docMethodOp(function(line, ch, options2) {
        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options2);
      }),
      setSelection: docMethodOp(function(anchor, head, options2) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options2);
      }),
      extendSelection: docMethodOp(function(head, other, options2) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options2);
      }),
      extendSelections: docMethodOp(function(heads, options2) {
        extendSelections(this, clipPosArray(this, heads), options2);
      }),
      extendSelectionsBy: docMethodOp(function(f2, options2) {
        var heads = map(this.sel.ranges, f2);
        extendSelections(this, clipPosArray(this, heads), options2);
      }),
      setSelections: docMethodOp(function(ranges, primary, options2) {
        if (!ranges.length) {
          return;
        }
        var out = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          out[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
        }
        if (primary == null) {
          primary = Math.min(ranges.length - 1, this.sel.primIndex);
        }
        setSelection(this, normalizeSelection(this.cm, out, primary), options2);
      }),
      addSelection: docMethodOp(function(anchor, head, options2) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options2);
      }),
      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) {
          return lines;
        } else {
          return lines.join(lineSep || this.lineSeparator());
        }
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          if (lineSep !== false) {
            sel = sel.join(lineSep || this.lineSeparator());
          }
          parts[i2] = sel;
        }
        return parts;
      },
      replaceSelection: function(code, collapse, origin) {
        var dup = [];
        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
          dup[i2] = code;
        }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
          var range4 = sel.ranges[i2];
          changes[i2] = { from: range4.from(), to: range4.to(), text: this.splitLines(code[i2]), origin };
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
          makeChange(this, changes[i$12]);
        }
        if (newSel) {
          setSelectionReplaceHistory(this, newSel);
        } else if (this.cm) {
          ensureCursorVisible(this.cm);
        }
      }),
      undo: docMethodOp(function() {
        makeChangeFromHistory(this, "undo");
      }),
      redo: docMethodOp(function() {
        makeChangeFromHistory(this, "redo");
      }),
      undoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "undo", true);
      }),
      redoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "redo", true);
      }),
      setExtending: function(val) {
        this.extend = val;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i2 = 0; i2 < hist.done.length; i2++) {
          if (!hist.done[i2].ranges) {
            ++done;
          }
        }
        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
          if (!hist.undone[i$12].ranges) {
            ++undone;
          }
        }
        return { undo: done, redo: undone };
      },
      clearHistory: function() {
        var this$1$1 = this;
        this.history = new History(this.history);
        linkedDocs(this, function(doc) {
          return doc.history = this$1$1.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit) {
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        }
        return this.history.generation;
      },
      isClean: function(gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },
      getHistory: function() {
        return {
          done: copyHistoryArray(this.history.done),
          undone: copyHistoryArray(this.history.undone)
        };
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },
      setGutterMarker: docMethodOp(function(line, gutterID, value) {
        return changeLine(this, line, "gutter", function(line2) {
          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty2(markers)) {
            line2.gutterMarkers = null;
          }
          return true;
        });
      }),
      clearGutter: docMethodOp(function(gutterID) {
        var this$1$1 = this;
        this.iter(function(line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            changeLine(this$1$1, line, "gutter", function() {
              line.gutterMarkers[gutterID] = null;
              if (isEmpty2(line.gutterMarkers)) {
                line.gutterMarkers = null;
              }
              return true;
            });
          }
        });
      }),
      lineInfo: function(line) {
        var n;
        if (typeof line == "number") {
          if (!isLine(this, line)) {
            return null;
          }
          n = line;
          line = getLine(this, line);
          if (!line) {
            return null;
          }
        } else {
          n = lineNo(line);
          if (n == null) {
            return null;
          }
        }
        return {
          line: n,
          handle: line,
          text: line.text,
          gutterMarkers: line.gutterMarkers,
          textClass: line.textClass,
          bgClass: line.bgClass,
          wrapClass: line.wrapClass,
          widgets: line.widgets
        };
      },
      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line[prop2]) {
            line[prop2] = cls;
          } else if (classTest(cls).test(line[prop2])) {
            return false;
          } else {
            line[prop2] += " " + cls;
          }
          return true;
        });
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line[prop2];
          if (!cur) {
            return false;
          } else if (cls == null) {
            line[prop2] = null;
          } else {
            var found = cur.match(classTest(cls));
            if (!found) {
              return false;
            }
            var end2 = found.index + found[0].length;
            line[prop2] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
          }
          return true;
        });
      }),
      addLineWidget: docMethodOp(function(handle, node, options2) {
        return addLineWidget(this, handle, node, options2);
      }),
      removeLineWidget: function(widget) {
        widget.clear();
      },
      markText: function(from, to, options2) {
        return markText(this, clipPos(this, from), clipPos(this, to), options2, options2 && options2.type || "range");
      },
      setBookmark: function(pos, options2) {
        var realOpts = {
          replacedWith: options2 && (options2.nodeType == null ? options2.widget : options2),
          insertLeft: options2 && options2.insertLeft,
          clearWhenEmpty: false,
          shared: options2 && options2.shared,
          handleMouseEvents: options2 && options2.handleMouseEvents
        };
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine(this, pos.line).markedSpans;
        if (spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
              markers.push(span.marker.parent || span.marker);
            }
          }
        }
        return markers;
      },
      findMarks: function(from, to, filter) {
        from = clipPos(this, from);
        to = clipPos(this, to);
        var found = [], lineNo2 = from.line;
        this.iter(from.line, to.line + 1, function(line) {
          var spans = line.markedSpans;
          if (spans) {
            for (var i2 = 0; i2 < spans.length; i2++) {
              var span = spans[i2];
              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                found.push(span.marker.parent || span.marker);
              }
            }
          }
          ++lineNo2;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line) {
          var sps = line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              if (sps[i2].from != null) {
                markers.push(sps[i2].marker);
              }
            }
          }
        });
        return markers;
      },
      posFromIndex: function(off3) {
        var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function(line) {
          var sz = line.text.length + sepSize;
          if (sz > off3) {
            ch = off3;
            return true;
          }
          off3 -= sz;
          ++lineNo2;
        });
        return clipPos(this, Pos(lineNo2, ch));
      },
      indexFromPos: function(coords) {
        coords = clipPos(this, coords);
        var index2 = coords.ch;
        if (coords.line < this.first || coords.ch < 0) {
          return 0;
        }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function(line) {
          index2 += line.text.length + sepSize;
        });
        return index2;
      },
      copy: function(copyHistory) {
        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        doc.scrollTop = this.scrollTop;
        doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc;
      },
      linkedDoc: function(options2) {
        if (!options2) {
          options2 = {};
        }
        var from = this.first, to = this.first + this.size;
        if (options2.from != null && options2.from > from) {
          from = options2.from;
        }
        if (options2.to != null && options2.to < to) {
          to = options2.to;
        }
        var copy2 = new Doc(getLines(this, from, to), options2.mode || this.modeOption, from, this.lineSep, this.direction);
        if (options2.sharedHist) {
          copy2.history = this.history;
        }
        (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options2.sharedHist });
        copy2.linked = [{ doc: this, isParent: true, sharedHist: options2.sharedHist }];
        copySharedMarkers(copy2, findSharedMarkers(this));
        return copy2;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror2) {
          other = other.doc;
        }
        if (this.linked) {
          for (var i2 = 0; i2 < this.linked.length; ++i2) {
            var link = this.linked[i2];
            if (link.doc != other) {
              continue;
            }
            this.linked.splice(i2, 1);
            other.unlinkDoc(this);
            detachSharedMarkers(findSharedMarkers(this));
            break;
          }
        }
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function(doc) {
            return splitIds.push(doc.id);
          }, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f2) {
        linkedDocs(this, f2);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(str) {
        if (this.lineSep) {
          return str.split(this.lineSep);
        }
        return splitLinesAuto(str);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: docMethodOp(function(dir) {
        if (dir != "rtl") {
          dir = "ltr";
        }
        if (dir == this.direction) {
          return;
        }
        this.direction = dir;
        this.iter(function(line) {
          return line.order = null;
        });
        if (this.cm) {
          directionChanged(this.cm);
        }
      })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var lastDrop = 0;
    function onDrop(e) {
      var cm = this;
      clearDragCursor(cm);
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e_preventDefault(e);
      if (ie) {
        lastDrop = +new Date();
      }
      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
      if (!pos || cm.isReadOnly()) {
        return;
      }
      if (files && files.length && window.FileReader && window.File) {
        var n = files.length, text = Array(n), read2 = 0;
        var markAsReadAndPasteIfAllFilesAreRead = function() {
          if (++read2 == n) {
            operation(cm, function() {
              pos = clipPos(cm.doc, pos);
              var change = {
                from: pos,
                to: pos,
                text: cm.doc.splitLines(text.filter(function(t) {
                  return t != null;
                }).join(cm.doc.lineSeparator())),
                origin: "paste"
              };
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
            })();
          }
        };
        var readTextFromFile = function(file, i3) {
          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          var reader = new FileReader();
          reader.onerror = function() {
            return markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.onload = function() {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            text[i3] = content;
            markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.readAsText(file);
        };
        for (var i2 = 0; i2 < files.length; i2++) {
          readTextFromFile(files[i2], i2);
        }
      } else {
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          setTimeout(function() {
            return cm.display.input.focus();
          }, 20);
          return;
        }
        try {
          var text$1 = e.dataTransfer.getData("Text");
          if (text$1) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy) {
              selected = cm.listSelections();
            }
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) {
              for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
              }
            }
            cm.replaceSelection(text$1, "around", "paste");
            cm.display.input.focus();
          }
        } catch (e$1) {
        }
      }
    }
    function onDragStart(cm, e) {
      if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
        e_stop(e);
        return;
      }
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e.dataTransfer.setData("Text", cm.getSelection());
      e.dataTransfer.effectAllowed = "copyMove";
      if (e.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto) {
          img.parentNode.removeChild(img);
        }
      }
    }
    function onDragOver(cm, e) {
      var pos = posFromMouse(cm, e);
      if (!pos) {
        return;
      }
      var frag = document.createDocumentFragment();
      drawSelectionCursor(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }
    function forEachCodeMirror(f2) {
      if (!document.getElementsByClassName) {
        return;
      }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i2 = 0; i2 < byClass.length; i2++) {
        var cm = byClass[i2].CodeMirror;
        if (cm) {
          editors.push(cm);
        }
      }
      if (editors.length) {
        editors[0].operation(function() {
          for (var i3 = 0; i3 < editors.length; i3++) {
            f2(editors[i3]);
          }
        });
      }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) {
        return;
      }
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      var resizeTimer;
      on2(window, "resize", function() {
        if (resizeTimer == null) {
          resizeTimer = setTimeout(function() {
            resizeTimer = null;
            forEachCodeMirror(onResize);
          }, 100);
        }
      });
      on2(window, "blur", function() {
        return forEachCodeMirror(onBlur);
      });
    }
    function onResize(cm) {
      var d2 = cm.display;
      d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
      d2.scrollbarsClipped = false;
      cm.setSize();
    }
    var keyNames = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    };
    for (var i = 0; i < 10; i++) {
      keyNames[i + 48] = keyNames[i + 96] = String(i);
    }
    for (var i$1 = 65; i$1 <= 90; i$1++) {
      keyNames[i$1] = String.fromCharCode(i$1);
    }
    for (var i$2 = 1; i$2 <= 12; i$2++) {
      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    }
    var keyMap = {};
    keyMap.basic = {
      "Left": "goCharLeft",
      "Right": "goCharRight",
      "Up": "goLineUp",
      "Down": "goLineDown",
      "End": "goLineEnd",
      "Home": "goLineStartSmart",
      "PageUp": "goPageUp",
      "PageDown": "goPageDown",
      "Delete": "delCharAfter",
      "Backspace": "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab",
      "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent",
      "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    keyMap.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      "fallthrough": "basic"
    };
    keyMap.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      "fallthrough": ["basic", "emacsy"]
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/);
      name = parts[parts.length - 1];
      var alt, ctrl, shift, cmd;
      for (var i2 = 0; i2 < parts.length - 1; i2++) {
        var mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          cmd = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else {
          throw new Error("Unrecognized modifier name: " + mod);
        }
      }
      if (alt) {
        name = "Alt-" + name;
      }
      if (ctrl) {
        name = "Ctrl-" + name;
      }
      if (cmd) {
        name = "Cmd-" + name;
      }
      if (shift) {
        name = "Shift-" + name;
      }
      return name;
    }
    function normalizeKeyMap(keymap) {
      var copy2 = {};
      for (var keyname in keymap) {
        if (keymap.hasOwnProperty(keyname)) {
          var value = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
            continue;
          }
          if (value == "...") {
            delete keymap[keyname];
            continue;
          }
          var keys2 = map(keyname.split(" "), normalizeKeyName);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var val = void 0, name = void 0;
            if (i2 == keys2.length - 1) {
              name = keys2.join(" ");
              val = value;
            } else {
              name = keys2.slice(0, i2 + 1).join(" ");
              val = "...";
            }
            var prev = copy2[name];
            if (!prev) {
              copy2[name] = val;
            } else if (prev != val) {
              throw new Error("Inconsistent bindings for " + name);
            }
          }
          delete keymap[keyname];
        }
      }
      for (var prop2 in copy2) {
        keymap[prop2] = copy2[prop2];
      }
      return keymap;
    }
    function lookupKey(key2, map2, handle, context) {
      map2 = getKeyMap(map2);
      var found = map2.call ? map2.call(key2, context) : map2[key2];
      if (found === false) {
        return "nothing";
      }
      if (found === "...") {
        return "multi";
      }
      if (found != null && handle(found)) {
        return "handled";
      }
      if (map2.fallthrough) {
        if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
          return lookupKey(key2, map2.fallthrough, handle, context);
        }
        for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {
          var result = lookupKey(key2, map2.fallthrough[i2], handle, context);
          if (result) {
            return result;
          }
        }
      }
    }
    function isModifierKey(value) {
      var name = typeof value == "string" ? value : keyNames[value.keyCode];
      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
    }
    function addModifierNames(name, event, noShift) {
      var base2 = name;
      if (event.altKey && base2 != "Alt") {
        name = "Alt-" + name;
      }
      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
        name = "Ctrl-" + name;
      }
      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
        name = "Cmd-" + name;
      }
      if (!noShift && event.shiftKey && base2 != "Shift") {
        name = "Shift-" + name;
      }
      return name;
    }
    function keyName(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) {
        return false;
      }
      var name = keyNames[event.keyCode];
      if (name == null || event.altGraphKey) {
        return false;
      }
      if (event.keyCode == 3 && event.code) {
        name = event.code;
      }
      return addModifierNames(name, event, noShift);
    }
    function getKeyMap(val) {
      return typeof val == "string" ? keyMap[val] : val;
    }
    function deleteNearSelection(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var toKill = compute(ranges[i2]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      runInOp(cm, function() {
        for (var i3 = kill.length - 1; i3 >= 0; i3--) {
          replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
        }
        ensureCursorVisible(cm);
      });
    }
    function moveCharLogically(line, ch, dir) {
      var target = skipExtendingChars(line.text, ch + dir, dir);
      return target < 0 || target > line.text.length ? null : target;
    }
    function moveLogically(line, start2, dir) {
      var ch = moveCharLogically(line, start2.ch, dir);
      return ch == null ? null : new Pos(start2.line, ch, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo2, dir) {
      if (visually) {
        if (cm.doc.direction == "rtl") {
          dir = -dir;
        }
        var order2 = getOrder(lineObj, cm.doc.direction);
        if (order2) {
          var part = dir < 0 ? lst(order2) : order2[0];
          var moveInStorageOrder = dir < 0 == (part.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch;
          if (part.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine(cm, lineObj);
            ch = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared(cm, prep, ch).top;
            ch = findFirst(function(ch2) {
              return measureCharPrepared(cm, prep, ch2).top == targetTop;
            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
            if (sticky == "before") {
              ch = moveCharLogically(lineObj, ch, 1);
            }
          } else {
            ch = dir < 0 ? part.to : part.from;
          }
          return new Pos(lineNo2, ch, sticky);
        }
      }
      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line, start2, dir) {
      var bidi = getOrder(line, cm.doc.direction);
      if (!bidi) {
        return moveLogically(line, start2, dir);
      }
      if (start2.ch >= line.text.length) {
        start2.ch = line.text.length;
        start2.sticky = "before";
      } else if (start2.ch <= 0) {
        start2.ch = 0;
        start2.sticky = "after";
      }
      var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part = bidi[partPos];
      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start2.ch : part.from < start2.ch)) {
        return moveLogically(line, start2, dir);
      }
      var mv = function(pos, dir2) {
        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
      };
      var prep;
      var getWrappedLineExtent = function(ch2) {
        if (!cm.options.lineWrapping) {
          return { begin: 0, end: line.text.length };
        }
        prep = prep || prepareMeasureForLine(cm, line);
        return wrappedLineExtentChar(cm, line, prep, ch2);
      };
      var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
      if (cm.doc.direction == "rtl" || part.level == 1) {
        var moveInStorageOrder = part.level == 1 == dir < 0;
        var ch = mv(start2, moveInStorageOrder ? 1 : -1);
        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos(start2.line, ch, sticky);
        }
      }
      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
        var getRes = function(ch3, moveInStorageOrder3) {
          return moveInStorageOrder3 ? new Pos(start2.line, mv(ch3, 1), "before") : new Pos(start2.line, ch3, "after");
        };
        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
          var part2 = bidi[partPos2];
          var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
          var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
          if (part2.from <= ch2 && ch2 < part2.to) {
            return getRes(ch2, moveInStorageOrder2);
          }
          ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
          if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
            return getRes(ch2, moveInStorageOrder2);
          }
        }
      };
      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
      if (res) {
        return res;
      }
      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res) {
          return res;
        }
      }
      return null;
    }
    var commands = {
      selectAll,
      singleSelection: function(cm) {
        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
      },
      killLine: function(cm) {
        return deleteNearSelection(cm, function(range4) {
          if (range4.empty()) {
            var len = getLine(cm.doc, range4.head.line).text.length;
            if (range4.head.ch == len && range4.head.line < cm.lastLine()) {
              return { from: range4.head, to: Pos(range4.head.line + 1, 0) };
            } else {
              return { from: range4.head, to: Pos(range4.head.line, len) };
            }
          } else {
            return { from: range4.from(), to: range4.to() };
          }
        });
      },
      deleteLine: function(cm) {
        return deleteNearSelection(cm, function(range4) {
          return {
            from: Pos(range4.from().line, 0),
            to: clipPos(cm.doc, Pos(range4.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range4) {
          return {
            from: Pos(range4.from().line, 0),
            to: range4.from()
          };
        });
      },
      delWrappedLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range4) {
          var top2 = cm.charCoords(range4.head, "div").top + 5;
          var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
          return { from: leftPos, to: range4.from() };
        });
      },
      delWrappedLineRight: function(cm) {
        return deleteNearSelection(cm, function(range4) {
          var top2 = cm.charCoords(range4.head, "div").top + 5;
          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
          return { from: range4.from(), to: rightPos };
        });
      },
      undo: function(cm) {
        return cm.undo();
      },
      redo: function(cm) {
        return cm.redo();
      },
      undoSelection: function(cm) {
        return cm.undoSelection();
      },
      redoSelection: function(cm) {
        return cm.redoSelection();
      },
      goDocStart: function(cm) {
        return cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function(cm) {
        return cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          return lineStart(cm, range4.head.line);
        }, { origin: "+move", bias: 1 });
      },
      goLineStartSmart: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          return lineStartSmart(cm, range4.head);
        }, { origin: "+move", bias: 1 });
      },
      goLineEnd: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          return lineEnd(cm, range4.head.line);
        }, { origin: "+move", bias: -1 });
      },
      goLineRight: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          var top2 = cm.cursorCoords(range4.head, "div").top + 5;
          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeft: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          var top2 = cm.cursorCoords(range4.head, "div").top + 5;
          return cm.coordsChar({ left: 0, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeftSmart: function(cm) {
        return cm.extendSelectionsBy(function(range4) {
          var top2 = cm.cursorCoords(range4.head, "div").top + 5;
          var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
            return lineStartSmart(cm, range4.head);
          }
          return pos;
        }, sel_move);
      },
      goLineUp: function(cm) {
        return cm.moveV(-1, "line");
      },
      goLineDown: function(cm) {
        return cm.moveV(1, "line");
      },
      goPageUp: function(cm) {
        return cm.moveV(-1, "page");
      },
      goPageDown: function(cm) {
        return cm.moveV(1, "page");
      },
      goCharLeft: function(cm) {
        return cm.moveH(-1, "char");
      },
      goCharRight: function(cm) {
        return cm.moveH(1, "char");
      },
      goColumnLeft: function(cm) {
        return cm.moveH(-1, "column");
      },
      goColumnRight: function(cm) {
        return cm.moveH(1, "column");
      },
      goWordLeft: function(cm) {
        return cm.moveH(-1, "word");
      },
      goGroupRight: function(cm) {
        return cm.moveH(1, "group");
      },
      goGroupLeft: function(cm) {
        return cm.moveH(-1, "group");
      },
      goWordRight: function(cm) {
        return cm.moveH(1, "word");
      },
      delCharBefore: function(cm) {
        return cm.deleteH(-1, "codepoint");
      },
      delCharAfter: function(cm) {
        return cm.deleteH(1, "char");
      },
      delWordBefore: function(cm) {
        return cm.deleteH(-1, "word");
      },
      delWordAfter: function(cm) {
        return cm.deleteH(1, "word");
      },
      delGroupBefore: function(cm) {
        return cm.deleteH(-1, "group");
      },
      delGroupAfter: function(cm) {
        return cm.deleteH(1, "group");
      },
      indentAuto: function(cm) {
        return cm.indentSelection("smart");
      },
      indentMore: function(cm) {
        return cm.indentSelection("add");
      },
      indentLess: function(cm) {
        return cm.indentSelection("subtract");
      },
      insertTab: function(cm) {
        return cm.replaceSelection("	");
      },
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var pos = ranges[i2].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.execCommand("insertTab");
        }
      },
      transposeChars: function(cm) {
        return runInOp(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            if (!ranges[i2].empty()) {
              continue;
            }
            var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) {
                cur = new Pos(cur.line, cur.ch - 1);
              }
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos(cur.line, 1);
                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        return runInOp(cm, function() {
          var sels = cm.listSelections();
          for (var i2 = sels.length - 1; i2 >= 0; i2--) {
            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
          }
          sels = cm.listSelections();
          for (var i$12 = 0; i$12 < sels.length; i$12++) {
            cm.indentLine(sels[i$12].from().line, null, true);
          }
          ensureCursorVisible(cm);
        });
      },
      openLine: function(cm) {
        return cm.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(cm) {
        return cm.toggleOverwrite();
      }
    };
    function lineStart(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLine(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLineEnd(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, line, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
      var start2 = lineStart(cm, pos.line);
      var line = getLine(cm.doc, start2.line);
      var order2 = getOrder(line, cm.doc.direction);
      if (!order2 || order2[0].level == 0) {
        var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
        var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
      }
      return start2;
    }
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) {
          return false;
        }
      }
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        if (dropShift) {
          cm.display.shift = false;
        }
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
        var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);
        if (result) {
          return result;
        }
      }
      return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name, e, handle) {
      var seq = cm.state.keySeq;
      if (seq) {
        if (isModifierKey(name)) {
          return "handled";
        }
        if (/\'$/.test(name)) {
          cm.state.keySeq = null;
        } else {
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
        }
        if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
          return true;
        }
      }
      return dispatchKeyInner(cm, name, e, handle);
    }
    function dispatchKeyInner(cm, name, e, handle) {
      var result = lookupKeyForEditor(cm, name, handle);
      if (result == "multi") {
        cm.state.keySeq = name;
      }
      if (result == "handled") {
        signalLater(cm, "keyHandled", cm, name, e);
      }
      if (result == "handled" || result == "multi") {
        e_preventDefault(e);
        restartBlink(cm);
      }
      return !!result;
    }
    function handleKeyBinding(cm, e) {
      var name = keyName(e, true);
      if (!name) {
        return false;
      }
      if (e.shiftKey && !cm.state.keySeq) {
        return dispatchKey(cm, "Shift-" + name, e, function(b2) {
          return doHandleBinding(cm, b2, true);
        }) || dispatchKey(cm, name, e, function(b2) {
          if (typeof b2 == "string" ? /^go[A-Z]/.test(b2) : b2.motion) {
            return doHandleBinding(cm, b2);
          }
        });
      } else {
        return dispatchKey(cm, name, e, function(b2) {
          return doHandleBinding(cm, b2);
        });
      }
    }
    function handleCharBinding(cm, e, ch) {
      return dispatchKey(cm, "'" + ch + "'", e, function(b2) {
        return doHandleBinding(cm, b2, true);
      });
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      cm.curOp.focus = activeElt();
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (ie && ie_version < 11 && e.keyCode == 27) {
        e.returnValue = false;
      }
      var code = e.keyCode;
      cm.display.shift = code == 16 || e.shiftKey;
      var handled = handleKeyBinding(cm, e);
      if (presto) {
        lastStoppedKey = handled ? code : null;
        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
          cm.replaceSelection("", null, "cut");
        }
      }
      if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
        document.execCommand("cut");
      }
      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
        showCrossHair(cm);
      }
    }
    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass2(lineDiv, "CodeMirror-crosshair");
      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off2(document, "keyup", up);
          off2(document, "mouseover", up);
        }
      }
      on2(document, "keyup", up);
      on2(document, "mouseover", up);
    }
    function onKeyUp(e) {
      if (e.keyCode == 16) {
        this.doc.sel.shift = false;
      }
      signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
        return;
      }
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto && keyCode == lastStoppedKey) {
        lastStoppedKey = null;
        e_preventDefault(e);
        return;
      }
      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
        return;
      }
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (ch == "\b") {
        return;
      }
      if (handleCharBinding(cm, e, ch)) {
        return;
      }
      cm.display.input.onKeyPress(e);
    }
    var DOUBLECLICK_DELAY = 400;
    var PastClick = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };
    PastClick.prototype.compare = function(time, pos, button) {
      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
      var now2 = +new Date();
      if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
        lastClick = lastDoubleClick = null;
        return "triple";
      } else if (lastClick && lastClick.compare(now2, pos, button)) {
        lastDoubleClick = new PastClick(now2, pos, button);
        lastClick = null;
        return "double";
      } else {
        lastClick = new PastClick(now2, pos, button);
        lastDoubleClick = null;
        return "single";
      }
    }
    function onMouseDown(e) {
      var cm = this, display = cm.display;
      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
        return;
      }
      display.input.ensurePolled();
      display.shift = e.shiftKey;
      if (eventInWidget(display, e)) {
        if (!webkit) {
          display.scroller.draggable = false;
          setTimeout(function() {
            return display.scroller.draggable = true;
          }, 100);
        }
        return;
      }
      if (clickInGutter(cm, e)) {
        return;
      }
      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
      window.focus();
      if (button == 1 && cm.state.selectingText) {
        cm.state.selectingText(e);
      }
      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
        return;
      }
      if (button == 1) {
        if (pos) {
          leftButtonDown(cm, pos, repeat, e);
        } else if (e_target(e) == display.scroller) {
          e_preventDefault(e);
        }
      } else if (button == 2) {
        if (pos) {
          extendSelection(cm.doc, pos);
        }
        setTimeout(function() {
          return display.input.focus();
        }, 20);
      } else if (button == 3) {
        if (captureRightClick) {
          cm.display.input.onContextMenu(e);
        } else {
          delayBlurEvent(cm);
        }
      }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
      var name = "Click";
      if (repeat == "double") {
        name = "Double" + name;
      } else if (repeat == "triple") {
        name = "Triple" + name;
      }
      name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
      return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
        if (typeof bound == "string") {
          bound = commands[bound];
        }
        if (!bound) {
          return false;
        }
        var done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          done = bound(cm, pos) != Pass;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done;
      });
    }
    function configureMouse(cm, repeat, event) {
      var option2 = cm.getOption("configureMouse");
      var value = option2 ? option2(cm, repeat, event) : {};
      if (value.unit == null) {
        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
        value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
      }
      if (value.extend == null || cm.doc.extend) {
        value.extend = cm.doc.extend || event.shiftKey;
      }
      if (value.addNew == null) {
        value.addNew = mac ? event.metaKey : event.ctrlKey;
      }
      if (value.moveOnDrag == null) {
        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
      }
      return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
      if (ie) {
        setTimeout(bind(ensureFocus, cm), 0);
      } else {
        cm.curOp.focus = activeElt();
      }
      var behavior = configureMouse(cm, repeat, event);
      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
        leftButtonStartDrag(cm, event, pos, behavior);
      } else {
        leftButtonSelect(cm, event, pos, behavior);
      }
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
      var display = cm.display, moved2 = false;
      var dragEnd = operation(cm, function(e) {
        if (webkit) {
          display.scroller.draggable = false;
        }
        cm.state.draggingText = false;
        if (cm.state.delayingBlurEvent) {
          if (cm.hasFocus()) {
            cm.state.delayingBlurEvent = false;
          } else {
            delayBlurEvent(cm);
          }
        }
        off2(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off2(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off2(display.scroller, "dragstart", dragStart2);
        off2(display.scroller, "drop", dragEnd);
        if (!moved2) {
          e_preventDefault(e);
          if (!behavior.addNew) {
            extendSelection(cm.doc, pos, null, null, behavior.extend);
          }
          if (webkit && !safari || ie && ie_version == 9) {
            setTimeout(function() {
              display.wrapper.ownerDocument.body.focus({ preventScroll: true });
              display.input.focus();
            }, 20);
          } else {
            display.input.focus();
          }
        }
      });
      var mouseMove = function(e2) {
        moved2 = moved2 || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
      };
      var dragStart2 = function() {
        return moved2 = true;
      };
      if (webkit) {
        display.scroller.draggable = true;
      }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      on2(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on2(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on2(display.scroller, "dragstart", dragStart2);
      on2(display.scroller, "drop", dragEnd);
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        return display.input.focus();
      }, 20);
      if (display.scroller.dragDrop) {
        display.scroller.dragDrop();
      }
    }
    function rangeForUnit(cm, pos, unit) {
      if (unit == "char") {
        return new Range(pos, pos);
      }
      if (unit == "word") {
        return cm.findWordAt(pos);
      }
      if (unit == "line") {
        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
      }
      var result = unit(cm, pos);
      return new Range(result.from, result.to);
    }
    function leftButtonSelect(cm, event, start2, behavior) {
      if (ie) {
        delayBlurEvent(cm);
      }
      var display = cm.display, doc = cm.doc;
      e_preventDefault(event);
      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc.sel.contains(start2);
        if (ourIndex > -1) {
          ourRange = ranges[ourIndex];
        } else {
          ourRange = new Range(start2, start2);
        }
      } else {
        ourRange = doc.sel.primary();
        ourIndex = doc.sel.primIndex;
      }
      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) {
          ourRange = new Range(start2, start2);
        }
        start2 = posFromMouse(cm, event, true, true);
        ourIndex = -1;
      } else {
        var range4 = rangeForUnit(cm, start2, behavior.unit);
        if (behavior.extend) {
          ourRange = extendRange(ourRange, range4.anchor, range4.head, behavior.extend);
        } else {
          ourRange = range4;
        }
      }
      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
        startSel = doc.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
        startSel = doc.sel;
      } else {
        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
      }
      var lastPos = start2;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) {
          return;
        }
        lastPos = pos;
        if (behavior.unit == "rectangle") {
          var ranges2 = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine(doc, start2.line).text, start2.ch, tabSize);
          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
          var left2 = Math.min(startCol, posCol), right2 = Math.max(startCol, posCol);
          for (var line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {
            var text = getLine(doc, line).text, leftPos = findColumn(text, left2, tabSize);
            if (left2 == right2) {
              ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
            } else if (text.length > leftPos) {
              ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right2, tabSize))));
            }
          }
          if (!ranges2.length) {
            ranges2.push(new Range(start2, start2));
          }
          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range5 = rangeForUnit(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp(range5.anchor, anchor) > 0) {
            head = range5.head;
            anchor = minPos(oldRange.from(), range5.anchor);
          } else {
            head = range5.anchor;
            anchor = maxPos(oldRange.to(), range5.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
        }
      }
      var editorSize = display.wrapper.getBoundingClientRect();
      var counter = 0;
      function extend2(e) {
        var curCount = ++counter;
        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
        if (!cur) {
          return;
        }
        if (cmp(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt();
          extendTo(cur);
          var visible = visibleLines(display, doc);
          if (cur.line >= visible.to || cur.line < visible.from) {
            setTimeout(operation(cm, function() {
              if (counter == curCount) {
                extend2(e);
              }
            }), 150);
          }
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) {
            setTimeout(operation(cm, function() {
              if (counter != curCount) {
                return;
              }
              display.scroller.scrollTop += outside;
              extend2(e);
            }), 50);
          }
        }
      }
      function done(e) {
        cm.state.selectingText = false;
        counter = Infinity;
        if (e) {
          e_preventDefault(e);
          display.input.focus();
        }
        off2(display.wrapper.ownerDocument, "mousemove", move);
        off2(display.wrapper.ownerDocument, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }
      var move = operation(cm, function(e) {
        if (e.buttons === 0 || !e_button(e)) {
          done(e);
        } else {
          extend2(e);
        }
      });
      var up = operation(cm, done);
      cm.state.selectingText = up;
      on2(display.wrapper.ownerDocument, "mousemove", move);
      on2(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify(cm, range4) {
      var anchor = range4.anchor;
      var head = range4.head;
      var anchorLine = getLine(cm.doc, anchor.line);
      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
        return range4;
      }
      var order2 = getOrder(anchorLine);
      if (!order2) {
        return range4;
      }
      var index2 = getBidiPartAt(order2, anchor.ch, anchor.sticky), part = order2[index2];
      if (part.from != anchor.ch && part.to != anchor.ch) {
        return range4;
      }
      var boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order2.length) {
        return range4;
      }
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt(order2, head.ch, head.sticky);
        var dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary) {
          leftSide = dir < 0;
        } else {
          leftSide = dir > 0;
        }
      }
      var usePart = order2[boundary + (leftSide ? -1 : 0)];
      var from = leftSide == (usePart.level == 1);
      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
      return anchor.ch == ch && anchor.sticky == sticky ? range4 : new Range(new Pos(anchor.line, ch, sticky), head);
    }
    function gutterEvent(cm, e, type4, prevent) {
      var mX, mY;
      if (e.touches) {
        mX = e.touches[0].clientX;
        mY = e.touches[0].clientY;
      } else {
        try {
          mX = e.clientX;
          mY = e.clientY;
        } catch (e$1) {
          return false;
        }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
        return false;
      }
      if (prevent) {
        e_preventDefault(e);
      }
      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();
      if (mY > lineBox.bottom || !hasHandler(cm, type4)) {
        return e_defaultPrevented(e);
      }
      mY -= lineBox.top - display.viewOffset;
      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
        var g = display.gutters.childNodes[i2];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight(cm.doc, mY);
          var gutter2 = cm.display.gutterSpecs[i2];
          signal(cm, type4, cm, line, gutter2.className, e);
          return e_defaultPrevented(e);
        }
      }
    }
    function clickInGutter(cm, e) {
      return gutterEvent(cm, e, "gutterClick", true);
    }
    function onContextMenu(cm, e) {
      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
        return;
      }
      if (signalDOMEvent(cm, e, "contextmenu")) {
        return;
      }
      if (!captureRightClick) {
        cm.display.input.onContextMenu(e);
      }
    }
    function contextMenuInGutter(cm, e) {
      if (!hasHandler(cm, "gutterContextMenu")) {
        return false;
      }
      return gutterEvent(cm, e, "gutterContextMenu", false);
    }
    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }
    var Init = { toString: function() {
      return "CodeMirror.Init";
    } };
    var defaults2 = {};
    var optionHandlers = {};
    function defineOptions(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      function option2(name, deflt, handle, notOnInit) {
        CodeMirror3.defaults[name] = deflt;
        if (handle) {
          optionHandlers2[name] = notOnInit ? function(cm, val, old) {
            if (old != Init) {
              handle(cm, val, old);
            }
          } : handle;
        }
      }
      CodeMirror3.defineOption = option2;
      CodeMirror3.Init = Init;
      option2("value", "", function(cm, val) {
        return cm.setValue(val);
      }, true);
      option2("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option2("indentUnit", 2, loadMode, true);
      option2("indentWithTabs", false);
      option2("smartIndent", true);
      option2("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option2("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val) {
          return;
        }
        var newBreaks = [], lineNo2 = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1) {
              break;
            }
            pos = found + val.length;
            newBreaks.push(Pos(lineNo2, found));
          }
          lineNo2++;
        });
        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
        }
      });
      option2("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
        if (old != Init) {
          cm.refresh();
        }
      });
      option2("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        return cm.refresh();
      }, true);
      option2("electricChars", true);
      option2("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option2("spellcheck", false, function(cm, val) {
        return cm.getInputField().spellcheck = val;
      }, true);
      option2("autocorrect", false, function(cm, val) {
        return cm.getInputField().autocorrect = val;
      }, true);
      option2("autocapitalize", false, function(cm, val) {
        return cm.getInputField().autocapitalize = val;
      }, true);
      option2("rtlMoveVisually", !windows);
      option2("wholeLineUpdateBefore", true);
      option2("theme", "default", function(cm) {
        themeChanged(cm);
        updateGutters(cm);
      }, true);
      option2("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != Init && getKeyMap(old);
        if (prev && prev.detach) {
          prev.detach(cm, next);
        }
        if (next.attach) {
          next.attach(cm, prev || null);
        }
      });
      option2("extraKeys", null);
      option2("configureMouse", null);
      option2("lineWrapping", false, wrappingChanged, true);
      option2("gutters", [], function(cm, val) {
        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
        updateGutters(cm);
      }, true);
      option2("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option2("coverGutterNextToScrollbar", false, function(cm) {
        return updateScrollbars(cm);
      }, true);
      option2("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option2("lineNumbers", false, function(cm, val) {
        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
        updateGutters(cm);
      }, true);
      option2("firstLineNumber", 1, updateGutters, true);
      option2("lineNumberFormatter", function(integer4) {
        return integer4;
      }, updateGutters, true);
      option2("showCursorWhenSelecting", false, updateSelection, true);
      option2("resetSelectionOnContextMenu", true);
      option2("lineWiseCopyCut", true);
      option2("pasteLinesPerSelection", true);
      option2("selectionsMayTouch", false);
      option2("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option2("screenReaderLabel", null, function(cm, val) {
        val = val === "" ? null : val;
        cm.display.input.screenReaderLabelChanged(val);
      });
      option2("disableInput", false, function(cm, val) {
        if (!val) {
          cm.display.input.reset();
        }
      }, true);
      option2("dragDrop", true, dragDropChanged);
      option2("allowDropFileTypes", null);
      option2("cursorBlinkRate", 530);
      option2("cursorScrollMargin", 0);
      option2("cursorHeight", 1, updateSelection, true);
      option2("singleCursorHeightPerLine", true, updateSelection, true);
      option2("workTime", 100);
      option2("workDelay", 100);
      option2("flattenSpans", true, resetModeState, true);
      option2("addModeClass", false, resetModeState, true);
      option2("pollInterval", 100);
      option2("undoDepth", 200, function(cm, val) {
        return cm.doc.history.undoDepth = val;
      });
      option2("historyEventDelay", 1250);
      option2("viewportMargin", 10, function(cm) {
        return cm.refresh();
      }, true);
      option2("maxHighlightLength", 1e4, resetModeState, true);
      option2("moveInputWithCursor", true, function(cm, val) {
        if (!val) {
          cm.display.input.resetPosition();
        }
      });
      option2("tabindex", null, function(cm, val) {
        return cm.display.input.getField().tabIndex = val || "";
      });
      option2("autofocus", null);
      option2("direction", "ltr", function(cm, val) {
        return cm.doc.setDirection(val);
      }, true);
      option2("phrases", null);
    }
    function dragDropChanged(cm, value, old) {
      var wasOn = old && old != Init;
      if (!value != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value ? on2 : off2;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }
    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass2(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function() {
        return updateScrollbars(cm);
      }, 100);
    }
    function CodeMirror2(place, options2) {
      var this$1$1 = this;
      if (!(this instanceof CodeMirror2)) {
        return new CodeMirror2(place, options2);
      }
      this.options = options2 = options2 ? copyObj(options2) : {};
      copyObj(defaults2, options2, false);
      var doc = options2.value;
      if (typeof doc == "string") {
        doc = new Doc(doc, options2.mode, null, options2.lineSeparator, options2.direction);
      } else if (options2.mode) {
        doc.modeOption = options2.mode;
      }
      this.doc = doc;
      var input = new CodeMirror2.inputStyles[options2.inputStyle](this);
      var display = this.display = new Display(place, doc, input, options2);
      display.wrapper.CodeMirror = this;
      themeChanged(this);
      if (options2.lineWrapping) {
        this.display.wrapper.className += " CodeMirror-wrap";
      }
      initScrollbars(this);
      this.state = {
        keyMaps: [],
        overlays: [],
        modeGen: 0,
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false,
        pasteIncoming: -1,
        cutIncoming: -1,
        selectingText: false,
        draggingText: false,
        highlight: new Delayed(),
        keySeq: null,
        specialChars: null
      };
      if (options2.autofocus && !mobile) {
        display.input.focus();
      }
      if (ie && ie_version < 11) {
        setTimeout(function() {
          return this$1$1.display.input.reset(true);
        }, 20);
      }
      registerEventHandlers(this);
      ensureGlobalHandlers();
      startOperation(this);
      this.curOp.forceUpdate = true;
      attachDoc(this, doc);
      if (options2.autofocus && !mobile || this.hasFocus()) {
        setTimeout(function() {
          if (this$1$1.hasFocus() && !this$1$1.state.focused) {
            onFocus(this$1$1);
          }
        }, 20);
      } else {
        onBlur(this);
      }
      for (var opt in optionHandlers) {
        if (optionHandlers.hasOwnProperty(opt)) {
          optionHandlers[opt](this, options2[opt], Init);
        }
      }
      maybeUpdateLineNumberWidth(this);
      if (options2.finishInit) {
        options2.finishInit(this);
      }
      for (var i2 = 0; i2 < initHooks.length; ++i2) {
        initHooks[i2](this);
      }
      endOperation(this);
      if (webkit && options2.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
        display.lineDiv.style.textRendering = "auto";
      }
    }
    CodeMirror2.defaults = defaults2;
    CodeMirror2.optionHandlers = optionHandlers;
    function registerEventHandlers(cm) {
      var d2 = cm.display;
      on2(d2.scroller, "mousedown", operation(cm, onMouseDown));
      if (ie && ie_version < 11) {
        on2(d2.scroller, "dblclick", operation(cm, function(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e_preventDefault(e);
          var word = cm.findWordAt(pos);
          extendSelection(cm.doc, word.anchor, word.head);
        }));
      } else {
        on2(d2.scroller, "dblclick", function(e) {
          return signalDOMEvent(cm, e) || e_preventDefault(e);
        });
      }
      on2(d2.scroller, "contextmenu", function(e) {
        return onContextMenu(cm, e);
      });
      on2(d2.input.getField(), "contextmenu", function(e) {
        if (!d2.scroller.contains(e.target)) {
          onContextMenu(cm, e);
        }
      });
      var touchFinished, prevTouch = { end: 0 };
      function finishTouch() {
        if (d2.activeTouch) {
          touchFinished = setTimeout(function() {
            return d2.activeTouch = null;
          }, 1e3);
          prevTouch = d2.activeTouch;
          prevTouch.end = +new Date();
        }
      }
      function isMouseLikeTouchEvent(e) {
        if (e.touches.length != 1) {
          return false;
        }
        var touch = e.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1;
      }
      function farAway(touch, other) {
        if (other.left == null) {
          return true;
        }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20;
      }
      on2(d2.scroller, "touchstart", function(e) {
        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
          d2.input.ensurePolled();
          clearTimeout(touchFinished);
          var now2 = +new Date();
          d2.activeTouch = {
            start: now2,
            moved: false,
            prev: now2 - prevTouch.end <= 300 ? prevTouch : null
          };
          if (e.touches.length == 1) {
            d2.activeTouch.left = e.touches[0].pageX;
            d2.activeTouch.top = e.touches[0].pageY;
          }
        }
      });
      on2(d2.scroller, "touchmove", function() {
        if (d2.activeTouch) {
          d2.activeTouch.moved = true;
        }
      });
      on2(d2.scroller, "touchend", function(e) {
        var touch = d2.activeTouch;
        if (touch && !eventInWidget(d2, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
          var pos = cm.coordsChar(d2.activeTouch, "page"), range4;
          if (!touch.prev || farAway(touch, touch.prev)) {
            range4 = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
            range4 = cm.findWordAt(pos);
          } else {
            range4 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          cm.setSelection(range4.anchor, range4.head);
          cm.focus();
          e_preventDefault(e);
        }
        finishTouch();
      });
      on2(d2.scroller, "touchcancel", finishTouch);
      on2(d2.scroller, "scroll", function() {
        if (d2.scroller.clientHeight) {
          updateScrollTop(cm, d2.scroller.scrollTop);
          setScrollLeft(cm, d2.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });
      on2(d2.scroller, "mousewheel", function(e) {
        return onScrollWheel(cm, e);
      });
      on2(d2.scroller, "DOMMouseScroll", function(e) {
        return onScrollWheel(cm, e);
      });
      on2(d2.wrapper, "scroll", function() {
        return d2.wrapper.scrollTop = d2.wrapper.scrollLeft = 0;
      });
      d2.dragFunctions = {
        enter: function(e) {
          if (!signalDOMEvent(cm, e)) {
            e_stop(e);
          }
        },
        over: function(e) {
          if (!signalDOMEvent(cm, e)) {
            onDragOver(cm, e);
            e_stop(e);
          }
        },
        start: function(e) {
          return onDragStart(cm, e);
        },
        drop: operation(cm, onDrop),
        leave: function(e) {
          if (!signalDOMEvent(cm, e)) {
            clearDragCursor(cm);
          }
        }
      };
      var inp = d2.input.getField();
      on2(inp, "keyup", function(e) {
        return onKeyUp.call(cm, e);
      });
      on2(inp, "keydown", operation(cm, onKeyDown));
      on2(inp, "keypress", operation(cm, onKeyPress));
      on2(inp, "focus", function(e) {
        return onFocus(cm, e);
      });
      on2(inp, "blur", function(e) {
        return onBlur(cm, e);
      });
    }
    var initHooks = [];
    CodeMirror2.defineInitHook = function(f2) {
      return initHooks.push(f2);
    };
    function indentLine(cm, n, how, aggressive) {
      var doc = cm.doc, state;
      if (how == null) {
        how = "add";
      }
      if (how == "smart") {
        if (!doc.mode.indent) {
          how = "prev";
        } else {
          state = getContextBefore(cm, n).state;
        }
      }
      var tabSize = cm.options.tabSize;
      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) {
            return;
          }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n > doc.first) {
          indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
        } else {
          indentation = 0;
        }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);
      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs) {
        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
          pos += tabSize;
          indentString += "	";
        }
      }
      if (pos < indentation) {
        indentString += spaceStr(indentation - pos);
      }
      if (indentString != curSpaceString) {
        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
        line.stateAfter = null;
        return true;
      } else {
        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
          var range4 = doc.sel.ranges[i$12];
          if (range4.head.line == n && range4.head.ch < curSpaceString.length) {
            var pos$1 = Pos(n, curSpaceString.length);
            replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));
            break;
          }
        }
      }
    }
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
      lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
      var doc = cm.doc;
      cm.display.shift = false;
      if (!sel) {
        sel = doc.sel;
      }
      var recent = +new Date() - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto(inserted), multiPaste = null;
      if (paste && sel.ranges.length > 1) {
        if (lastCopied && lastCopied.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied.text.length == 0) {
            multiPaste = [];
            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
              multiPaste.push(doc.splitLines(lastCopied.text[i2]));
            }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map(textLines, function(l2) {
            return [l2];
          });
        }
      }
      var updateInput = cm.curOp.updateInput;
      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
        var range4 = sel.ranges[i$12];
        var from = range4.from(), to = range4.to();
        if (range4.empty()) {
          if (deleted && deleted > 0) {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
            from = to = Pos(from.line, 0);
          }
        }
        var changeEvent = {
          from,
          to,
          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
        };
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste) {
        triggerElectric(cm, inserted);
      }
      ensureCursorVisible(cm);
      if (cm.curOp.updateInput < 2) {
        cm.curOp.updateInput = updateInput;
      }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste(e, cm) {
      var pasted = e.clipboardData && e.clipboardData.getData("Text");
      if (pasted) {
        e.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput) {
          runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
          });
        }
        return true;
      }
    }
    function triggerElectric(cm, inserted) {
      if (!cm.options.electricChars || !cm.options.smartIndent) {
        return;
      }
      var sel = cm.doc.sel;
      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
        var range4 = sel.ranges[i2];
        if (range4.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range4.head.line) {
          continue;
        }
        var mode = cm.getModeAt(range4.head);
        var indented = false;
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++) {
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indented = indentLine(cm, range4.head.line, "smart");
              break;
            }
          }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine(cm.doc, range4.head.line).text.slice(0, range4.head.ch))) {
            indented = indentLine(cm, range4.head.line, "smart");
          }
        }
        if (indented) {
          signalLater(cm, "electricInput", cm, range4.head.line);
        }
      }
    }
    function copyableRanges(cm) {
      var text = [], ranges = [];
      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
        var line = cm.doc.sel.ranges[i2].head.line;
        var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
        ranges.push(lineRange);
        text.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return { text, ranges };
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea2() {
      var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
      var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      if (webkit) {
        te.style.width = "1000px";
      } else {
        te.setAttribute("wrap", "off");
      }
      if (ios) {
        te.style.border = "1px solid black";
      }
      disableBrowserMagic(te);
      return div;
    }
    function addEditorMethods(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      var helpers = CodeMirror3.helpers = {};
      CodeMirror3.prototype = {
        constructor: CodeMirror3,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option2, value) {
          var options2 = this.options, old = options2[option2];
          if (options2[option2] == value && option2 != "mode") {
            return;
          }
          options2[option2] = value;
          if (optionHandlers2.hasOwnProperty(option2)) {
            operation(this, optionHandlers2[option2])(this, value, old);
          }
          signal(this, "optionChange", this, option2);
        },
        getOption: function(option2) {
          return this.options[option2];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map2, bottom2) {
          this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map2));
        },
        removeKeyMap: function(map2) {
          var maps = this.state.keyMaps;
          for (var i2 = 0; i2 < maps.length; ++i2) {
            if (maps[i2] == map2 || maps[i2].name == map2) {
              maps.splice(i2, 1);
              return true;
            }
          }
        },
        addOverlay: methodOp(function(spec, options2) {
          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
          if (mode.startState) {
            throw new Error("Overlays may not be stateful.");
          }
          insertSorted(this.state.overlays, {
            mode,
            modeSpec: spec,
            opaque: options2 && options2.opaque,
            priority: options2 && options2.priority || 0
          }, function(overlay) {
            return overlay.priority;
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i2 = 0; i2 < overlays.length; ++i2) {
            var cur = overlays[i2].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i2, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) {
              dir = this.options.smartIndent ? "smart" : "prev";
            } else {
              dir = dir ? "add" : "subtract";
            }
          }
          if (isLine(this.doc, n)) {
            indentLine(this, n, dir, aggressive);
          }
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges, end2 = -1;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var range4 = ranges[i2];
            if (!range4.empty()) {
              var from = range4.from(), to = range4.to();
              var start2 = Math.max(end2, from.line);
              end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start2; j < end2; ++j) {
                indentLine(this, j, how);
              }
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
              }
            } else if (range4.head.line > end2) {
              indentLine(this, range4.head.line, how, true);
              end2 = range4.head.line;
              if (i2 == this.doc.sel.primIndex) {
                ensureCursorVisible(this);
              }
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
          var type4;
          if (ch == 0) {
            type4 = styles[2];
          } else {
            for (; ; ) {
              var mid = before + after >> 1;
              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                after = mid;
              } else if (styles[mid * 2 + 1] < ch) {
                before = mid + 1;
              } else {
                type4 = styles[mid * 2 + 2];
                break;
              }
            }
          }
          var cut = type4 ? type4.indexOf("overlay ") : -1;
          return cut < 0 ? type4 : cut == 0 ? null : type4.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) {
            return mode;
          }
          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type4) {
          return this.getHelpers(pos, type4)[0];
        },
        getHelpers: function(pos, type4) {
          var found = [];
          if (!helpers.hasOwnProperty(type4)) {
            return found;
          }
          var help = helpers[type4], mode = this.getModeAt(pos);
          if (typeof mode[type4] == "string") {
            if (help[mode[type4]]) {
              found.push(help[mode[type4]]);
            }
          } else if (mode[type4]) {
            for (var i2 = 0; i2 < mode[type4].length; i2++) {
              var val = help[mode[type4][i2]];
              if (val) {
                found.push(val);
              }
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i$12 = 0; i$12 < help._global.length; i$12++) {
            var cur = help._global[i$12];
            if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
              found.push(cur.val);
            }
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getContextBefore(this, line + 1, precise).state;
        },
        cursorCoords: function(start2, mode) {
          var pos, range4 = this.doc.sel.primary();
          if (start2 == null) {
            pos = range4.head;
          } else if (typeof start2 == "object") {
            pos = clipPos(this.doc, start2);
          } else {
            pos = start2 ? range4.from() : range4.to();
          }
          return cursorCoords(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height2, mode) {
          height2 = fromCoordSystem(this, { top: height2, left: 0 }, mode || "page").top;
          return lineAtHeight(this.doc, height2 + this.display.viewOffset);
        },
        heightAtLine: function(line, mode, includeWidgets) {
          var end2 = false, lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first) {
              line = this.doc.first;
            } else if (line > last) {
              line = last;
              end2 = true;
            }
            lineObj = getLine(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        getViewport: function() {
          return { from: this.display.viewFrom, to: this.display.viewTo };
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top2 = pos.bottom, left2 = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top2 = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
              top2 = pos.top - node.offsetHeight;
            } else if (pos.bottom + node.offsetHeight <= vspace) {
              top2 = pos.bottom;
            }
            if (left2 + node.offsetWidth > hspace) {
              left2 = hspace - node.offsetWidth;
            }
          }
          node.style.top = top2 + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left2 = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") {
              left2 = 0;
            } else if (horiz == "middle") {
              left2 = (display.sizer.clientWidth - node.offsetWidth) / 2;
            }
            node.style.left = left2 + "px";
          }
          if (scroll) {
            scrollIntoView2(this, { left: left2, top: top2, right: left2 + node.offsetWidth, bottom: top2 + node.offsetHeight });
          }
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        triggerOnMouseDown: methodOp(onMouseDown),
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd)) {
            return commands[cmd].call(null, this);
          }
        },
        triggerElectric: methodOp(function(text) {
          triggerElectric(this, text);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var this$1$1 = this;
          this.extendSelectionsBy(function(range4) {
            if (this$1$1.display.shift || this$1$1.doc.extend || range4.empty()) {
              return findPosH(this$1$1.doc, range4.head, dir, unit, this$1$1.options.rtlMoveVisually);
            } else {
              return dir < 0 ? range4.from() : range4.to();
            }
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel, doc = this.doc;
          if (sel.somethingSelected()) {
            doc.replaceSelection("", null, "+delete");
          } else {
            deleteNearSelection(this, function(range4) {
              var other = findPosH(doc, range4.head, dir, unit, false);
              return dir < 0 ? { from: other, to: range4.head } : { from: range4.head, to: other };
            });
          }
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1, x2 = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            var coords = cursorCoords(this, cur, "div");
            if (x2 == null) {
              x2 = coords.left;
            } else {
              coords.left = x2;
            }
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var this$1$1 = this;
          var doc = this.doc, goals = [];
          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range4) {
            if (collapse) {
              return dir < 0 ? range4.from() : range4.to();
            }
            var headPos = cursorCoords(this$1$1, range4.head, "div");
            if (range4.goalColumn != null) {
              headPos.left = range4.goalColumn;
            }
            goals.push(headPos.left);
            var pos = findPosV(this$1$1, headPos, dir, unit);
            if (unit == "page" && range4 == doc.sel.primary()) {
              addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
            }
            return pos;
          }, sel_move);
          if (goals.length) {
            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
              doc.sel.ranges[i2].goalColumn = goals[i2];
            }
          }
        }),
        findWordAt: function(pos) {
          var doc = this.doc, line = getLine(doc, pos.line).text;
          var start2 = pos.ch, end2 = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end2 == line.length) && start2) {
              --start2;
            } else {
              ++end2;
            }
            var startChar = line.charAt(start2);
            var check = isWordChar(startChar, helper) ? function(ch) {
              return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start2 > 0 && check(line.charAt(start2 - 1))) {
              --start2;
            }
            while (end2 < line.length && check(line.charAt(end2))) {
              ++end2;
            }
          }
          return new Range(Pos(pos.line, start2), Pos(pos.line, end2));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite) {
            return;
          }
          if (this.state.overwrite = !this.state.overwrite) {
            addClass2(this.display.cursorDiv, "CodeMirror-overwrite");
          } else {
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          }
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp(function(x2, y) {
          scrollToCoords(this, x2, y);
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range4, margin) {
          if (range4 == null) {
            range4 = { from: this.doc.sel.primary().head, to: null };
            if (margin == null) {
              margin = this.options.cursorScrollMargin;
            }
          } else if (typeof range4 == "number") {
            range4 = { from: Pos(range4, 0), to: null };
          } else if (range4.from == null) {
            range4 = { from: range4, to: null };
          }
          if (!range4.to) {
            range4.to = range4.from;
          }
          range4.margin = margin || 0;
          if (range4.from.line != null) {
            scrollToRange(this, range4);
          } else {
            scrollToCoordsRange(this, range4.from, range4.to, range4.margin);
          }
        }),
        setSize: methodOp(function(width2, height2) {
          var this$1$1 = this;
          var interpret = function(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          };
          if (width2 != null) {
            this.display.wrapper.style.width = interpret(width2);
          }
          if (height2 != null) {
            this.display.wrapper.style.height = interpret(height2);
          }
          if (this.options.lineWrapping) {
            clearLineMeasurementCache(this);
          }
          var lineNo2 = this.display.viewFrom;
          this.doc.iter(lineNo2, this.display.viewTo, function(line) {
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].noHScroll) {
                  regLineChange(this$1$1, lineNo2, "widget");
                  break;
                }
              }
            }
            ++lineNo2;
          });
          this.curOp.forceUpdate = true;
          signal(this, "refresh", this);
        }),
        operation: function(f2) {
          return runInOp(this, f2);
        },
        startOperation: function() {
          return startOperation(this);
        },
        endOperation: function() {
          return endOperation(this);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
            estimateLineHeights(this);
          }
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          if (this.state.selectingText) {
            this.state.selectingText();
          }
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror3);
      CodeMirror3.registerHelper = function(type4, name, value) {
        if (!helpers.hasOwnProperty(type4)) {
          helpers[type4] = CodeMirror3[type4] = { _global: [] };
        }
        helpers[type4][name] = value;
      };
      CodeMirror3.registerGlobalHelper = function(type4, name, predicate, value) {
        CodeMirror3.registerHelper(type4, name, value);
        helpers[type4]._global.push({ pred: predicate, val: value });
      };
    }
    function findPosH(doc, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine(doc, pos.line);
      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
      function findNextLine() {
        var l2 = pos.line + lineDir;
        if (l2 < doc.first || l2 >= doc.first + doc.size) {
          return false;
        }
        pos = new Pos(l2, pos.ch, pos.sticky);
        return lineObj = getLine(doc, l2);
      }
      function moveOnce(boundToLine) {
        var next;
        if (unit == "codepoint") {
          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
          if (isNaN(ch)) {
            next = null;
          } else {
            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
          }
        } else if (visually) {
          next = moveVisually(doc.cm, lineObj, pos, dir);
        } else {
          next = moveLogically(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
          } else {
            return false;
          }
        } else {
          pos = next;
        }
        return true;
      }
      if (unit == "char" || unit == "codepoint") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true; ; first = false) {
          if (dir < 0 && !moveOnce(!first)) {
            break;
          }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type4 = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
          if (group && !first && !type4) {
            type4 = "s";
          }
          if (sawType && sawType != type4) {
            if (dir < 0) {
              dir = 1;
              moveOnce();
              pos.sticky = "after";
            }
            break;
          }
          if (type4) {
            sawType = type4;
          }
          if (dir > 0 && !moveOnce(!first)) {
            break;
          }
        }
      }
      var result = skipAtomic(doc, pos, oldPos, origDir, true);
      if (equalCursorPos(oldPos, result)) {
        result.hitSide = true;
      }
      return result;
    }
    function findPosV(cm, pos, dir, unit) {
      var doc = cm.doc, x2 = pos.left, y;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
      } else if (unit == "line") {
        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target;
      for (; ; ) {
        target = coordsChar(cm, x2, y);
        if (!target.outside) {
          break;
        }
        if (dir < 0 ? y <= 0 : y >= doc.height) {
          target.hitSide = true;
          break;
        }
        y += dir * 5;
      }
      return target;
    }
    var ContentEditableInput = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      div.contentEditable = true;
      disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      function belongsToInput(e) {
        for (var t = e.target; t; t = t.parentNode) {
          if (t == div) {
            return true;
          }
          if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
            break;
          }
        }
        return false;
      }
      on2(div, "paste", function(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }
        if (ie_version <= 11) {
          setTimeout(operation(cm, function() {
            return this$1$1.updateFromDOM();
          }), 20);
        }
      });
      on2(div, "compositionstart", function(e) {
        this$1$1.composing = { data: e.data, done: false };
      });
      on2(div, "compositionupdate", function(e) {
        if (!this$1$1.composing) {
          this$1$1.composing = { data: e.data, done: false };
        }
      });
      on2(div, "compositionend", function(e) {
        if (this$1$1.composing) {
          if (e.data != this$1$1.composing.data) {
            this$1$1.readFromDOMSoon();
          }
          this$1$1.composing.done = true;
        }
      });
      on2(div, "touchstart", function() {
        return input.forceCompositionEnd();
      });
      on2(div, "input", function() {
        if (!this$1$1.composing) {
          this$1$1.readFromDOMSoon();
        }
      });
      function onCopyCut(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
          if (e.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        }
        var kludge = hiddenTextarea2(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = activeElt();
        selectInput(te);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) {
            input.showPrimarySelection();
          }
        }, 50);
      }
      on2(div, "copy", onCopyCut);
      on2(div, "cut", onCopyCut);
    };
    ContentEditableInput.prototype.screenReaderLabelChanged = function(label2) {
      if (label2) {
        this.div.setAttribute("aria-label", label2);
      } else {
        this.div.removeAttribute("aria-label");
      }
    };
    ContentEditableInput.prototype.prepareSelection = function() {
      var result = prepareSelection(this.cm, false);
      result.focus = activeElt() == this.div;
      return result;
    };
    ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) {
        return;
      }
      if (info.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info);
    };
    ContentEditableInput.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput.prototype.showPrimarySelection = function() {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from = prim.from(), to = prim.to();
      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }
      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
        return;
      }
      var view = cm.display.view;
      var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
      var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
      if (!end2) {
        var measure = view[view.length - 1].measure;
        var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end2 = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
      }
      if (!start2 || !end2) {
        sel.removeAllRanges();
        return;
      }
      var old = sel.rangeCount && sel.getRangeAt(0), rng;
      try {
        rng = range3(start2.node, start2.offset, end2.offset, end2.node);
      } catch (e) {
      }
      if (rng) {
        if (!gecko && cm.state.focused) {
          sel.collapse(start2.node, start2.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    };
    ContentEditableInput.prototype.startGracePeriod = function() {
      var this$1$1 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        this$1$1.gracePeriod = false;
        if (this$1$1.selectionChanged()) {
          this$1$1.cm.operation(function() {
            return this$1$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    };
    ContentEditableInput.prototype.showMultipleSelections = function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    };
    ContentEditableInput.prototype.rememberSelection = function() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput.prototype.selectionInEditor = function() {
      var sel = this.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains2(this.div, node);
    };
    ContentEditableInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor() || activeElt() != this.div) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    };
    ContentEditableInput.prototype.blur = function() {
      this.div.blur();
    };
    ContentEditableInput.prototype.getField = function() {
      return this.div;
    };
    ContentEditableInput.prototype.supportsTouch = function() {
      return true;
    };
    ContentEditableInput.prototype.receivedFocus = function() {
      var this$1$1 = this;
      var input = this;
      if (this.selectionInEditor()) {
        setTimeout(function() {
          return this$1$1.pollSelection();
        }, 20);
      } else {
        runInOp(this.cm, function() {
          return input.cm.curOp.selectionChanged = true;
        });
      }
      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput.prototype.selectionChanged = function() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput.prototype.pollSelection = function() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
        return;
      }
      var sel = this.getSelection(), cm = this.cm;
      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
        this.blur();
        this.focus();
        return;
      }
      if (this.composing) {
        return;
      }
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) {
        runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) {
            cm.curOp.selectionChanged = true;
          }
        });
      }
    };
    ContentEditableInput.prototype.pollContent = function() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) {
        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
      }
      if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
        to = Pos(to.line + 1, 0);
      }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
        return false;
      }
      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }
      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else {
          break;
        }
      }
      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }
      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    };
    ContentEditableInput.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function() {
      if (!this.composing) {
        return;
      }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function() {
      var this$1$1 = this;
      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function() {
        this$1$1.readDOMTimeout = null;
        if (this$1$1.composing) {
          if (this$1$1.composing.done) {
            this$1$1.composing = null;
          } else {
            return;
          }
        }
        this$1$1.updateFromDOM();
      }, 80);
    };
    ContentEditableInput.prototype.updateFromDOM = function() {
      var this$1$1 = this;
      if (this.cm.isReadOnly() || !this.pollContent()) {
        runInOp(this.cm, function() {
          return regChange(this$1$1.cm);
        });
      }
    };
    ContentEditableInput.prototype.setUneditable = function(node) {
      node.contentEditable = "false";
    };
    ContentEditableInput.prototype.onKeyPress = function(e) {
      if (e.charCode == 0 || this.composing) {
        return;
      }
      e.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
      }
    };
    ContentEditableInput.prototype.readOnlyChanged = function(val) {
      this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput.prototype.onContextMenu = function() {
    };
    ContentEditableInput.prototype.resetPosition = function() {
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
      var view = findViewForLine(cm, pos.line);
      if (!view || view.hidden) {
        return null;
      }
      var line = getLine(cm.doc, pos.line);
      var info = mapFromLineView(view, line, pos.line);
      var order2 = getOrder(line, cm.doc.direction), side = "left";
      if (order2) {
        var partPos = getBidiPartAt(order2, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
      result.offset = result.collapse == "right" ? result.end : result.start;
      return result;
    }
    function isInGutter(node) {
      for (var scan = node; scan; scan = scan.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
          return true;
        }
      }
      return false;
    }
    function badPos(pos, bad) {
      if (bad) {
        pos.bad = true;
      }
      return pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
      var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id2) {
        return function(marker) {
          return marker.id == id2;
        };
      }
      function close2() {
        if (closing) {
          text += lineSep;
          if (extraLinebreak) {
            text += lineSep;
          }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close2();
          text += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return;
          }
          var markerID = node.getAttribute("cm-marker"), range4;
          if (markerID) {
            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range4 = found[0].find(0))) {
              addText(getBetween(cm.doc, range4.from, range4.to).join(lineSep));
            }
            return;
          }
          if (node.getAttribute("contenteditable") == "false") {
            return;
          }
          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
            return;
          }
          if (isBlock) {
            close2();
          }
          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
            walk(node.childNodes[i2]);
          }
          if (/^(pre|p)$/i.test(node.nodeName)) {
            extraLinebreak = true;
          }
          if (isBlock) {
            closing = true;
          }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (; ; ) {
        walk(from);
        if (from == to) {
          break;
        }
        from = from.nextSibling;
        extraLinebreak = false;
      }
      return text;
    }
    function domToPos(cm, node, offset2) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset2];
        if (!lineNode) {
          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
        }
        node = null;
        offset2 = 0;
      } else {
        for (lineNode = node; ; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) {
            return null;
          }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
            break;
          }
        }
      }
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        var lineView = cm.display.view[i2];
        if (lineView.node == lineNode) {
          return locateNodeInLineView(lineView, node, offset2);
        }
      }
    }
    function locateNodeInLineView(lineView, node, offset2) {
      var wrapper = lineView.text.firstChild, bad = false;
      if (!node || !contains2(wrapper, node)) {
        return badPos(Pos(lineNo(lineView.line), 0), true);
      }
      if (node == wrapper) {
        bad = true;
        node = wrapper.childNodes[offset2];
        offset2 = 0;
        if (!node) {
          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
          return badPos(Pos(lineNo(line), line.text.length), bad);
        }
      }
      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset2) {
          offset2 = textNode.nodeValue.length;
        }
      }
      while (topNode.parentNode != wrapper) {
        topNode = topNode.parentNode;
      }
      var measure = lineView.measure, maps = measure.maps;
      function find2(textNode2, topNode2, offset3) {
        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
          var map2 = i2 < 0 ? measure.map : maps[i2];
          for (var j = 0; j < map2.length; j += 3) {
            var curNode = map2[j + 2];
            if (curNode == textNode2 || curNode == topNode2) {
              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
              var ch = map2[j] + offset3;
              if (offset3 < 0 || curNode != textNode2) {
                ch = map2[j + (offset3 ? 1 : 0)];
              }
              return Pos(line2, ch);
            }
          }
        }
      }
      var found = find2(textNode, topNode, offset2);
      if (found) {
        return badPos(found, bad);
      }
      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
        found = find2(after, after.firstChild, 0);
        if (found) {
          return badPos(Pos(found.line, found.ch - dist), bad);
        } else {
          dist += after.textContent.length;
        }
      }
      for (var before = topNode.previousSibling, dist$1 = offset2; before; before = before.previousSibling) {
        found = find2(before, before.firstChild, -1);
        if (found) {
          return badPos(Pos(found.line, found.ch + dist$1), bad);
        } else {
          dist$1 += before.textContent.length;
        }
      }
    }
    var TextareaInput = function(cm) {
      this.cm = cm;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Delayed();
      this.hasSelection = false;
      this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = this.cm;
      this.createField(display);
      var te = this.textarea;
      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
      if (ios) {
        te.style.width = "0px";
      }
      on2(te, "input", function() {
        if (ie && ie_version >= 9 && this$1$1.hasSelection) {
          this$1$1.hasSelection = null;
        }
        input.poll();
      });
      on2(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }
        cm.state.pasteIncoming = +new Date();
        input.fastPoll();
      });
      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") {
          cm.state.cutIncoming = +new Date();
        }
      }
      on2(te, "cut", prepareCopyCut);
      on2(te, "copy", prepareCopyCut);
      on2(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (!te.dispatchEvent) {
          cm.state.pasteIncoming = +new Date();
          input.focus();
          return;
        }
        var event = new Event("paste");
        event.clipboardData = e.clipboardData;
        te.dispatchEvent(event);
      });
      on2(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) {
          e_preventDefault(e);
        }
      });
      on2(te, "compositionstart", function() {
        var start2 = cm.getCursor("from");
        if (input.composing) {
          input.composing.range.clear();
        }
        input.composing = {
          start: start2,
          range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
        };
      });
      on2(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    };
    TextareaInput.prototype.createField = function(_display) {
      this.wrapper = hiddenTextarea2();
      this.textarea = this.wrapper.firstChild;
    };
    TextareaInput.prototype.screenReaderLabelChanged = function(label2) {
      if (label2) {
        this.textarea.setAttribute("aria-label", label2);
      } else {
        this.textarea.removeAttribute("aria-label");
      }
    };
    TextareaInput.prototype.prepareSelection = function() {
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }
      return result;
    };
    TextareaInput.prototype.showSelection = function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };
    TextareaInput.prototype.reset = function(typing) {
      if (this.contextMenuPending || this.composing) {
        return;
      }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput(this.textarea);
        }
        if (ie && ie_version >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
      }
    };
    TextareaInput.prototype.getField = function() {
      return this.textarea;
    };
    TextareaInput.prototype.supportsTouch = function() {
      return false;
    };
    TextareaInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e) {
        }
      }
    };
    TextareaInput.prototype.blur = function() {
      this.textarea.blur();
    };
    TextareaInput.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    TextareaInput.prototype.slowPoll = function() {
      var this$1$1 = this;
      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function() {
        this$1$1.poll();
        if (this$1$1.cm.state.focused) {
          this$1$1.slowPoll();
        }
      });
    };
    TextareaInput.prototype.fastPoll = function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p2() {
        var changed = input.poll();
        if (!changed && !missed) {
          missed = true;
          input.polling.set(60, p2);
        } else {
          input.pollingFast = false;
          input.slowPoll();
        }
      }
      input.polling.set(20, p2);
    };
    TextareaInput.prototype.poll = function() {
      var this$1$1 = this;
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }
      var text = input.value;
      if (text == prevInput && !cm.somethingSelected()) {
        return false;
      }
      if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }
      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 8203 && !prevInput) {
          prevInput = "\u200B";
        }
        if (first == 8666) {
          this.reset();
          return this.cm.execCommand("undo");
        }
      }
      var same = 0, l2 = Math.min(prevInput.length, text.length);
      while (same < l2 && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
        ++same;
      }
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);
        if (text.length > 1e3 || text.indexOf("\n") > -1) {
          input.value = this$1$1.prevInput = "";
        } else {
          this$1$1.prevInput = text;
        }
        if (this$1$1.composing) {
          this$1$1.composing.range.clear();
          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
        }
      });
      return true;
    };
    TextareaInput.prototype.ensurePolled = function() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    };
    TextareaInput.prototype.onKeyPress = function() {
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    };
    TextareaInput.prototype.onContextMenu = function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      if (input.contextMenuPending) {
        input.contextMenuPending();
      }
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) {
        return;
      }
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1) {
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
      }
      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
      input.wrapper.style.cssText = "position: static";
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) {
        oldScrollY = window.scrollY;
      }
      display.input.focus();
      if (webkit) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      if (!cm.somethingSelected()) {
        te.value = input.prevInput = " ";
      }
      input.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200B" + (selected ? te.value : "");
          te.value = "\u21DA";
          te.value = extval;
          input.prevInput = selected ? "" : "\u200B";
          te.selectionStart = 1;
          te.selectionEnd = extval.length;
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input.contextMenuPending != rehide) {
          return;
        }
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }
        if (te.selectionStart != null) {
          if (!ie || ie && ie_version < 9) {
            prepareSelectAllHack();
          }
          var i2 = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
              operation(cm, selectAll)(cm);
            } else if (i2++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }
      if (ie && ie_version >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off2(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on2(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };
    TextareaInput.prototype.readOnlyChanged = function(val) {
      if (!val) {
        this.reset();
      }
      this.textarea.disabled = val == "nocursor";
      this.textarea.readOnly = !!val;
    };
    TextareaInput.prototype.setUneditable = function() {
    };
    TextareaInput.prototype.needsContentAttribute = false;
    function fromTextArea(textarea, options2) {
      options2 = options2 ? copyObj(options2) : {};
      options2.value = textarea.value;
      if (!options2.tabindex && textarea.tabIndex) {
        options2.tabindex = textarea.tabIndex;
      }
      if (!options2.placeholder && textarea.placeholder) {
        options2.placeholder = textarea.placeholder;
      }
      if (options2.autofocus == null) {
        var hasFocus = activeElt();
        options2.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }
      function save2() {
        textarea.value = cm.getValue();
      }
      var realSubmit;
      if (textarea.form) {
        on2(textarea.form, "submit", save2);
        if (!options2.leaveSubmitMethodAlone) {
          var form2 = textarea.form;
          realSubmit = form2.submit;
          try {
            var wrappedSubmit = form2.submit = function() {
              save2();
              form2.submit = realSubmit;
              form2.submit();
              form2.submit = wrappedSubmit;
            };
          } catch (e) {
          }
        }
      }
      options2.finishInit = function(cm2) {
        cm2.save = save2;
        cm2.getTextArea = function() {
          return textarea;
        };
        cm2.toTextArea = function() {
          cm2.toTextArea = isNaN;
          save2();
          textarea.parentNode.removeChild(cm2.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off2(textarea.form, "submit", save2);
            if (!options2.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
              textarea.form.submit = realSubmit;
            }
          }
        };
      };
      textarea.style.display = "none";
      var cm = CodeMirror2(function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options2);
      return cm;
    }
    function addLegacyProps(CodeMirror3) {
      CodeMirror3.off = off2;
      CodeMirror3.on = on2;
      CodeMirror3.wheelEventPixels = wheelEventPixels;
      CodeMirror3.Doc = Doc;
      CodeMirror3.splitLines = splitLinesAuto;
      CodeMirror3.countColumn = countColumn;
      CodeMirror3.findColumn = findColumn;
      CodeMirror3.isWordChar = isWordCharBasic;
      CodeMirror3.Pass = Pass;
      CodeMirror3.signal = signal;
      CodeMirror3.Line = Line;
      CodeMirror3.changeEnd = changeEnd;
      CodeMirror3.scrollbarModel = scrollbarModel;
      CodeMirror3.Pos = Pos;
      CodeMirror3.cmpPos = cmp;
      CodeMirror3.modes = modes;
      CodeMirror3.mimeModes = mimeModes;
      CodeMirror3.resolveMode = resolveMode;
      CodeMirror3.getMode = getMode;
      CodeMirror3.modeExtensions = modeExtensions;
      CodeMirror3.extendMode = extendMode;
      CodeMirror3.copyState = copyState;
      CodeMirror3.startState = startState;
      CodeMirror3.innerMode = innerMode;
      CodeMirror3.commands = commands;
      CodeMirror3.keyMap = keyMap;
      CodeMirror3.keyName = keyName;
      CodeMirror3.isModifierKey = isModifierKey;
      CodeMirror3.lookupKey = lookupKey;
      CodeMirror3.normalizeKeyMap = normalizeKeyMap;
      CodeMirror3.StringStream = StringStream;
      CodeMirror3.SharedTextMarker = SharedTextMarker;
      CodeMirror3.TextMarker = TextMarker;
      CodeMirror3.LineWidget = LineWidget;
      CodeMirror3.e_preventDefault = e_preventDefault;
      CodeMirror3.e_stopPropagation = e_stopPropagation;
      CodeMirror3.e_stop = e_stop;
      CodeMirror3.addClass = addClass2;
      CodeMirror3.contains = contains2;
      CodeMirror3.rmClass = rmClass;
      CodeMirror3.keyNames = keyNames;
    }
    defineOptions(CodeMirror2);
    addEditorMethods(CodeMirror2);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop in Doc.prototype) {
      if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
        CodeMirror2.prototype[prop] = function(method4) {
          return function() {
            return method4.apply(this.doc, arguments);
          };
        }(Doc.prototype[prop]);
      }
    }
    eventMixin(Doc);
    CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
    CodeMirror2.defineMode = function(name) {
      if (!CodeMirror2.defaults.mode && name != "null") {
        CodeMirror2.defaults.mode = name;
      }
      defineMode.apply(this, arguments);
    };
    CodeMirror2.defineMIME = defineMIME;
    CodeMirror2.defineMode("null", function() {
      return { token: function(stream) {
        return stream.skipToEnd();
      } };
    });
    CodeMirror2.defineMIME("text/plain", "null");
    CodeMirror2.defineExtension = function(name, func) {
      CodeMirror2.prototype[name] = func;
    };
    CodeMirror2.defineDocExtension = function(name, func) {
      Doc.prototype[name] = func;
    };
    CodeMirror2.fromTextArea = fromTextArea;
    addLegacyProps(CodeMirror2);
    CodeMirror2.version = "5.63.3";
    return CodeMirror2;
  });
})(codemirror$1);
var CodeMirror = codemirror$1.exports;
var codemirror = "";
(function(module, exports) {
  (function(mod) {
    mod(codemirror$1.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineMode("javascript", function(config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var trackScope = parserConfig.trackScope !== false;
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
      var keywords = function() {
        function kw(type5) {
          return { type: type5, style: "keyword" };
        }
        var A2 = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D2 = kw("keyword d");
        var operator = kw("operator"), atom = { type: "atom", style: "atom" };
        return {
          "if": kw("if"),
          "while": A2,
          "with": A2,
          "else": B,
          "do": B,
          "try": B,
          "finally": B,
          "return": D2,
          "break": D2,
          "continue": D2,
          "new": kw("new"),
          "delete": C,
          "void": C,
          "throw": C,
          "debugger": kw("debugger"),
          "var": kw("var"),
          "const": kw("var"),
          "let": kw("var"),
          "function": kw("function"),
          "catch": kw("catch"),
          "for": kw("for"),
          "switch": kw("switch"),
          "case": kw("case"),
          "default": kw("default"),
          "in": operator,
          "typeof": operator,
          "instanceof": operator,
          "true": atom,
          "false": atom,
          "null": atom,
          "undefined": atom,
          "NaN": atom,
          "Infinity": atom,
          "this": kw("this"),
          "class": kw("class"),
          "super": kw("atom"),
          "yield": C,
          "export": kw("export"),
          "import": kw("import"),
          "extends": C,
          "await": C
        };
      }();
      var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
      function readRegexp(stream) {
        var escaped = false, next, inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet)
              return;
            if (next == "[")
              inSet = true;
            else if (inSet && next == "]")
              inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }
      var type4, content;
      function ret(tp, style, cont2) {
        type4 = tp;
        content = cont2;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (expressionAllowed(stream, state, 1)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eat("=");
            return ret("operator", "operator", stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#" && stream.peek() == "!") {
          stream.skipToEnd();
          return ret("meta", "meta");
        } else if (ch == "#" && stream.eatWhile(wordRE)) {
          return ret("variable", "property");
        } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (isOperatorChar.test(ch)) {
          if (ch != ">" || !state.lexical || state.lexical.type != ">") {
            if (stream.eat("=")) {
              if (ch == "!" || ch == "=")
                stream.eat("=");
            } else if (/[<>*+\-|&?]/.test(ch)) {
              stream.eat(ch);
              if (ch == ">")
                stream.eat(ch);
            }
          }
          if (ch == "?" && stream.eat("."))
            return ret(".");
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch)) {
          stream.eatWhile(wordRE);
          var word = stream.current();
          if (state.lastType != ".") {
            if (keywords.propertyIsEnumerable(word)) {
              var kw = keywords[word];
              return ret(kw.type, kw.style, word);
            }
            if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
              return ret("async", "keyword", word);
          }
          return ret("variable", "variable", word);
        }
      }
      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped)
              break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped)
            state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }
      function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ret("comment", "comment");
      }
      function tokenQuasi(stream, state) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }
      var brackets = "([{}])";
      function findFatArrow(stream, state) {
        if (state.fatArrowAt)
          state.fatArrowAt = null;
        var arrow2 = stream.string.indexOf("=>", stream.start);
        if (arrow2 < 0)
          return;
        if (isTS) {
          var m2 = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow2));
          if (m2)
            arrow2 = m2.index;
        }
        var depth = 0, sawSomething = false;
        for (var pos = arrow2 - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;
              break;
            }
            if (--depth == 0) {
              if (ch == "(")
                sawSomething = true;
              break;
            }
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch)) {
            sawSomething = true;
          } else if (/["'\/`]/.test(ch)) {
            for (; ; --pos) {
              if (pos == 0)
                return;
              var next = stream.string.charAt(pos - 1);
              if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                pos--;
                break;
              }
            }
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth)
          state.fatArrowAt = pos;
      }
      var atomicTypes = {
        "atom": true,
        "number": true,
        "variable": true,
        "string": true,
        "regexp": true,
        "this": true,
        "import": true,
        "jsonld-keyword": true
      };
      function JSLexical(indented, column, type5, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type5;
        this.prev = prev;
        this.info = info;
        if (align != null)
          this.align = align;
      }
      function inScope(state, varname) {
        if (!trackScope)
          return false;
        for (var v2 = state.localVars; v2; v2 = v2.next)
          if (v2.name == varname)
            return true;
        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
          for (var v2 = cx2.vars; v2; v2 = v2.next)
            if (v2.name == varname)
              return true;
        }
      }
      function parseJS(state, style, type5, content2, stream) {
        var cc = state.cc;
        cx.state = state;
        cx.stream = stream;
        cx.marked = null, cx.cc = cc;
        cx.style = style;
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;
        while (true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type5, content2)) {
            while (cc.length && cc[cc.length - 1].lex)
              cc.pop()();
            if (cx.marked)
              return cx.marked;
            if (type5 == "variable" && inScope(state, content2))
              return "variable-2";
            return style;
          }
        }
      }
      var cx = { state: null, column: null, marked: null, cc: null };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--)
          cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function inList(name, list) {
        for (var v2 = list; v2; v2 = v2.next)
          if (v2.name == name)
            return true;
        return false;
      }
      function register2(varname) {
        var state = cx.state;
        cx.marked = "def";
        if (!trackScope)
          return;
        if (state.context) {
          if (state.lexical.info == "var" && state.context && state.context.block) {
            var newContext = registerVarScoped(varname, state.context);
            if (newContext != null) {
              state.context = newContext;
              return;
            }
          } else if (!inList(varname, state.localVars)) {
            state.localVars = new Var(varname, state.localVars);
            return;
          }
        }
        if (parserConfig.globalVars && !inList(varname, state.globalVars))
          state.globalVars = new Var(varname, state.globalVars);
      }
      function registerVarScoped(varname, context) {
        if (!context) {
          return null;
        } else if (context.block) {
          var inner = registerVarScoped(varname, context.prev);
          if (!inner)
            return null;
          if (inner == context.prev)
            return context;
          return new Context(inner, context.vars, true);
        } else if (inList(varname, context.vars)) {
          return context;
        } else {
          return new Context(context.prev, new Var(varname, context.vars), false);
        }
      }
      function isModifier(name) {
        return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
      }
      function Context(prev, vars, block2) {
        this.prev = prev;
        this.vars = vars;
        this.block = block2;
      }
      function Var(name, next) {
        this.name = name;
        this.next = next;
      }
      var defaultVars = new Var("this", new Var("arguments", null));
      function pushcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
        cx.state.localVars = defaultVars;
      }
      function pushblockcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
        cx.state.localVars = null;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      popcontext.lex = true;
      function pushlex(type5, info) {
        var result = function() {
          var state = cx.state, indent = state.indented;
          if (state.lexical.type == "stat")
            indent = state.lexical.indented;
          else
            for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
              indent = outer.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type5, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;
      function expect(wanted) {
        function exp(type5) {
          if (type5 == wanted)
            return cont();
          else if (wanted == ";" || type5 == "}" || type5 == ")" || type5 == "]")
            return pass();
          else
            return cont(exp);
        }
        return exp;
      }
      function statement(type5, value) {
        if (type5 == "var")
          return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
        if (type5 == "keyword a")
          return cont(pushlex("form"), parenExpr, statement, poplex);
        if (type5 == "keyword b")
          return cont(pushlex("form"), statement, poplex);
        if (type5 == "keyword d")
          return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
        if (type5 == "debugger")
          return cont(expect(";"));
        if (type5 == "{")
          return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
        if (type5 == ";")
          return cont();
        if (type5 == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
            cx.state.cc.pop()();
          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
        }
        if (type5 == "function")
          return cont(functiondef);
        if (type5 == "for")
          return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
        if (type5 == "class" || isTS && value == "interface") {
          cx.marked = "keyword";
          return cont(pushlex("form", type5 == "class" ? type5 : value), className, poplex);
        }
        if (type5 == "variable") {
          if (isTS && value == "declare") {
            cx.marked = "keyword";
            return cont(statement);
          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
            cx.marked = "keyword";
            if (value == "enum")
              return cont(enumdef);
            else if (value == "type")
              return cont(typename, expect("operator"), typeexpr, expect(";"));
            else
              return cont(pushlex("form"), pattern4, expect("{"), pushlex("}"), block, poplex, poplex);
          } else if (isTS && value == "namespace") {
            cx.marked = "keyword";
            return cont(pushlex("form"), expression, statement, poplex);
          } else if (isTS && value == "abstract") {
            cx.marked = "keyword";
            return cont(statement);
          } else {
            return cont(pushlex("stat"), maybelabel);
          }
        }
        if (type5 == "switch")
          return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
        if (type5 == "case")
          return cont(expression, expect(":"));
        if (type5 == "default")
          return cont(expect(":"));
        if (type5 == "catch")
          return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
        if (type5 == "export")
          return cont(pushlex("stat"), afterExport, poplex);
        if (type5 == "import")
          return cont(pushlex("stat"), afterImport, poplex);
        if (type5 == "async")
          return cont(statement);
        if (value == "@")
          return cont(expression, statement);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function maybeCatchBinding(type5) {
        if (type5 == "(")
          return cont(funarg, expect(")"));
      }
      function expression(type5, value) {
        return expressionInner(type5, value, false);
      }
      function expressionNoComma(type5, value) {
        return expressionInner(type5, value, true);
      }
      function parenExpr(type5) {
        if (type5 != "(")
          return pass();
        return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
      }
      function expressionInner(type5, value, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type5 == "(")
            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
          else if (type5 == "variable")
            return pass(pushcontext, pattern4, expect("=>"), body, popcontext);
        }
        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type5))
          return cont(maybeop);
        if (type5 == "function")
          return cont(functiondef, maybeop);
        if (type5 == "class" || isTS && value == "interface") {
          cx.marked = "keyword";
          return cont(pushlex("form"), classExpression, poplex);
        }
        if (type5 == "keyword c" || type5 == "async")
          return cont(noComma ? expressionNoComma : expression);
        if (type5 == "(")
          return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
        if (type5 == "operator" || type5 == "spread")
          return cont(noComma ? expressionNoComma : expression);
        if (type5 == "[")
          return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type5 == "{")
          return contCommasep(objprop, "}", null, maybeop);
        if (type5 == "quasi")
          return pass(quasi, maybeop);
        if (type5 == "new")
          return cont(maybeTarget(noComma));
        return cont();
      }
      function maybeexpression(type5) {
        if (type5.match(/[;\}\)\],]/))
          return pass();
        return pass(expression);
      }
      function maybeoperatorComma(type5, value) {
        if (type5 == ",")
          return cont(maybeexpression);
        return maybeoperatorNoComma(type5, value, false);
      }
      function maybeoperatorNoComma(type5, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type5 == "=>")
          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type5 == "operator") {
          if (/\+\+|--/.test(value) || isTS && value == "!")
            return cont(me);
          if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
          if (value == "?")
            return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type5 == "quasi") {
          return pass(quasi, me);
        }
        if (type5 == ";")
          return;
        if (type5 == "(")
          return contCommasep(expressionNoComma, ")", "call", me);
        if (type5 == ".")
          return cont(property, me);
        if (type5 == "[")
          return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
        if (isTS && value == "as") {
          cx.marked = "keyword";
          return cont(typeexpr, me);
        }
        if (type5 == "regexp") {
          cx.state.lastType = cx.marked = "operator";
          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
          return cont(expr);
        }
      }
      function quasi(type5, value) {
        if (type5 != "quasi")
          return pass();
        if (value.slice(value.length - 2) != "${")
          return cont(quasi);
        return cont(maybeexpression, continueQuasi);
      }
      function continueQuasi(type5) {
        if (type5 == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type5) {
        findFatArrow(cx.stream, cx.state);
        return pass(type5 == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type5) {
        findFatArrow(cx.stream, cx.state);
        return pass(type5 == "{" ? statement : expressionNoComma);
      }
      function maybeTarget(noComma) {
        return function(type5) {
          if (type5 == ".")
            return cont(noComma ? targetNoComma : target);
          else if (type5 == "variable" && isTS)
            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
          else
            return pass(noComma ? expressionNoComma : expression);
        };
      }
      function target(_2, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorComma);
        }
      }
      function targetNoComma(_2, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorNoComma);
        }
      }
      function maybelabel(type5) {
        if (type5 == ":")
          return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type5) {
        if (type5 == "variable") {
          cx.marked = "property";
          return cont();
        }
      }
      function objprop(type5, value) {
        if (type5 == "async") {
          cx.marked = "property";
          return cont(objprop);
        } else if (type5 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set")
            return cont(getterSetter);
          var m2;
          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m2 = cx.stream.match(/^\s*:\s*/, false)))
            cx.state.fatArrowAt = cx.stream.pos + m2[0].length;
          return cont(afterprop);
        } else if (type5 == "number" || type5 == "string") {
          cx.marked = jsonldMode ? "property" : cx.style + " property";
          return cont(afterprop);
        } else if (type5 == "jsonld-keyword") {
          return cont(afterprop);
        } else if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type5 == "[") {
          return cont(expression, maybetype, expect("]"), afterprop);
        } else if (type5 == "spread") {
          return cont(expressionNoComma, afterprop);
        } else if (value == "*") {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type5 == ":") {
          return pass(afterprop);
        }
      }
      function getterSetter(type5) {
        if (type5 != "variable")
          return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type5) {
        if (type5 == ":")
          return cont(expressionNoComma);
        if (type5 == "(")
          return pass(functiondef);
      }
      function commasep(what, end2, sep) {
        function proceed(type5, value) {
          if (sep ? sep.indexOf(type5) > -1 : type5 == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call")
              lex.pos = (lex.pos || 0) + 1;
            return cont(function(type6, value2) {
              if (type6 == end2 || value2 == end2)
                return pass();
              return pass(what);
            }, proceed);
          }
          if (type5 == end2 || value == end2)
            return cont();
          if (sep && sep.indexOf(";") > -1)
            return pass(what);
          return cont(expect(end2));
        }
        return function(type5, value) {
          if (type5 == end2 || value == end2)
            return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end2, info) {
        for (var i = 3; i < arguments.length; i++)
          cx.cc.push(arguments[i]);
        return cont(pushlex(end2, info), commasep(what, end2), poplex);
      }
      function block(type5) {
        if (type5 == "}")
          return cont();
        return pass(statement, block);
      }
      function maybetype(type5, value) {
        if (isTS) {
          if (type5 == ":")
            return cont(typeexpr);
          if (value == "?")
            return cont(maybetype);
        }
      }
      function maybetypeOrIn(type5, value) {
        if (isTS && (type5 == ":" || value == "in"))
          return cont(typeexpr);
      }
      function mayberettype(type5) {
        if (isTS && type5 == ":") {
          if (cx.stream.match(/^\s*\w+\s+is\b/, false))
            return cont(expression, isKW, typeexpr);
          else
            return cont(typeexpr);
        }
      }
      function isKW(_2, value) {
        if (value == "is") {
          cx.marked = "keyword";
          return cont();
        }
      }
      function typeexpr(type5, value) {
        if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
          cx.marked = "keyword";
          return cont(value == "typeof" ? expressionNoComma : typeexpr);
        }
        if (type5 == "variable" || value == "void") {
          cx.marked = "type";
          return cont(afterType);
        }
        if (value == "|" || value == "&")
          return cont(typeexpr);
        if (type5 == "string" || type5 == "number" || type5 == "atom")
          return cont(afterType);
        if (type5 == "[")
          return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
        if (type5 == "{")
          return cont(pushlex("}"), typeprops, poplex, afterType);
        if (type5 == "(")
          return cont(commasep(typearg, ")"), maybeReturnType, afterType);
        if (type5 == "<")
          return cont(commasep(typeexpr, ">"), typeexpr);
        if (type5 == "quasi") {
          return pass(quasiType, afterType);
        }
      }
      function maybeReturnType(type5) {
        if (type5 == "=>")
          return cont(typeexpr);
      }
      function typeprops(type5) {
        if (type5.match(/[\}\)\]]/))
          return cont();
        if (type5 == "," || type5 == ";")
          return cont(typeprops);
        return pass(typeprop, typeprops);
      }
      function typeprop(type5, value) {
        if (type5 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(typeprop);
        } else if (value == "?" || type5 == "number" || type5 == "string") {
          return cont(typeprop);
        } else if (type5 == ":") {
          return cont(typeexpr);
        } else if (type5 == "[") {
          return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
        } else if (type5 == "(") {
          return pass(functiondecl, typeprop);
        } else if (!type5.match(/[;\}\)\],]/)) {
          return cont();
        }
      }
      function quasiType(type5, value) {
        if (type5 != "quasi")
          return pass();
        if (value.slice(value.length - 2) != "${")
          return cont(quasiType);
        return cont(typeexpr, continueQuasiType);
      }
      function continueQuasiType(type5) {
        if (type5 == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasiType);
        }
      }
      function typearg(type5, value) {
        if (type5 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
          return cont(typearg);
        if (type5 == ":")
          return cont(typeexpr);
        if (type5 == "spread")
          return cont(typearg);
        return pass(typeexpr);
      }
      function afterType(type5, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        if (value == "|" || type5 == "." || value == "&")
          return cont(typeexpr);
        if (type5 == "[")
          return cont(typeexpr, expect("]"), afterType);
        if (value == "extends" || value == "implements") {
          cx.marked = "keyword";
          return cont(typeexpr);
        }
        if (value == "?")
          return cont(typeexpr, expect(":"), typeexpr);
      }
      function maybeTypeArgs(_2, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      }
      function typeparam() {
        return pass(typeexpr, maybeTypeDefault);
      }
      function maybeTypeDefault(_2, value) {
        if (value == "=")
          return cont(typeexpr);
      }
      function vardef(_2, value) {
        if (value == "enum") {
          cx.marked = "keyword";
          return cont(enumdef);
        }
        return pass(pattern4, maybetype, maybeAssign, vardefCont);
      }
      function pattern4(type5, value) {
        if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(pattern4);
        }
        if (type5 == "variable") {
          register2(value);
          return cont();
        }
        if (type5 == "spread")
          return cont(pattern4);
        if (type5 == "[")
          return contCommasep(eltpattern, "]");
        if (type5 == "{")
          return contCommasep(proppattern, "}");
      }
      function proppattern(type5, value) {
        if (type5 == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register2(value);
          return cont(maybeAssign);
        }
        if (type5 == "variable")
          cx.marked = "property";
        if (type5 == "spread")
          return cont(pattern4);
        if (type5 == "}")
          return pass();
        if (type5 == "[")
          return cont(expression, expect("]"), expect(":"), proppattern);
        return cont(expect(":"), pattern4, maybeAssign);
      }
      function eltpattern() {
        return pass(pattern4, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=")
          return cont(expressionNoComma);
      }
      function vardefCont(type5) {
        if (type5 == ",")
          return cont(vardef);
      }
      function maybeelse(type5, value) {
        if (type5 == "keyword b" && value == "else")
          return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type5, value) {
        if (value == "await")
          return cont(forspec);
        if (type5 == "(")
          return cont(pushlex(")"), forspec1, poplex);
      }
      function forspec1(type5) {
        if (type5 == "var")
          return cont(vardef, forspec2);
        if (type5 == "variable")
          return cont(forspec2);
        return pass(forspec2);
      }
      function forspec2(type5, value) {
        if (type5 == ")")
          return cont();
        if (type5 == ";")
          return cont(forspec2);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression, forspec2);
        }
        return pass(expression, forspec2);
      }
      function functiondef(type5, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondef);
        }
        if (type5 == "variable") {
          register2(value);
          return cont(functiondef);
        }
        if (type5 == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
        if (isTS && value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
      }
      function functiondecl(type5, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondecl);
        }
        if (type5 == "variable") {
          register2(value);
          return cont(functiondecl);
        }
        if (type5 == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
        if (isTS && value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
      }
      function typename(type5, value) {
        if (type5 == "keyword" || type5 == "variable") {
          cx.marked = "type";
          return cont(typename);
        } else if (value == "<") {
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
        }
      }
      function funarg(type5, value) {
        if (value == "@")
          cont(expression, funarg);
        if (type5 == "spread")
          return cont(funarg);
        if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(funarg);
        }
        if (isTS && type5 == "this")
          return cont(maybetype, maybeAssign);
        return pass(pattern4, maybetype, maybeAssign);
      }
      function classExpression(type5, value) {
        if (type5 == "variable")
          return className(type5, value);
        return classNameAfter(type5, value);
      }
      function className(type5, value) {
        if (type5 == "variable") {
          register2(value);
          return cont(classNameAfter);
        }
      }
      function classNameAfter(type5, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
        if (value == "extends" || value == "implements" || isTS && type5 == ",") {
          if (value == "implements")
            cx.marked = "keyword";
          return cont(isTS ? typeexpr : expression, classNameAfter);
        }
        if (type5 == "{")
          return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type5, value) {
        if (type5 == "async" || type5 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type5 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(classfield, classBody);
        }
        if (type5 == "number" || type5 == "string")
          return cont(classfield, classBody);
        if (type5 == "[")
          return cont(expression, maybetype, expect("]"), classfield, classBody);
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (isTS && type5 == "(")
          return pass(functiondecl, classBody);
        if (type5 == ";" || type5 == ",")
          return cont(classBody);
        if (type5 == "}")
          return cont();
        if (value == "@")
          return cont(expression, classBody);
      }
      function classfield(type5, value) {
        if (value == "!")
          return cont(classfield);
        if (value == "?")
          return cont(classfield);
        if (type5 == ":")
          return cont(typeexpr, maybeAssign);
        if (value == "=")
          return cont(expressionNoComma);
        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
        return pass(isInterface ? functiondecl : functiondef);
      }
      function afterExport(type5, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(maybeFrom, expect(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";
          return cont(expression, expect(";"));
        }
        if (type5 == "{")
          return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
        return pass(statement);
      }
      function exportField(type5, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(expect("variable"));
        }
        if (type5 == "variable")
          return pass(expressionNoComma, exportField);
      }
      function afterImport(type5) {
        if (type5 == "string")
          return cont();
        if (type5 == "(")
          return pass(expression);
        if (type5 == ".")
          return pass(maybeoperatorComma);
        return pass(importSpec, maybeMoreImports, maybeFrom);
      }
      function importSpec(type5, value) {
        if (type5 == "{")
          return contCommasep(importSpec, "}");
        if (type5 == "variable")
          register2(value);
        if (value == "*")
          cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeMoreImports(type5) {
        if (type5 == ",")
          return cont(importSpec, maybeMoreImports);
      }
      function maybeAs(_type, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(importSpec);
        }
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";
          return cont(expression);
        }
      }
      function arrayLiteral(type5) {
        if (type5 == "]")
          return cont();
        return pass(commasep(expressionNoComma, "]"));
      }
      function enumdef() {
        return pass(pushlex("form"), pattern4, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
      }
      function enummember() {
        return pass(pattern4, maybeAssign);
      }
      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
      }
      function expressionAllowed(stream, state, backUp) {
        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
      }
      return {
        startState: function(basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && new Context(null, null, false),
            indented: basecolumn || 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },
        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace())
            return null;
          var style = state.tokenize(stream, state);
          if (type4 == "comment")
            return style;
          state.lastType = type4 == "operator" && (content == "++" || content == "--") ? "incdec" : type4;
          return parseJS(state, style, type4, content, stream);
        },
        indent: function(state, textAfter) {
          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
            return CodeMirror2.Pass;
          if (state.tokenize != tokenBase)
            return 0;
          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;
          if (!/^\s*else\b/.test(textAfter))
            for (var i = state.cc.length - 1; i >= 0; --i) {
              var c2 = state.cc[i];
              if (c2 == poplex)
                lexical = lexical.prev;
              else if (c2 != maybeelse && c2 != popcontext)
                break;
            }
          while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
            lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
            lexical = lexical.prev;
          var type5 = lexical.type, closing = firstChar == type5;
          if (type5 == "vardef")
            return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
          else if (type5 == "form" && firstChar == "{")
            return lexical.indented;
          else if (type5 == "form")
            return lexical.indented + indentUnit;
          else if (type5 == "stat")
            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align)
            return lexical.column + (closing ? 0 : 1);
          else
            return lexical.indented + (closing ? 0 : indentUnit);
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        blockCommentContinue: jsonMode ? null : " * ",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: jsonMode ? "json" : "javascript",
        jsonldMode,
        jsonMode,
        expressionAllowed,
        skipExpression: function(state) {
          parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
        }
      };
    });
    CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
    CodeMirror2.defineMIME("text/javascript", "javascript");
    CodeMirror2.defineMIME("text/ecmascript", "javascript");
    CodeMirror2.defineMIME("application/javascript", "javascript");
    CodeMirror2.defineMIME("application/x-javascript", "javascript");
    CodeMirror2.defineMIME("application/ecmascript", "javascript");
    CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
    CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
  });
})();
var index_vue_vue_type_style_index_0_lang = "";
const _sfc_main$1l = {
  name: "code-mirror",
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: function() {
        return {
          mode: "text/javascript",
          tabSize: 2,
          lineNumbers: true,
          lineWrapping: true
        };
      }
    }
  },
  data: function() {
    return {
      skipNextChangeEvent: false
    };
  },
  ready: function() {
    var _this = this;
    this.editor = CodeMirror.fromTextArea(this.$el.querySelector("textarea"), this.options);
    this.editor.setValue(this.modelValue);
    this.editor.on("change", function(cm) {
      if (_this.skipNextChangeEvent) {
        _this.skipNextChangeEvent = false;
        return;
      }
      _this.modelValue = cm.getValue();
      if (!!_this.$emit) {
        _this.$emit("update:modelValue", cm.getValue());
      }
    });
  },
  mounted: function() {
    var _this = this;
    this.editor = CodeMirror.fromTextArea(this.$el.querySelector("textarea"), this.options);
    this.editor.setValue(this.modelValue);
    this.editor.on("change", function(cm) {
      if (_this.skipNextChangeEvent) {
        _this.skipNextChangeEvent = false;
        return;
      }
      if (!!_this.$emit) {
        _this.$emit("update:modelValue", cm.getValue());
        _this.$emit("input", cm.getValue());
      }
    });
  },
  watch: {
    modelValue: function(newVal, oldVal) {
      var editorValue = this.editor.getValue();
      if (newVal !== editorValue) {
        this.skipNextChangeEvent = true;
        var scrollInfo = this.editor.getScrollInfo();
        this.editor.setValue(newVal);
        this.editor.scrollTo(scrollInfo.left, scrollInfo.top);
      }
    },
    options: function(newOptions, oldVal) {
      if (typeof newOptions === "object") {
        for (var optionName in newOptions) {
          if (newOptions.hasOwnProperty(optionName)) {
            this.editor.setOption(optionName, newOptions[optionName]);
          }
        }
      }
    }
  },
  beforeUnmount: function() {
    if (this.editor) {
      this.editor.toTextArea();
    }
  }
};
const _hoisted_1$l = { class: "vue-codemirror-wrap" };
const _hoisted_2$i = /* @__PURE__ */ createElementVNode("textarea", null, null, -1);
const _hoisted_3$f = [
  _hoisted_2$i
];
function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$l, _hoisted_3$f);
}
var __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$1l]]);
const _hoisted_1$k = {
  class: "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  width: "200",
  height: "200"
};
const _hoisted_2$h = /* @__PURE__ */ createElementVNode("path", { d: "M276.096 152a40 40 0 0 1 1.736 79.96l-1.736.04h-37.888c-17.936 0-29.664 4.504-37.616 13.168l-2.16 2.456c-7.896 8.696-12.544 22.928-12.936 43.848l-.024 2.896v149.504c0 25.576-5.368 47.824-16.816 65.584l-1.688 2.52.272.384c11.824 17.152 17.704 39.032 18.192 64.296l.04 3.472v150.24c0 21.32 4.176 35.488 11.888 44.768l2.12 2.432c7.6 9.056 18.856 13.976 36.208 14.4l2.52.032h37.888a40 40 0 0 1 1.736 79.96l-1.736.04h-37.888c-40.088 0-73.952-13.512-97.92-40.592l-1.568-1.816-1.616-1.824c-20.992-24.376-30.984-55.84-31.6-93.6l-.032-3.8v-150.24c0-12.72-2.176-20.144-4.088-22.4-1.096-1.256-9.008-4.032-24.552-5.808l-4.432-.456c-49.304-4.576-47.976-77 1.456-79.768 17.408-.976 26.24-3.944 27.256-5.12 2.056-2.416 4.104-9.12 4.336-20.512l.024-2.192V294.368c0-39.616 9.968-72.944 31.632-98.136l1.672-1.904 1.504-1.736c23.272-26.288 55.856-39.784 94.408-40.56l3.52-.032h37.888zm505.792 0 3.52.032c38.56.776 71.136 14.272 94.4 40.56l1.512 1.736 1.672 1.904c21.656 25.192 31.632 58.52 31.632 98.136v149.504l.024 2.192c.24 11.384 2.28 18.096 4.336 20.512 1.016 1.176 9.84 4.144 27.256 5.12 49.44 2.768 50.76 75.2 1.456 79.76l-4.432.464c-15.544 1.776-23.464 4.56-24.552 5.808-1.92 2.256-4.08 9.68-4.08 22.4v150.24l-.04 3.792c-.616 37.776-10.608 69.232-31.6 93.6l-1.616 1.832-1.56 1.816C855.84 858.488 821.976 872 781.888 872H744l-1.736-.04A40 40 0 0 1 744 792h37.888l2.52-.032c17.352-.424 28.608-5.344 36.208-14.4l2.12-2.432c7.712-9.28 11.888-23.448 11.888-44.768v-150.24l.032-3.472c.496-25.264 6.368-47.144 18.192-64.296l.28-.384-1.688-2.52c-11.448-17.76-16.816-40.008-16.816-65.584V294.368l-.024-2.896c-.392-20.92-5.04-35.152-12.944-43.84l-2.152-2.464c-7.952-8.664-19.68-13.168-37.616-13.168H744l-1.736-.04A40 40 0 0 1 744 152h37.888zM336 624a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm176 0a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm176 0a48 48 0 1 1 0 96 48 48 0 0 1 0-96z" }, null, -1);
const _hoisted_3$e = [
  _hoisted_2$h
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$e);
}
const _sfc_main$1k = {
  components: { ElTooltip, ElDialog, ElButton, ElDivider, CodeMirror: __unplugin_components_0$2, FormRender, JsonIcon: render$1 },
  setup() {
    const formRender = ref(null);
    const previewDialog = ref(false);
    const jsonDialog = reactive({
      title: "",
      isShow: false,
      code: ""
    });
    const resultDialog = reactive({
      title: "",
      isShow: false,
      code: ""
    });
    const state = inject("state");
    const clear = inject("clear");
    const revoke = inject("revoke");
    const forward = inject("forward");
    const init = inject("init");
    const preview = () => {
      previewDialog.value = true;
      nextTick(() => {
        formRender.value && formRender.value.init(deepClone(state.formDesign));
      });
    };
    const submit = (result) => {
      resultDialog.title = "\u83B7\u53D6\u6570\u636E";
      resultDialog.isShow = true;
      nextTick(() => {
        resultDialog.code = JSON.stringify(result, null, "	");
      });
    };
    const editJson = () => {
      jsonDialog.title = "\u67E5\u770BJSON";
      jsonDialog.isShow = true;
      nextTick(() => {
        jsonDialog.code = JSON.stringify(state.formDesign, null, "	");
      });
    };
    const saveJson = () => {
      try {
        init(JSON.parse(jsonDialog.code));
      } catch (e) {
        return ElMessage.error("\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      jsonDialog.isShow = false;
    };
    return {
      previewDialog,
      jsonDialog,
      resultDialog,
      clear: () => clear(),
      revoke,
      forward,
      preview,
      submit,
      editJson,
      saveJson,
      formRender,
      cached: computed(() => state.cached),
      current: computed(() => state.current)
    };
  }
};
const _hoisted_1$j = { class: "form-operator" };
const _hoisted_2$g = { class: "icon" };
const _hoisted_3$d = { class: "json-box" };
const _hoisted_4$a = { class: "dialog-footer" };
const _hoisted_5$6 = /* @__PURE__ */ createTextVNode("\u53D6\u6D88");
const _hoisted_6$4 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
const _hoisted_7$3 = { class: "json-box" };
const _hoisted_8$1 = { class: "dialog-footer" };
const _hoisted_9 = /* @__PURE__ */ createTextVNode("\u5173\u95ED");
function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = ElTooltip;
  const _component_JsonIcon = resolveComponent("JsonIcon");
  const _component_el_divider = ElDivider;
  const _component_form_render = FormRender;
  const _component_el_dialog = ElDialog;
  const _component_code_mirror = __unplugin_components_0$2;
  const _component_el_button = ElButton;
  return openBlock(), createElementBlock("div", _hoisted_1$j, [
    createVNode(_component_el_tooltip, {
      effect: "dark",
      content: "\u9884\u89C8",
      placement: "bottom"
    }, {
      default: withCtx(() => [
        createElementVNode("i", {
          class: "icon el-icon-video-play",
          onClick: _cache[0] || (_cache[0] = (...args) => $setup.preview && $setup.preview(...args))
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_tooltip, {
      effect: "dark",
      content: "\u7F16\u8F91JSON",
      placement: "bottom"
    }, {
      default: withCtx(() => [
        createElementVNode("i", _hoisted_2$g, [
          createVNode(_component_JsonIcon, { onClick: $setup.editJson }, null, 8, ["onClick"])
        ])
      ]),
      _: 1
    }),
    createVNode(_component_el_tooltip, {
      effect: "dark",
      content: "\u6E05\u7A7A",
      placement: "bottom"
    }, {
      default: withCtx(() => [
        createElementVNode("i", {
          class: "icon el-icon-delete",
          onClick: _cache[1] || (_cache[1] = (...args) => $setup.clear && $setup.clear(...args))
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_divider, { direction: "vertical" }),
    createVNode(_component_el_tooltip, {
      effect: "dark",
      content: "\u540E\u9000",
      placement: "bottom"
    }, {
      default: withCtx(() => [
        createElementVNode("i", {
          class: normalizeClass(["icon el-icon-refresh-left", { disabled: $setup.current <= 0 }]),
          onClick: _cache[2] || (_cache[2] = (...args) => $setup.revoke && $setup.revoke(...args))
        }, null, 2)
      ]),
      _: 1
    }),
    createVNode(_component_el_tooltip, {
      effect: "dark",
      content: "\u524D\u8FDB",
      placement: "bottom"
    }, {
      default: withCtx(() => [
        createElementVNode("i", {
          class: normalizeClass(["icon el-icon-refresh-right", { disabled: $setup.current >= $setup.cached.length - 1 }]),
          onClick: _cache[3] || (_cache[3] = (...args) => $setup.forward && $setup.forward(...args))
        }, null, 2)
      ]),
      _: 1
    }),
    createVNode(_component_el_dialog, {
      title: "\u9884\u89C8",
      modelValue: $setup.previewDialog,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.previewDialog = $event),
      "destroy-on-close": "",
      width: "750px"
    }, {
      default: withCtx(() => [
        createVNode(_component_form_render, {
          ref: "formRender",
          onSubmit: $setup.submit
        }, null, 8, ["onSubmit"])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_el_dialog, {
      title: $setup.jsonDialog.title,
      modelValue: $setup.jsonDialog.isShow,
      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $setup.jsonDialog.isShow = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_4$a, [
          createVNode(_component_el_button, {
            onClick: _cache[6] || (_cache[6] = ($event) => $setup.jsonDialog.isShow = false)
          }, {
            default: withCtx(() => [
              _hoisted_5$6
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.saveJson
          }, {
            default: withCtx(() => [
              _hoisted_6$4
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_3$d, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.jsonDialog.code,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $setup.jsonDialog.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["title", "modelValue"]),
    createVNode(_component_el_dialog, {
      title: $setup.resultDialog.title,
      modelValue: $setup.resultDialog.isShow,
      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $setup.resultDialog.isShow = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_8$1, [
          createVNode(_component_el_button, {
            onClick: _cache[9] || (_cache[9] = ($event) => $setup.resultDialog.isShow = false)
          }, {
            default: withCtx(() => [
              _hoisted_9
            ]),
            _: 1
          })
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_7$3, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.resultDialog.code,
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $setup.resultDialog.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["title", "modelValue"])
  ]);
}
var __unplugin_components_1$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1k]]);
var elEmpty = "";
const _sfc_main$1j = {
  name: "objectBuilder",
  components: { draggable: draggableComponent, FormBuilderItem: defineAsyncComponent(() => Promise.resolve().then(function() {
    return index$1;
  })) },
  props: {
    path: String,
    uuid: String,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2) {
    const setSelected = inject("setSelected");
    const updateFormItem = inject("updateFormItem");
    return {
      add: (evt) => setSelected(props2.items[evt.newIndex].uuid),
      dragStart: (evt) => setSelected(props2.items[evt.oldIndex].uuid),
      updateItems: (items) => updateFormItem({ uuid: props2.uuid, items })
    };
  }
};
function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_form_builder_item = __unplugin_components_1;
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createBlock(_component_draggable, mergeProps({
    class: "form-item-drop-list",
    "model-value": $props.items,
    "onUpdate:modelValue": $setup.updateItems,
    onStart: $setup.dragStart,
    onAdd: $setup.add,
    "item-key": "uuid"
  }, { animation: 200, group: "form-draggable", disabled: false, ghostClass: "ghost" }), {
    item: withCtx(({ element }) => [
      createVNode(_component_form_builder_item, {
        component: element.component,
        uuid: element.uuid,
        items: element.items,
        options: element.options,
        path: element.options.key ? $props.path + "." + element.options.key : $props.path,
        style: normalizeStyle({
          "padding-left": $props.options.gutter / 2 + "px",
          "padding-right": $props.options.gutter / 2 + "px"
        })
      }, null, 8, ["component", "uuid", "items", "options", "path", "style"])
    ]),
    _: 1
  }, 16, ["model-value", "onUpdate:modelValue", "onStart", "onAdd"]);
}
var __unplugin_components_1$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1j]]);
var __glob_1_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __unplugin_components_1$1
});
const _sfc_main$1i = {
  name: "cardBuilder",
  components: { ElCard, objectBuilder: __unplugin_components_1$1 },
  props: {
    path: String,
    uuid: String,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
const _hoisted_1$i = { class: "card-header" };
function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_object_builder = __unplugin_components_1$1;
  const _component_el_card = ElCard;
  return openBlock(), createBlock(_component_el_card, {
    shadow: $props.options.shadow,
    "body-style": { padding: $props.options.padding }
  }, {
    header: withCtx(() => [
      createElementVNode("div", _hoisted_1$i, [
        createElementVNode("span", null, toDisplayString($props.options.label), 1)
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_object_builder, {
        uuid: $props.uuid,
        items: $props.items,
        options: $props.options,
        path: $props.path
      }, null, 8, ["uuid", "items", "options", "path"])
    ]),
    _: 1
  }, 8, ["shadow", "body-style"]);
}
var cardBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1i]]);
var __glob_1_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cardBuilder
});
const _sfc_main$1h = {
  name: "cascaderBuilder",
  components: { ElFormItem, ElCascader },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader = ElCascader;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_cascader, {
        key: 0,
        "model-value": $props.options.defaultValue,
        options: $props.options.options.items,
        disabled: $props.options.disabled,
        clearable: $props.options.clearable,
        props: {
          expandTrigger: $props.options.expandTrigger
        }
      }, null, 8, ["model-value", "options", "disabled", "clearable", "props"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var cascadeBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$1h]]);
var __glob_1_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": cascadeBuilder
});
const _sfc_main$1g = {
  name: "checkboxBuilder",
  components: { ElFormItem, ElCheckboxGroup: ElCheckboxGroup$1, ElCheckbox },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  const _component_el_checkbox_group = ElCheckboxGroup$1;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_checkbox_group, {
        key: 0,
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_checkbox, {
              key: item.value,
              label: item.value
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(item.label), 1)
              ]),
              _: 2
            }, 1032, ["label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var checkboxBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1g]]);
var __glob_1_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": checkboxBuilder
});
const _sfc_main$1f = {
  name: "colorPickerBuilder",
  components: { ElFormItem, ElColorPicker },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_color_picker = ElColorPicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_color_picker, {
        key: 0,
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled,
        "show-alpha": $props.options.showAlpha
      }, null, 8, ["model-value", "disabled", "show-alpha"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var colorPickerBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$1f]]);
var __glob_1_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": colorPickerBuilder
});
const _sfc_main$1e = {
  name: "datePickerBuilder",
  components: { ElFormItem, ElDatePicker },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker = ElDatePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_date_picker, {
        key: 0,
        "model-value": $props.options.defaultValue,
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var datePickerBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$1e]]);
var __glob_1_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": datePickerBuilder
});
const _sfc_main$1d = {
  name: "dateRangePickerBuilder",
  components: { ElFormItem, ElDatePicker },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker = ElDatePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_date_picker, {
        key: 0,
        type: "daterange",
        "model-value": $props.options.defaultValue,
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var dateRangePickerBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1d]]);
var __glob_1_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": dateRangePickerBuilder
});
const _sfc_main$1c = {
  name: "editorBuilder",
  components: { ElFormItem, quillEditor: __unplugin_components_0$4 },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_quill_editor = __unplugin_components_0$4;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_quill_editor, {
        key: 0,
        disabled: $props.options.disabled,
        options: { placeholder: $props.options.placeholder, readOnly: true },
        style: normalizeStyle({ height: $props.options.height })
      }, null, 8, ["disabled", "options", "style"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var editorBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1c]]);
var __glob_1_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": editorBuilder
});
const _sfc_main$1b = {
  name: "inputBuilder",
  components: { ElFormItem, ElInput },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_input, {
        key: 0,
        type: "text",
        "model-value": $props.options.defaultValue,
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        "show-password": $props.options.showPassword,
        "prefix-icon": $props.options.prefixIcon,
        "suffix-icon": $props.options.suffixIcon,
        maxlength: $props.options.maxlength,
        "show-word-limit": $props.options.showWordLimit
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "show-password", "prefix-icon", "suffix-icon", "maxlength", "show-word-limit"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var inputBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1b]]);
var __glob_1_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": inputBuilder
});
const _sfc_main$1a = {
  name: "multiSelectBuilder",
  components: { ElFormItem, ElSelect, ElOption },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;
  const _component_el_select = ElSelect;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_select, {
        key: 0,
        "model-value": $props.options.defaultValue,
        multiple: true,
        "collapse-tags": $props.options.collapseTags,
        "multiple-limit": $props.options.multipleLimit,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        filterable: $props.options.filterable,
        placeholder: $props.options.placeholder,
        "no-data-text": $props.options.noDataText,
        "no-match-text": $props.options.noMatchText
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_option, {
              key: item.value,
              label: item.label,
              value: item.value
            }, null, 8, ["label", "value"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "collapse-tags", "multiple-limit", "clearable", "disabled", "filterable", "placeholder", "no-data-text", "no-match-text"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var multiSelectBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$1a]]);
var __glob_1_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": multiSelectBuilder
});
const _sfc_main$19 = {
  name: "numberBuilder",
  components: { ElFormItem, ElInputNumber },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_input_number, {
        key: 0,
        "model-value": $props.options.defaultValue,
        min: $props.options.min,
        max: $props.options.max,
        disabled: $props.options.disabled
      }, null, 8, ["model-value", "min", "max", "disabled"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label"]);
}
var numberBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19]]);
var __glob_1_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": numberBuilder
});
const _sfc_main$18 = {
  name: "radioBuilder",
  components: { ElFormItem, ElRadioGroup, ElRadio },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio = ElRadio;
  const _component_el_radio_group = ElRadioGroup;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_radio_group, {
        key: 0,
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_radio, {
              key: item.value,
              label: item.value
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(item.label), 1)
              ]),
              _: 2
            }, 1032, ["label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var radioBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18]]);
var __glob_1_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": radioBuilder
});
const _sfc_main$17 = {
  name: "rateBuilder",
  components: { ElFormItem, ElRate },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_rate = ElRate;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_rate, {
        key: 0,
        class: "form-rate",
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled,
        "allow-half": $props.options.allowHalf,
        max: $props.options.max
      }, null, 8, ["model-value", "disabled", "allow-half", "max"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var rateBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17]]);
var __glob_1_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rateBuilder
});
const _sfc_main$16 = {
  name: "selectBuilder",
  components: { ElFormItem, ElSelect, ElOption },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;
  const _component_el_select = ElSelect;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_select, {
        key: 0,
        "model-value": $props.options.defaultValue,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        filterable: $props.options.filterable,
        placeholder: $props.options.placeholder,
        "no-data-text": $props.options.noDataText,
        "no-match-text": $props.options.noMatchText
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options.options.items, (item) => {
            return openBlock(), createBlock(_component_el_option, {
              key: item.value,
              label: item.label,
              value: item.value
            }, null, 8, ["label", "value"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "clearable", "disabled", "filterable", "placeholder", "no-data-text", "no-match-text"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var selectBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16]]);
var __glob_1_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": selectBuilder
});
const _sfc_main$15 = {
  name: "sliderBuilder",
  components: { ElFormItem, ElSlider },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_slider, {
        key: 0,
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled,
        min: $props.options.min,
        max: $props.options.max,
        step: $props.options.step,
        "show-stops": $props.options.showStops,
        "show-input": $props.options.showInput,
        "show-tooltip": $props.options.showToolTip
      }, null, 8, ["model-value", "disabled", "min", "max", "step", "show-stops", "show-input", "show-tooltip"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var sliderBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15]]);
var __glob_1_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": sliderBuilder
});
const _sfc_main$14 = {
  name: "switchBuilder",
  components: { ElFormItem, ElSwitch },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_switch = ElSwitch;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_switch, {
        key: 0,
        "model-value": $props.options.defaultValue,
        disabled: $props.options.disabled,
        "active-text": $props.options.activeText,
        "inactive-text": $props.options.inactiveText,
        "active-color": $props.options.activeColor,
        "inactive-color": $props.options.inactiveColor
      }, null, 8, ["model-value", "disabled", "active-text", "inactive-text", "active-color", "inactive-color"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var switchBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14]]);
var __glob_1_15 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": switchBuilder
});
const _sfc_main$13 = {
  name: "tableBuilder",
  components: { ElFormItem, objectBuilder: __unplugin_components_1$1 },
  props: {
    path: String,
    uuid: String,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_object_builder = __unplugin_components_1$1;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      createVNode(_component_object_builder, {
        uuid: $props.uuid,
        items: $props.items,
        options: $props.options,
        path: $props.path
      }, null, 8, ["uuid", "items", "options", "path"])
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var tableBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13]]);
var __glob_1_16 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tableBuilder
});
const _sfc_main$12 = {
  name: "tabsBuilder",
  components: { ElForm, ElFormItem, ElTabs, ElTabPane, ElDialog, ElInput, ElButton, objectBuilder: __unplugin_components_1$1 },
  props: {
    path: String,
    uuid: String,
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2) {
    const updateFormItem = inject("updateFormItem");
    const updateFormOption = inject("updateFormOption");
    const tabsValue = ref("");
    const tabDialog = reactive({
      title: "",
      isShow: false
    });
    const formRef = ref(null);
    const rules2 = reactive({
      label: [{ required: true, message: "\u8BF7\u8F93\u5165\u6807\u7B7E\u540D\u79F0", trigger: "change" }],
      key: [{ required: true, message: "\u8BF7\u8F93\u5165ID", trigger: "change" }]
    });
    const tabForm = reactive({
      uuid: "",
      label: "",
      key: ""
    });
    const addTab = () => {
      tabForm.uuid = "";
      tabForm.label = "\u6807\u7B7E" + (props2.items.length + 1);
      tabForm.key = "tab_" + uuid(8);
      tabDialog.isShow = true;
      tabDialog.title = "\u6DFB\u52A0";
      nextTick(() => {
        formRef.value && formRef.value.clearValidate();
      });
    };
    const editTab = () => {
      const item = props2.items.find((tab) => tab.uuid === tabsValue.value);
      if (item) {
        tabForm.uuid = item.uuid;
        tabForm.label = item.options.label;
        tabForm.key = item.options.key;
        tabDialog.isShow = true;
        tabDialog.title = "\u7F16\u8F91";
        nextTick(() => {
          formRef.value && formRef.value.clearValidate();
        });
      }
    };
    const removeTab = () => {
      const index2 = props2.items.findIndex((tab) => tab.uuid === tabsValue.value);
      const nextTab = props2.items[index2 + 1] || props2.items[index2 - 1];
      updateFormItem({ uuid: props2.uuid, items: props2.items.filter((tab) => tab.uuid !== tabsValue.value) });
      if (nextTab) {
        tabsValue.value = nextTab.uuid;
      }
    };
    const saveTab = () => {
      formRef.value.validate((valid) => {
        if (valid) {
          if (!tabForm.uuid) {
            const item = deepClone(objectLayout);
            item.uuid = item.component.replaceAll("-", "_") + "_" + uuid(8);
            item.options.label = tabForm.label;
            item.options.key = tabForm.key;
            tabsValue.value = item.uuid;
            updateFormItem({ uuid: props2.uuid, items: [...props2.items, item] });
          } else {
            const item = props2.items.find((tab) => tab.uuid === tabsValue.value);
            if (item) {
              updateFormOption({ uuid: tabForm.uuid, key: "label", value: tabForm.label });
              updateFormOption({ uuid: tabForm.uuid, key: "key", value: tabForm.key });
            }
          }
          tabDialog.isShow = false;
        }
      });
    };
    return {
      tabsValue,
      tabDialog,
      formRef,
      rules: rules2,
      tabForm,
      addTab,
      editTab,
      removeTab,
      saveTab
    };
  }
};
const _hoisted_1$h = { style: { "margin-bottom": "20px" } };
const _hoisted_2$f = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0 ");
const _hoisted_3$c = /* @__PURE__ */ createTextVNode(" \u4FEE\u6539 ");
const _hoisted_4$9 = /* @__PURE__ */ createTextVNode(" \u5220\u9664 ");
const _hoisted_5$5 = { class: "dialog-footer" };
const _hoisted_6$3 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
const _hoisted_7$2 = /* @__PURE__ */ createTextVNode("\u786E \u5B9A");
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = ElButton;
  const _component_object_builder = __unplugin_components_1$1;
  const _component_el_tab_pane = ElTabPane;
  const _component_el_tabs = ElTabs;
  const _component_el_input = ElInput;
  const _component_el_form_item = ElFormItem;
  const _component_el_form = ElForm;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", _hoisted_1$h, [
      createVNode(_component_el_button, {
        type: "primary",
        size: "small",
        onClick: $setup.addTab
      }, {
        default: withCtx(() => [
          _hoisted_2$f
        ]),
        _: 1
      }, 8, ["onClick"]),
      createVNode(_component_el_button, {
        type: "primary",
        size: "small",
        onClick: $setup.editTab
      }, {
        default: withCtx(() => [
          _hoisted_3$c
        ]),
        _: 1
      }, 8, ["onClick"]),
      createVNode(_component_el_button, {
        type: "danger",
        size: "small",
        disabled: $props.items.length <= 0,
        onClick: $setup.removeTab
      }, {
        default: withCtx(() => [
          _hoisted_4$9
        ]),
        _: 1
      }, 8, ["disabled", "onClick"])
    ]),
    createVNode(_component_el_tabs, {
      modelValue: $setup.tabsValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.tabsValue = $event),
      type: $props.options.tabType,
      "tab-position": $props.options.tabPosition
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item) => {
          return openBlock(), createBlock(_component_el_tab_pane, {
            key: item.name,
            label: item.options.label,
            name: item.uuid
          }, {
            default: withCtx(() => [
              createVNode(_component_object_builder, {
                uuid: item.uuid,
                items: item.items,
                options: item.options,
                path: $props.path + "." + item.options.key
              }, null, 8, ["uuid", "items", "options", "path"])
            ]),
            _: 2
          }, 1032, ["label", "name"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["modelValue", "type", "tab-position"]),
    createVNode(_component_el_dialog, {
      title: $setup.tabDialog.title,
      modelValue: $setup.tabDialog.isShow,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.tabDialog.isShow = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_5$5, [
          createVNode(_component_el_button, {
            onClick: _cache[3] || (_cache[3] = ($event) => $setup.tabDialog.isShow = false)
          }, {
            default: withCtx(() => [
              _hoisted_6$3
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.saveTab
          }, {
            default: withCtx(() => [
              _hoisted_7$2
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_form, {
          ref: "formRef",
          model: $setup.tabForm,
          rules: $setup.rules,
          "label-position": "left",
          "label-width": "150px",
          style: { "width": "400px", "margin-left": "50px" }
        }, {
          default: withCtx(() => [
            createVNode(_component_el_form_item, {
              label: "\u6807\u7B7E\u540D\u79F0",
              prop: "label"
            }, {
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: $setup.tabForm.label,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.tabForm.label = $event),
                  type: "text"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            createVNode(_component_el_form_item, {
              label: "ID (\u5B57\u6BB5\u540D\u79F0/\u82F1\u6587)",
              prop: "key",
              style: { "margin-top": "22px" }
            }, {
              default: withCtx(() => [
                createVNode(_component_el_input, {
                  modelValue: $setup.tabForm.key,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.tabForm.key = $event),
                  type: "text"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["model", "rules"])
      ]),
      _: 1
    }, 8, ["title", "modelValue"])
  ], 64);
}
var tabsBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12]]);
var __glob_1_17 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tabsBuilder
});
const _sfc_main$11 = {
  name: "textareaBuilder",
  components: { ElFormItem, ElInput },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_input, {
        key: 0,
        type: "textarea",
        "model-value": $props.options.defaultValue,
        rows: $props.options.rows,
        placeholder: $props.options.placeholder,
        disabled: $props.options.disabled,
        maxlength: $props.options.maxlength,
        "show-word-limit": $props.options.showWordLimit
      }, null, 8, ["model-value", "rows", "placeholder", "disabled", "maxlength", "show-word-limit"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var textareaBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11]]);
var __glob_1_18 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": textareaBuilder
});
const _sfc_main$10 = {
  name: "timePickerBuilder",
  components: { ElFormItem, ElTimePicker },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_time_picker = ElTimePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_time_picker, {
        key: 0,
        "model-value": $props.options.defaultValue,
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var timePickerBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10]]);
var __glob_1_19 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": timePickerBuilder
});
const _sfc_main$$ = {
  name: "timeRangePickerBuilder",
  components: { ElFormItem, ElTimePicker },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_time_picker = ElTimePicker;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_time_picker, {
        key: 0,
        "is-range": "",
        "model-value": $props.options.defaultValue,
        placeholder: $props.options.placeholder,
        clearable: $props.options.clearable,
        disabled: $props.options.disabled,
        format: $props.options.format,
        "prefix-icon": $props.options.prefixIcon
      }, null, 8, ["model-value", "placeholder", "clearable", "disabled", "format", "prefix-icon"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var timeRangePickerBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$]]);
var __glob_1_20 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": timeRangePickerBuilder
});
const _sfc_main$_ = {
  name: "uploadBuilder",
  components: { ElFormItem, ElUpload, ElButton },
  props: {
    path: String,
    uuid: String,
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
  }
};
const _hoisted_1$g = { class: "el-upload__tip" };
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = ElButton;
  const _component_el_upload = ElUpload;
  const _component_el_form_item = ElFormItem;
  return openBlock(), createBlock(_component_el_form_item, {
    prop: $props.path,
    label: $props.options.label,
    rules: $props.options.rules
  }, {
    default: withCtx(() => [
      !$props.options.hidden ? (openBlock(), createBlock(_component_el_upload, {
        key: 0,
        action: $props.options.uploadUrl,
        name: $props.options.uploadName,
        multiple: $props.options.multiple,
        "show-file-list": $props.options.showFileList,
        limit: $props.options.limit,
        "file-list": $props.options.defaultValue,
        disabled: $props.options.disabled
      }, createSlots({
        default: withCtx(() => [
          createVNode(_component_el_button, {
            size: "small",
            type: "primary"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.options.buttonText), 1)
            ]),
            _: 1
          })
        ]),
        _: 2
      }, [
        $props.options.showToolTip ? {
          name: "tip",
          fn: withCtx(() => [
            createElementVNode("div", _hoisted_1$g, toDisplayString($props.options.tip), 1)
          ])
        } : void 0
      ]), 1032, ["action", "name", "multiple", "show-file-list", "limit", "file-list", "disabled"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["prop", "label", "rules"]);
}
var uploadBuilder = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_]]);
var __glob_1_21 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadBuilder
});
const components$1 = {};
Object.values({ "./components/card-builder.vue": __glob_1_0, "./components/cascade-builder.vue": __glob_1_1, "./components/checkbox-builder.vue": __glob_1_2, "./components/color-picker-builder.vue": __glob_1_3, "./components/date-picker-builder.vue": __glob_1_4, "./components/date-range-picker-builder.vue": __glob_1_5, "./components/editor-builder.vue": __glob_1_6, "./components/input-builder.vue": __glob_1_7, "./components/multi-select-builder.vue": __glob_1_8, "./components/number-builder.vue": __glob_1_9, "./components/object-builder.vue": __glob_1_10, "./components/radio-builder.vue": __glob_1_11, "./components/rate-builder.vue": __glob_1_12, "./components/select-builder.vue": __glob_1_13, "./components/slider-builder.vue": __glob_1_14, "./components/switch-builder.vue": __glob_1_15, "./components/table-builder.vue": __glob_1_16, "./components/tabs-builder.vue": __glob_1_17, "./components/textarea-builder.vue": __glob_1_18, "./components/time-picker-builder.vue": __glob_1_19, "./components/time-range-picker-builder.vue": __glob_1_20, "./components/upload-builder.vue": __glob_1_21 }).forEach(({ default: component }) => components$1[component.name] = component);
const _sfc_main$Z = {
  name: "formBuilderItem",
  components: __spreadValues({}, components$1),
  props: {
    path: String,
    component: String,
    uuid: String,
    defaultValue: [String, Number, Boolean, Date, Object, Array],
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup(props2) {
    const state = inject("state");
    const setSelected = inject("setSelected");
    const copyFormItem = inject("copyFormItem");
    const removeFormItem = inject("removeFormItem");
    return {
      select: () => setSelected(props2.uuid),
      copy: () => copyFormItem(props2.uuid),
      remove: () => removeFormItem(props2.uuid),
      isSelected: computed(() => state.selected.uuid === props2.uuid)
    };
  }
};
const _hoisted_1$f = { class: "operator" };
const _hoisted_2$e = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-copy-document" }, null, -1);
const _hoisted_3$b = [
  _hoisted_2$e
];
const _hoisted_4$8 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-delete" }, null, -1);
const _hoisted_5$4 = [
  _hoisted_4$8
];
const _hoisted_6$2 = { class: "info" };
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "form-item",
    style: normalizeStyle({
      width: $props.options.width
    })
  }, [
    createElementVNode("div", {
      class: normalizeClass(["form-item-box", { "is-selected": $setup.isSelected }]),
      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $setup.select && $setup.select(...args), ["stop"]))
    }, [
      createElementVNode("div", _hoisted_1$f, [
        createElementVNode("div", {
          class: "copy",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $setup.copy && $setup.copy(...args), ["stop"]))
        }, _hoisted_3$b),
        createElementVNode("div", {
          class: "remove",
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $setup.remove && $setup.remove(...args), ["stop"]))
        }, _hoisted_5$4)
      ]),
      createElementVNode("div", _hoisted_6$2, toDisplayString($props.options.key), 1),
      (openBlock(), createBlock(resolveDynamicComponent($props.component + "-builder"), {
        uuid: $props.uuid,
        items: $props.items,
        options: $props.options,
        path: $props.path
      }, null, 8, ["uuid", "items", "options", "path"]))
    ], 2)
  ], 4);
}
var __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z]]);
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __unplugin_components_1
});
const _sfc_main$Y = {
  name: "formBuilder",
  components: { ElEmpty, ElForm, FormBuilderItem: __unplugin_components_1 },
  props: {},
  setup() {
    const state = inject("state");
    return {
      formDesign: computed(() => state.formDesign)
    };
  }
};
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_empty = ElEmpty;
  const _component_form_builder_item = __unplugin_components_1;
  const _component_el_form = ElForm;
  return openBlock(), createElementBlock(Fragment, null, [
    $setup.formDesign.items.length === 0 ? (openBlock(), createBlock(_component_el_empty, {
      key: 0,
      class: "empty",
      description: "\u4ECE\u5DE6\u4FA7\u9009\u62E9\u63A7\u4EF6\u6DFB\u52A0"
    })) : createCommentVNode("", true),
    createVNode(_component_el_form, {
      class: "form-builder",
      "label-width": $setup.formDesign.options.labelWidth,
      "label-position": $setup.formDesign.options.labelPosition,
      "hide-required-asterisk": $setup.formDesign.options.hideRequiredAsterisk,
      "status-icon": $setup.formDesign.options.statusIcon,
      inline: $setup.formDesign.options.inline,
      size: $setup.formDesign.options.size
    }, {
      default: withCtx(() => [
        createVNode(_component_form_builder_item, {
          class: "root",
          component: $setup.formDesign.component,
          uuid: $setup.formDesign.uuid,
          items: $setup.formDesign.items,
          options: $setup.formDesign.options,
          path: "root"
        }, null, 8, ["component", "uuid", "items", "options"])
      ]),
      _: 1
    }, 8, ["label-width", "label-position", "hide-required-asterisk", "status-icon", "inline", "size"])
  ], 64);
}
var __unplugin_components_2 = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y]]);
const _sfc_main$X = {
  name: "activeColorOption",
  components: { ElColorPicker },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_color_picker = ElColorPicker;
  return openBlock(), createBlock(_component_el_color_picker, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var activeColor = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X]]);
var __glob_13_0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": activeColor
});
const _sfc_main$W = {
  name: "activeTextOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var activeText = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W]]);
var __glob_13_1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": activeText
});
const _sfc_main$V = {
  name: "allowHalfOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var allowHalf = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V]]);
var __glob_13_2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": allowHalf
});
const _sfc_main$U = {
  name: "buttonTextOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var buttonText = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U]]);
var __glob_13_3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": buttonText
});
const _sfc_main$T = {
  name: "clearableOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var clearable = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T]]);
var __glob_13_4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clearable
});
const _sfc_main$S = {
  name: "collapseTagsOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var collapseTags = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S]]);
var __glob_13_5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": collapseTags
});
const _sfc_main$R = {
  name: "defaultValueOption",
  components: { FormRenderItem: __unplugin_components_0$3 },
  props: {
    modelValue: [String, Number, Boolean, Date, Object, Array]
  },
  setup() {
    const state = inject("state");
    return {
      component: computed(() => state.selected.component),
      items: computed(() => state.selected.items),
      options: computed(() => Object.assign({}, state.selected.options, {
        label: "",
        clearable: true,
        disabled: false
      }))
    };
  }
};
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_form_render_item = __unplugin_components_0$3;
  return openBlock(), createBlock(_component_form_render_item, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    component: $setup.component,
    items: $setup.items,
    options: $setup.options
  }, null, 8, ["model-value", "component", "items", "options"]);
}
var defaultValue = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R]]);
var __glob_13_6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": defaultValue
});
const _sfc_main$Q = {
  name: "disabledOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var disabled = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q]]);
var __glob_13_7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": disabled
});
var elRadioButton = "";
const _sfc_main$P = {
  name: "expandTriggerOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$e = /* @__PURE__ */ createTextVNode("\u70B9\u51FB");
const _hoisted_2$d = /* @__PURE__ */ createTextVNode("\u60AC\u6D6E");
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "click" }, {
        default: withCtx(() => [
          _hoisted_1$e
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "hover" }, {
        default: withCtx(() => [
          _hoisted_2$d
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var expandTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P]]);
var __glob_13_8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": expandTrigger
});
const _sfc_main$O = {
  name: "filterableOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var filterable = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O]]);
var __glob_13_9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": filterable
});
const _sfc_main$N = {
  name: "formatOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var format = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N]]);
var __glob_13_10 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": format
});
const _sfc_main$M = {
  name: "gutterOption",
  components: { ElSlider },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  return openBlock(), createBlock(_component_el_slider, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue = $event),
    onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event)),
    min: 0,
    max: 300
  }, null, 8, ["model-value"]);
}
var gutter = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M]]);
var __glob_13_11 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": gutter
});
const _sfc_main$L = {
  name: "heightOption",
  components: { ElSlider },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  return openBlock(), createBlock(_component_el_slider, {
    "model-value": parseInt($props.modelValue),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue = $event + "px"),
    onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event + "px")),
    min: 0,
    max: 300,
    "format-tooltip": (value) => {
      return value + "px";
    }
  }, null, 8, ["model-value", "format-tooltip"]);
}
var height = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L]]);
var __glob_13_12 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": height
});
const _sfc_main$K = {
  name: "hiddenOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var hidden = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K]]);
var __glob_13_13 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": hidden
});
const _sfc_main$J = {
  name: "hideRequiredAsteriskOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var hideRequiredAsterisk = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J]]);
var __glob_13_14 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": hideRequiredAsterisk
});
const _sfc_main$I = {
  name: "inactiveColorOption",
  components: { ElColorPicker },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_color_picker = ElColorPicker;
  return openBlock(), createBlock(_component_el_color_picker, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var inactiveColor = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
var __glob_13_15 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": inactiveColor
});
const _sfc_main$H = {
  name: "inactiveTextOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var inactiveText = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H]]);
var __glob_13_16 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": inactiveText
});
const _sfc_main$G = {
  name: "inlineOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var inline = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G]]);
var __glob_13_17 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": inline
});
const _sfc_main$F = {
  name: "keyOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var key = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
var __glob_13_18 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": key
});
const _sfc_main$E = {
  name: "labelPositionOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$d = /* @__PURE__ */ createTextVNode("\u5DE6");
const _hoisted_2$c = /* @__PURE__ */ createTextVNode("\u53F3");
const _hoisted_3$a = /* @__PURE__ */ createTextVNode("\u9876\u90E8");
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "left" }, {
        default: withCtx(() => [
          _hoisted_1$d
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "right" }, {
        default: withCtx(() => [
          _hoisted_2$c
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "top" }, {
        default: withCtx(() => [
          _hoisted_3$a
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var labelPosition = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
var __glob_13_19 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": labelPosition
});
const _sfc_main$D = {
  name: "labelWidthOption",
  components: { ElSlider },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  return openBlock(), createBlock(_component_el_slider, {
    "model-value": parseInt($props.modelValue),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue = $event + "px"),
    onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event + "px")),
    min: 0,
    max: 300,
    "format-tooltip": (value) => {
      return value + "px";
    }
  }, null, 8, ["model-value", "format-tooltip"]);
}
var labelWidth = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D]]);
var __glob_13_20 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": labelWidth
});
const _sfc_main$C = {
  name: "labelOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var label = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C]]);
var __glob_13_21 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": label
});
const _sfc_main$B = {
  name: "limitOption",
  components: { ElInputNumber },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  return openBlock(), createBlock(_component_el_input_number, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "small"
  }, null, 8, ["model-value"]);
}
var limit = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
var __glob_13_22 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": limit
});
const _sfc_main$A = {
  name: "maxOption",
  components: { ElInputNumber },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  return openBlock(), createBlock(_component_el_input_number, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "small"
  }, null, 8, ["model-value"]);
}
var max = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
var __glob_13_23 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": max
});
const _sfc_main$z = {
  name: "maxlengthOption",
  components: { ElInputNumber },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  return openBlock(), createBlock(_component_el_input_number, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event ? $event : void 0)),
    size: "small"
  }, null, 8, ["model-value"]);
}
var maxlength = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
var __glob_13_24 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": maxlength
});
const _sfc_main$y = {
  name: "minOption",
  components: { ElInputNumber },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  return openBlock(), createBlock(_component_el_input_number, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "small"
  }, null, 8, ["model-value"]);
}
var min = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
var __glob_13_25 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": min
});
const _sfc_main$x = {
  name: "multipleLimitOption",
  components: { ElInputNumber },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  return openBlock(), createBlock(_component_el_input_number, {
    "model-value": $props.modelValue,
    onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "small"
  }, null, 8, ["model-value"]);
}
var multipleLimit = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x]]);
var __glob_13_26 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": multipleLimit
});
const _sfc_main$w = {
  name: "multipleOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var multiple = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
var __glob_13_27 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": multiple
});
const _sfc_main$v = {
  name: "noDataTextOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var noDataText = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
var __glob_13_28 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": noDataText
});
const _sfc_main$u = {
  name: "noMatchTextOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var noMatchText = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
var __glob_13_29 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": noMatchText
});
var elCol = "";
var elRow = "";
const _sfc_main$t = {
  name: "optionsOption",
  components: { ElRow, ElCol, ElButton, ElDialog, ElInput, CodeMirror: __unplugin_components_0$2 },
  props: {
    modelValue: Object
  },
  setup(props2, { emit: emit2 }) {
    const data = reactive({
      remote: false,
      items: []
    });
    const code = ref("");
    const codeDialog = ref(false);
    const setInternal = () => {
      data.remote = props2.modelValue.remote;
      data.items = deepClone(props2.modelValue.items);
    };
    onMounted(setInternal);
    watch(() => props2.modelValue, setInternal);
    const emitChange = () => {
      emit2("update:modelValue", {
        remote: data.remote,
        items: data.items
      });
    };
    const update = (index2, key2, value) => {
      data.items[index2][key2] = value;
      emitChange();
    };
    const addOption = () => {
      const index2 = String(data.items.length + 1);
      data.items.push({
        label: "\u9009\u9879" + index2,
        value: index2
      });
      emitChange();
    };
    const removeOption = (index2) => {
      data.items.splice(index2, 1);
      emitChange();
    };
    const editOptions = () => {
      codeDialog.value = true;
      nextTick(() => {
        code.value = JSON.stringify(data.items, null, "	");
      });
    };
    const setOptions = () => {
      try {
        data.items = JSON.parse(code.value);
      } catch (e) {
        return ElMessage.error("\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      codeDialog.value = false;
      emitChange();
    };
    return {
      data,
      code,
      codeDialog,
      update,
      emitChange,
      addOption,
      removeOption,
      editOptions,
      setOptions
    };
  }
};
const _hoisted_1$c = ["onClick"];
const _hoisted_2$b = /* @__PURE__ */ createTextVNode("\u589E\u52A0\u9009\u9879");
const _hoisted_3$9 = /* @__PURE__ */ createTextVNode("\u7F16\u8F91\u9009\u9879");
const _hoisted_4$7 = { class: "json-box" };
const _hoisted_5$3 = { class: "dialog-footer" };
const _hoisted_6$1 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
const _hoisted_7$1 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  const _component_el_col = ElCol;
  const _component_el_row = ElRow;
  const _component_el_button = ElButton;
  const _component_code_mirror = __unplugin_components_0$2;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($setup.data.items, (item, index2) => {
      return openBlock(), createBlock(_component_el_row, {
        class: "option-row",
        key: index2,
        gutter: 5
      }, {
        default: withCtx(() => [
          createVNode(_component_el_col, { span: 11 }, {
            default: withCtx(() => [
              createVNode(_component_el_input, {
                "model-value": item.label,
                onInput: ($event) => $setup.update(index2, "label", $event),
                placeholder: "\u540D\u79F0"
              }, null, 8, ["model-value", "onInput"])
            ]),
            _: 2
          }, 1024),
          createVNode(_component_el_col, { span: 11 }, {
            default: withCtx(() => [
              createVNode(_component_el_input, {
                "model-value": item.value,
                onInput: ($event) => $setup.update(index2, "value", $event),
                placeholder: "\u503C"
              }, null, 8, ["model-value", "onInput"])
            ]),
            _: 2
          }, 1024),
          createVNode(_component_el_col, {
            span: 2,
            class: "btn-del"
          }, {
            default: withCtx(() => [
              createElementVNode("i", {
                class: "el-icon-delete",
                onClick: ($event) => $setup.removeOption(index2)
              }, null, 8, _hoisted_1$c)
            ]),
            _: 2
          }, 1024)
        ]),
        _: 2
      }, 1024);
    }), 128)),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.addOption
    }, {
      default: withCtx(() => [
        _hoisted_2$b
      ]),
      _: 1
    }, 8, ["onClick"]),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.editOptions
    }, {
      default: withCtx(() => [
        _hoisted_3$9
      ]),
      _: 1
    }, 8, ["onClick"]),
    createVNode(_component_el_dialog, {
      title: "\u7F16\u8F91\u9009\u9879",
      modelValue: $setup.codeDialog,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.codeDialog = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_5$3, [
          createVNode(_component_el_button, {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.codeDialog = false)
          }, {
            default: withCtx(() => [
              _hoisted_6$1
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.setOptions
          }, {
            default: withCtx(() => [
              _hoisted_7$1
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_4$7, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.code,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var options = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t]]);
var __glob_13_30 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": options
});
const _sfc_main$s = {
  name: "paddingOption",
  components: { ElRow, ElCol, ElInputNumber },
  props: {
    modelValue: String
  },
  setup(props2, { emit: emit2 }) {
    const data = reactive({
      top: 0,
      right: 0,
      down: 0,
      left: 0
    });
    const setInternal = () => {
      const [top2, right2, down, left2] = props2.modelValue.split(" ");
      data.top = parseFloat(top2);
      data.right = parseFloat(right2);
      data.down = parseFloat(down);
      data.left = parseFloat(left2);
    };
    onMounted(setInternal);
    watch(() => props2.modelValue, setInternal);
    const emitChange = () => {
      emit2("update:modelValue", `${data.top || 0}px ${data.right || 0}px ${data.down || 0}px ${data.left || 0}px`);
    };
    return { data, emitChange };
  }
};
const _hoisted_1$b = /* @__PURE__ */ createTextVNode(" \u4E0A\uFF1A");
const _hoisted_2$a = /* @__PURE__ */ createTextVNode(" \u53F3\uFF1A");
const _hoisted_3$8 = /* @__PURE__ */ createTextVNode(" \u4E0B\uFF1A");
const _hoisted_4$6 = /* @__PURE__ */ createTextVNode(" \u5DE6\uFF1A");
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = ElInputNumber;
  const _component_el_col = ElCol;
  const _component_el_row = ElRow;
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_el_row, { class: "option-row" }, {
      default: withCtx(() => [
        createVNode(_component_el_col, { span: 24 }, {
          default: withCtx(() => [
            _hoisted_1$b,
            createVNode(_component_el_input_number, {
              modelValue: $setup.data.top,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.data.top = $event),
              onInput: $setup.emitChange,
              size: "small"
            }, null, 8, ["modelValue", "onInput"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_row, { class: "option-row" }, {
      default: withCtx(() => [
        createVNode(_component_el_col, { span: 24 }, {
          default: withCtx(() => [
            _hoisted_2$a,
            createVNode(_component_el_input_number, {
              modelValue: $setup.data.right,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.data.right = $event),
              onInput: $setup.emitChange,
              size: "small"
            }, null, 8, ["modelValue", "onInput"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_row, { class: "option-row" }, {
      default: withCtx(() => [
        createVNode(_component_el_col, { span: 24 }, {
          default: withCtx(() => [
            _hoisted_3$8,
            createVNode(_component_el_input_number, {
              modelValue: $setup.data.down,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.data.down = $event),
              onInput: $setup.emitChange,
              size: "small"
            }, null, 8, ["modelValue", "onInput"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_row, { class: "option-row" }, {
      default: withCtx(() => [
        createVNode(_component_el_col, { span: 24 }, {
          default: withCtx(() => [
            _hoisted_4$6,
            createVNode(_component_el_input_number, {
              modelValue: $setup.data.left,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.data.left = $event),
              onInput: $setup.emitChange,
              size: "small"
            }, null, 8, ["modelValue", "onInput"])
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ], 64);
}
var padding = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
var __glob_13_31 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": padding
});
const _sfc_main$r = {
  name: "placeholderOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var placeholder = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
var __glob_13_32 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": placeholder
});
const _sfc_main$q = {
  name: "prefixIconOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var prefixIcon = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
var __glob_13_33 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": prefixIcon
});
const _sfc_main$p = {
  name: "rowsOption",
  components: { ElSlider },
  props: {
    modelValue: Number
  },
  setup() {
  }
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  return openBlock(), createBlock(_component_el_slider, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue = $event),
    onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event)),
    min: 2,
    max: 10
  }, null, 8, ["model-value"]);
}
var rows = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
var __glob_13_34 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rows
});
const _sfc_main$o = {
  name: "rulesOption",
  components: { ElRow, ElCol, ElCheckbox, ElInput, ElButton, ElDialog, CodeMirror: __unplugin_components_0$2 },
  props: {
    modelValue: Array
  },
  setup(props2, { emit: emit2 }) {
    const data = reactive({
      required: { required: false, message: "\u5FC5\u586B\u9879", trigger: "blur" },
      patterns: []
    });
    const code = ref("");
    const codeDialog = ref(false);
    const setInternal = () => {
      data.required = deepClone(props2.modelValue[0]);
      data.patterns = deepClone(props2.modelValue.slice(1));
    };
    onMounted(setInternal);
    watch(() => props2.modelValue, setInternal);
    const emitChange = () => {
      emit2("update:modelValue", [data.required, ...data.patterns]);
    };
    const update = (index2, key2, value) => {
      data.patterns[index2][key2] = value;
      emitChange();
    };
    const addRule = () => {
      data.patterns.push({
        pattern: "",
        message: "",
        trigger: "blur"
      });
      emitChange();
    };
    const removeRule = (index2) => {
      data.patterns.splice(index2, 1);
      emitChange();
    };
    const editRules = () => {
      codeDialog.value = true;
      nextTick(() => {
        code.value = JSON.stringify(data.patterns, null, "	");
      });
    };
    const setRules = () => {
      try {
        data.patterns = JSON.parse(code.value);
      } catch (e) {
        return ElMessage.error("\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      codeDialog.value = false;
      emitChange();
    };
    return {
      data,
      code,
      codeDialog,
      update,
      emitChange,
      addRule,
      removeRule,
      editRules,
      setRules
    };
  }
};
const _hoisted_1$a = /* @__PURE__ */ createTextVNode(" \u5FC5\u586B ");
const _hoisted_2$9 = ["onClick"];
const _hoisted_3$7 = /* @__PURE__ */ createTextVNode("\u589E\u52A0\u9A8C\u8BC1");
const _hoisted_4$5 = /* @__PURE__ */ createTextVNode("\u7F16\u8F91\u9A8C\u8BC1");
const _hoisted_5$2 = { class: "json-box" };
const _hoisted_6 = { class: "dialog-footer" };
const _hoisted_7 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
const _hoisted_8 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  const _component_el_col = ElCol;
  const _component_el_input = ElInput;
  const _component_el_row = ElRow;
  const _component_el_button = ElButton;
  const _component_code_mirror = __unplugin_components_0$2;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_el_row, {
      class: "option-row",
      gutter: 5
    }, {
      default: withCtx(() => [
        createVNode(_component_el_col, { span: 11 }, {
          default: withCtx(() => [
            createVNode(_component_el_checkbox, {
              modelValue: $setup.data.required.required,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.data.required.required = $event),
              onChange: $setup.emitChange
            }, {
              default: withCtx(() => [
                _hoisted_1$a
              ]),
              _: 1
            }, 8, ["modelValue", "onChange"])
          ]),
          _: 1
        }),
        createVNode(_component_el_col, { span: 11 }, {
          default: withCtx(() => [
            createVNode(_component_el_input, {
              modelValue: $setup.data.required.message,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.data.required.message = $event),
              onInput: $setup.emitChange,
              placeholder: "\u63D0\u793A\u4FE1\u606F"
            }, null, 8, ["modelValue", "onInput"])
          ]),
          _: 1
        }),
        createVNode(_component_el_col, { span: 2 })
      ]),
      _: 1
    }),
    (openBlock(true), createElementBlock(Fragment, null, renderList($setup.data.patterns, (rule, index2) => {
      return openBlock(), createBlock(_component_el_row, {
        class: "option-row",
        key: index2,
        gutter: 5
      }, {
        default: withCtx(() => [
          createVNode(_component_el_col, { span: 11 }, {
            default: withCtx(() => [
              createVNode(_component_el_input, {
                "model-value": rule.pattern,
                onInput: ($event) => $setup.update(index2, "pattern", $event),
                placeholder: "\u6B63\u5219\u8868\u8FBE\u5F0F"
              }, null, 8, ["model-value", "onInput"])
            ]),
            _: 2
          }, 1024),
          createVNode(_component_el_col, { span: 11 }, {
            default: withCtx(() => [
              createVNode(_component_el_input, {
                "model-value": rule.message,
                onInput: ($event) => $setup.update(index2, "message", $event),
                placeholder: "\u63D0\u793A\u4FE1\u606F"
              }, null, 8, ["model-value", "onInput"])
            ]),
            _: 2
          }, 1024),
          createVNode(_component_el_col, {
            span: 2,
            class: "btn-del"
          }, {
            default: withCtx(() => [
              createElementVNode("i", {
                class: "el-icon-delete",
                onClick: ($event) => $setup.removeRule(index2)
              }, null, 8, _hoisted_2$9)
            ]),
            _: 2
          }, 1024)
        ]),
        _: 2
      }, 1024);
    }), 128)),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.addRule
    }, {
      default: withCtx(() => [
        _hoisted_3$7
      ]),
      _: 1
    }, 8, ["onClick"]),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.editRules
    }, {
      default: withCtx(() => [
        _hoisted_4$5
      ]),
      _: 1
    }, 8, ["onClick"]),
    createVNode(_component_el_dialog, {
      title: "\u7F16\u8F91\u9A8C\u8BC1",
      modelValue: $setup.codeDialog,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.codeDialog = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_6, [
          createVNode(_component_el_button, {
            onClick: _cache[3] || (_cache[3] = ($event) => $setup.codeDialog = false)
          }, {
            default: withCtx(() => [
              _hoisted_7
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.setRules
          }, {
            default: withCtx(() => [
              _hoisted_8
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_5$2, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.code,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var rules = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
var __glob_13_35 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": rules
});
const _sfc_main$n = {
  name: "shadowOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$9 = /* @__PURE__ */ createTextVNode("\u603B\u662F");
const _hoisted_2$8 = /* @__PURE__ */ createTextVNode("\u60AC\u6D6E");
const _hoisted_3$6 = /* @__PURE__ */ createTextVNode("\u4ECE\u4E0D");
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "always" }, {
        default: withCtx(() => [
          _hoisted_1$9
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "hover" }, {
        default: withCtx(() => [
          _hoisted_2$8
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "never" }, {
        default: withCtx(() => [
          _hoisted_3$6
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var shadow = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
var __glob_13_36 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": shadow
});
const _sfc_main$m = {
  name: "showAlphaOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showAlpha = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
var __glob_13_37 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showAlpha
});
const _sfc_main$l = {
  name: "showFileListOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showFileList = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
var __glob_13_38 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showFileList
});
const _sfc_main$k = {
  name: "showInputOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showInput = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
var __glob_13_39 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showInput
});
const _sfc_main$j = {
  name: "showPasswordOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showPassword = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
var __glob_13_40 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showPassword
});
const _sfc_main$i = {
  name: "showStopsOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showStops = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
var __glob_13_41 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showStops
});
const _sfc_main$h = {
  name: "showToolTipOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
var __glob_13_42 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showTooltip
});
const _sfc_main$g = {
  name: "showWordLimitOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var showWordLimit = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
var __glob_13_43 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": showWordLimit
});
const _sfc_main$f = {
  name: "sizeOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$8 = /* @__PURE__ */ createTextVNode("\u6B63\u5E38");
const _hoisted_2$7 = /* @__PURE__ */ createTextVNode("\u5C0F\u53F7");
const _hoisted_3$5 = /* @__PURE__ */ createTextVNode("\u8FF7\u4F60");
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "medium" }, {
        default: withCtx(() => [
          _hoisted_1$8
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "small" }, {
        default: withCtx(() => [
          _hoisted_2$7
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "mini" }, {
        default: withCtx(() => [
          _hoisted_3$5
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var size = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
var __glob_13_44 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": size
});
const _sfc_main$e = {
  name: "statusIconOption",
  components: { ElCheckbox },
  props: {
    modelValue: Boolean
  },
  setup() {
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = ElCheckbox;
  return openBlock(), createBlock(_component_el_checkbox, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var statusIcon = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
var __glob_13_45 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": statusIcon
});
const _sfc_main$d = {
  name: "suffixIconOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var suffixIcon = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
var __glob_13_46 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": suffixIcon
});
const _sfc_main$c = {
  name: "tabPositionOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$7 = /* @__PURE__ */ createTextVNode("\u4E0A");
const _hoisted_2$6 = /* @__PURE__ */ createTextVNode("\u53F3");
const _hoisted_3$4 = /* @__PURE__ */ createTextVNode("\u4E0B");
const _hoisted_4$4 = /* @__PURE__ */ createTextVNode("\u5DE6");
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "top" }, {
        default: withCtx(() => [
          _hoisted_1$7
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "right" }, {
        default: withCtx(() => [
          _hoisted_2$6
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "bottom" }, {
        default: withCtx(() => [
          _hoisted_3$4
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "left" }, {
        default: withCtx(() => [
          _hoisted_4$4
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var tabPosition = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var __glob_13_47 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tabPosition
});
const _sfc_main$b = {
  name: "tabTypeOption",
  components: { ElRadioGroup, ElRadioButton },
  props: {
    modelValue: String
  },
  setup() {
  }
};
const _hoisted_1$6 = /* @__PURE__ */ createTextVNode("\u9009\u9879\u5361");
const _hoisted_2$5 = /* @__PURE__ */ createTextVNode("\u5361\u7247\u5316");
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = ElRadioButton;
  const _component_el_radio_group = ElRadioGroup;
  return openBlock(), createBlock(_component_el_radio_group, {
    "model-value": $props.modelValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event)),
    size: "mini"
  }, {
    default: withCtx(() => [
      createVNode(_component_el_radio_button, { label: "card" }, {
        default: withCtx(() => [
          _hoisted_1$6
        ]),
        _: 1
      }),
      createVNode(_component_el_radio_button, { label: "border-card" }, {
        default: withCtx(() => [
          _hoisted_2$5
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var tabType = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
var __glob_13_48 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tabType
});
const _sfc_main$a = {
  name: "tipOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var tip = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var __glob_13_49 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": tip
});
const _sfc_main$9 = {
  name: "uploadDataOption",
  components: { ElDialog, ElButton, CodeMirror: __unplugin_components_0$2 },
  props: {
    modelValue: Object
  },
  setup(props2, { emit: emit2 }) {
    const code = ref("");
    const codeDialog = ref(false);
    const editData = () => {
      codeDialog.value = true;
      nextTick(() => {
        code.value = JSON.stringify(props2.modelValue, null, "	");
      });
    };
    const setData = () => {
      try {
        const modelValue = JSON.parse(code.value);
        emit2("update:modelValue", modelValue);
      } catch (e) {
        return ElMessage.error("\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      codeDialog.value = false;
    };
    return {
      code,
      codeDialog,
      editData,
      setData
    };
  }
};
const _hoisted_1$5 = { class: "json-box" };
const _hoisted_2$4 = { class: "dialog-footer" };
const _hoisted_3$3 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
const _hoisted_4$3 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
const _hoisted_5$1 = /* @__PURE__ */ createTextVNode("\u7F16\u8F91\u6570\u636E");
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_code_mirror = __unplugin_components_0$2;
  const _component_el_button = ElButton;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_el_dialog, {
      title: "\u7F16\u8F91\u989D\u5916\u53C2\u6570",
      modelValue: $setup.codeDialog,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.codeDialog = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_2$4, [
          createVNode(_component_el_button, {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.codeDialog = false)
          }, {
            default: withCtx(() => [
              _hoisted_3$3
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.setData
          }, {
            default: withCtx(() => [
              _hoisted_4$3
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$5, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.code,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.editData
    }, {
      default: withCtx(() => [
        _hoisted_5$1
      ]),
      _: 1
    }, 8, ["onClick"])
  ], 64);
}
var uploadData = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
var __glob_13_50 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadData
});
const _sfc_main$8 = {
  name: "uploadHeadersOption",
  components: { ElDialog, ElButton, CodeMirror: __unplugin_components_0$2 },
  props: {
    modelValue: Object
  },
  setup(props2, { emit: emit2 }) {
    const code = ref("");
    const codeDialog = ref(false);
    const editData = () => {
      codeDialog.value = true;
      nextTick(() => {
        code.value = JSON.stringify(props2.modelValue, null, "	");
      });
    };
    const setData = () => {
      try {
        const modelValue = JSON.parse(code.value);
        emit2("update:modelValue", modelValue);
      } catch (e) {
        return ElMessage.error("\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");
      }
      codeDialog.value = false;
    };
    return {
      code,
      codeDialog,
      editData,
      setData
    };
  }
};
const _hoisted_1$4 = { class: "json-box" };
const _hoisted_2$3 = { class: "dialog-footer" };
const _hoisted_3$2 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
const _hoisted_4$2 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
const _hoisted_5 = /* @__PURE__ */ createTextVNode("\u7F16\u8F91\u6570\u636E");
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_code_mirror = __unplugin_components_0$2;
  const _component_el_button = ElButton;
  const _component_el_dialog = ElDialog;
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_el_dialog, {
      title: "\u7F16\u8F91\u8BF7\u6C42\u5934\u90E8",
      modelValue: $setup.codeDialog,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.codeDialog = $event),
      width: "750px"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_2$3, [
          createVNode(_component_el_button, {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.codeDialog = false)
          }, {
            default: withCtx(() => [
              _hoisted_3$2
            ]),
            _: 1
          }),
          createVNode(_component_el_button, {
            type: "primary",
            onClick: $setup.setData
          }, {
            default: withCtx(() => [
              _hoisted_4$2
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$4, [
          createVNode(_component_code_mirror, {
            modelValue: $setup.code,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.code = $event)
          }, null, 8, ["modelValue"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue"]),
    createVNode(_component_el_button, {
      type: "text",
      onClick: $setup.editData
    }, {
      default: withCtx(() => [
        _hoisted_5
      ]),
      _: 1
    }, 8, ["onClick"])
  ], 64);
}
var uploadHeaders = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
var __glob_13_51 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadHeaders
});
const _sfc_main$7 = {
  name: "uploadNameOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var uploadName = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
var __glob_13_52 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadName
});
const _sfc_main$6 = {
  name: "uploadSizeOption",
  components: { ElInput, ElSelect, ElOption },
  props: {
    modelValue: String
  },
  setup(props2, { emit: emit2 }) {
    const size2 = ref(0);
    const unit = ref("KB");
    const setInternal = () => {
      size2.value = parseFloat(props2.modelValue);
      unit.value = props2.modelValue.substr(props2.modelValue.length - 2);
    };
    watch(() => props2.modelValue, setInternal);
    onMounted(setInternal);
    const update = () => {
      emit2("update:modelValue", size2.value + unit.value);
    };
    return {
      size: size2,
      unit,
      update
    };
  }
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = ElOption;
  const _component_el_select = ElSelect;
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    modelValue: $setup.size,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.size = $event),
    modelModifiers: { number: true },
    onInput: $setup.update
  }, {
    append: withCtx(() => [
      createVNode(_component_el_select, {
        modelValue: $setup.unit,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.unit = $event),
        style: { width: "70px" },
        onChange: $setup.update
      }, {
        default: withCtx(() => [
          createVNode(_component_el_option, {
            label: "KB",
            value: "KB"
          }),
          createVNode(_component_el_option, {
            label: "MB",
            value: "MB"
          }),
          createVNode(_component_el_option, {
            label: "GB",
            value: "GB"
          })
        ]),
        _: 1
      }, 8, ["modelValue", "onChange"])
    ]),
    _: 1
  }, 8, ["modelValue", "onInput"]);
}
var uploadSize = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
var __glob_13_53 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadSize
});
const _sfc_main$5 = {
  name: "uploadUrlOption",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $props.modelValue,
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, null, 8, ["model-value"]);
}
var uploadUrl = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
var __glob_13_54 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": uploadUrl
});
const _sfc_main$4 = {
  name: "widthOption",
  components: { ElSlider },
  props: {
    modelValue: String
  },
  setup() {
  }
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = ElSlider;
  return openBlock(), createBlock(_component_el_slider, {
    "model-value": parseInt($props.modelValue),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.modelValue = $event + "%"),
    onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:modelValue", $event + "%")),
    min: 0,
    max: 100,
    marks: { 33: "1/3", 50: "1/2", 66: "2/3" }
  }, null, 8, ["model-value"]);
}
var width = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var __glob_13_55 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": width
});
const _sfc_main$3 = {
  name: "interpolation",
  components: { ElInput },
  props: {
    modelValue: String
  },
  setup() {
    return {
      getInterpolation
    };
  }
};
const _hoisted_1$3 = /* @__PURE__ */ createElementVNode("span", { innerHTML: "{{" }, null, -1);
const _hoisted_2$2 = /* @__PURE__ */ createElementVNode("span", { innerHTML: "}}" }, null, -1);
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = ElInput;
  return openBlock(), createBlock(_component_el_input, {
    type: "text",
    "model-value": $setup.getInterpolation($props.modelValue).trim(),
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.trim() ? `{{${$event.trim()}}}` : "{{  }}")),
    placeholder: "\u8BF7\u8F93\u5165JS\u8868\u8FBE\u5F0F"
  }, {
    prefix: withCtx(() => [
      _hoisted_1$3
    ]),
    suffix: withCtx(() => [
      _hoisted_2$2
    ]),
    _: 1
  }, 8, ["model-value"]);
}
var __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const _hoisted_1$2 = {
  class: "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  width: "200",
  height: "200"
};
const _hoisted_2$1 = /* @__PURE__ */ createElementVNode("path", { d: "M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1 192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9c-5.2-4.4-13.1-.7-13.1 6.1v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2c-1.8 1.5-2.9 3.8-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1z" }, null, -1);
const _hoisted_3$1 = /* @__PURE__ */ createElementVNode("path", { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" }, null, -1);
const _hoisted_4$1 = [
  _hoisted_2$1,
  _hoisted_3$1
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_4$1);
}
const components = {};
Object.values({ "./components/active-color.vue": __glob_13_0, "./components/active-text.vue": __glob_13_1, "./components/allow-half.vue": __glob_13_2, "./components/button-text.vue": __glob_13_3, "./components/clearable.vue": __glob_13_4, "./components/collapse-tags.vue": __glob_13_5, "./components/default-value.vue": __glob_13_6, "./components/disabled.vue": __glob_13_7, "./components/expand-trigger.vue": __glob_13_8, "./components/filterable.vue": __glob_13_9, "./components/format.vue": __glob_13_10, "./components/gutter.vue": __glob_13_11, "./components/height.vue": __glob_13_12, "./components/hidden.vue": __glob_13_13, "./components/hide-required-asterisk.vue": __glob_13_14, "./components/inactive-color.vue": __glob_13_15, "./components/inactive-text.vue": __glob_13_16, "./components/inline.vue": __glob_13_17, "./components/key.vue": __glob_13_18, "./components/label-position.vue": __glob_13_19, "./components/label-width.vue": __glob_13_20, "./components/label.vue": __glob_13_21, "./components/limit.vue": __glob_13_22, "./components/max.vue": __glob_13_23, "./components/maxlength.vue": __glob_13_24, "./components/min.vue": __glob_13_25, "./components/multiple-limit.vue": __glob_13_26, "./components/multiple.vue": __glob_13_27, "./components/no-data-text.vue": __glob_13_28, "./components/no-match-text.vue": __glob_13_29, "./components/options.vue": __glob_13_30, "./components/padding.vue": __glob_13_31, "./components/placeholder.vue": __glob_13_32, "./components/prefix-icon.vue": __glob_13_33, "./components/rows.vue": __glob_13_34, "./components/rules.vue": __glob_13_35, "./components/shadow.vue": __glob_13_36, "./components/show-alpha.vue": __glob_13_37, "./components/show-file-list.vue": __glob_13_38, "./components/show-input.vue": __glob_13_39, "./components/show-password.vue": __glob_13_40, "./components/show-stops.vue": __glob_13_41, "./components/show-tooltip.vue": __glob_13_42, "./components/show-word-limit.vue": __glob_13_43, "./components/size.vue": __glob_13_44, "./components/status-icon.vue": __glob_13_45, "./components/suffix-icon.vue": __glob_13_46, "./components/tab-position.vue": __glob_13_47, "./components/tab-type.vue": __glob_13_48, "./components/tip.vue": __glob_13_49, "./components/upload-data.vue": __glob_13_50, "./components/upload-headers.vue": __glob_13_51, "./components/upload-name.vue": __glob_13_52, "./components/upload-size.vue": __glob_13_53, "./components/upload-url.vue": __glob_13_54, "./components/width.vue": __glob_13_55 }).forEach(({ default: component }) => components[component.name] = component);
const _sfc_main$2 = {
  name: "formOption",
  components: __spreadValues({ ElRow, ElCol, ElFormItem, CodeIcon: render, Interpolation: __unplugin_components_0$1 }, components),
  props: {
    optionKey: String,
    optionValue: [String, Number, Boolean, Date, Object, Array]
  },
  setup() {
    const updateSelectedFormOption = inject("updateSelectedFormOption");
    const switchInterpolate = inject("switchInterpolate");
    return {
      isPrimitive,
      validateInterpolation,
      optionKeyLabels,
      updateOption: (key2, value) => updateSelectedFormOption({ key: key2, value }),
      switchInterpolate: (key2) => switchInterpolate(key2)
    };
  }
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_interpolation = __unplugin_components_0$1;
  const _component_el_form_item = ElFormItem;
  const _component_el_col = ElCol;
  const _component_CodeIcon = resolveComponent("CodeIcon");
  const _component_el_row = ElRow;
  return openBlock(), createBlock(_component_el_row, null, {
    default: withCtx(() => [
      createVNode(_component_el_col, {
        span: $setup.isPrimitive($props.optionValue) ? 22 : 24
      }, {
        default: withCtx(() => [
          createVNode(_component_el_form_item, {
            label: $setup.optionKeyLabels[$props.optionKey]
          }, {
            default: withCtx(() => [
              $setup.validateInterpolation($props.optionValue) ? (openBlock(), createBlock(_component_interpolation, {
                key: 0,
                "model-value": $props.optionValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.updateOption($props.optionKey, $event))
              }, null, 8, ["model-value"])) : (openBlock(), createBlock(resolveDynamicComponent($props.optionKey + "Option"), {
                key: 1,
                "model-value": $props.optionValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.updateOption($props.optionKey, $event))
              }, null, 8, ["model-value"]))
            ]),
            _: 1
          }, 8, ["label"])
        ]),
        _: 1
      }, 8, ["span"]),
      $setup.isPrimitive($props.optionValue) && $props.optionKey !== "defaultValue" ? (openBlock(), createBlock(_component_el_col, {
        key: 0,
        span: 2,
        class: "code-switch"
      }, {
        default: withCtx(() => [
          createVNode(_component_CodeIcon, {
            class: "svg-icon",
            "class-name": $setup.validateInterpolation($props.optionValue) ? "highlight" : "",
            onClick: _cache[2] || (_cache[2] = ($event) => $setup.switchInterpolate($props.optionKey))
          }, null, 8, ["class-name"])
        ]),
        _: 1
      })) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = {
  name: "formSetting",
  components: { ElForm, formOption: __unplugin_components_0 },
  props: {},
  setup() {
    const state = inject("state");
    return {
      selected: computed(() => state.selected)
    };
  }
};
const _hoisted_1$1 = { class: "form-setting" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_form_option = __unplugin_components_0;
  const _component_el_form = ElForm;
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createVNode(_component_el_form, {
      "label-position": "left",
      "label-width": "120px",
      key: $setup.selected.uuid
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.selected.options, (value, key2) => {
          return openBlock(), createElementBlock("div", { key: key2 }, [
            key2 !== "defaultValue" || !$setup.selected.items ? (openBlock(), createBlock(_component_form_option, {
              key: 0,
              "option-key": key2,
              "option-value": value
            }, null, 8, ["option-key", "option-value"])) : createCommentVNode("", true)
          ]);
        }), 128))
      ]),
      _: 1
    })
  ]);
}
var __unplugin_components_3 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const query = (items, uuid2) => {
  let result = false;
  if (!uuid2) {
    return false;
  }
  for (let i = 0; i < items.length; i++) {
    if (items[i].uuid === uuid2) {
      return items[i];
    }
    if (items[i].items && items[i].items.length) {
      result = query(items[i].items, uuid2);
      if (!isEmptyObject(result)) {
        return result;
      }
    }
  }
  return result;
};
const copy = (items, uuid$1) => {
  if (!uuid$1) {
    return false;
  }
  for (let i = 0; i < items.length; i++) {
    if (items[i].uuid === uuid$1) {
      let newItem = deepClone(items[i]);
      newItem.uuid = newItem.options.key = newItem.component.replaceAll("-", "_") + "_" + uuid(8);
      if (hasOwn$1(newItem, "items")) {
        newItem.items = [];
      }
      items.splice(i + 1, 0, newItem);
      return newItem;
    }
    if (items[i].items && items[i].items.length) {
      const newItem = copy(items[i].items, uuid$1);
      if (newItem) {
        return newItem;
      }
    }
  }
  return false;
};
const remove = (items, uuid2) => {
  if (!uuid2) {
    return false;
  }
  for (let i = 0; i < items.length; i++) {
    if (items[i].uuid === uuid2) {
      items.splice(i, 1);
      return true;
    }
    if (items[i].items && items[i].items.length) {
      if (remove(items[i].items, uuid2)) {
        return true;
      }
    }
  }
};
const _sfc_main = {
  components: { left: __unplugin_components_0$6, operator: __unplugin_components_1$2, FormBuilder: __unplugin_components_2, FormSetting: __unplugin_components_3 },
  setup() {
    let state = reactive({
      formDesign: {},
      selected: {},
      cached: [],
      current: -1
    });
    const setSelected = (uuid2) => {
      state.selected = query([state.formDesign], uuid2) || state.formDesign;
    };
    const updateFormItem = ({ uuid: uuid2, items }) => {
      const target = query([state.formDesign], uuid2);
      if (target) {
        target.items = items;
      }
      addCache();
    };
    const updateFormOption = ({ uuid: uuid2, key: key2, value }) => {
      const item = query([state.formDesign], uuid2);
      if (item) {
        item.options[key2] = value;
      }
    };
    const updateSelectedFormOption = ({ key: key2, value }) => {
      state.selected.options[key2] = value;
      addCache();
    };
    const switchInterpolate = (key2) => {
      const option2 = state.selected.options[key2];
      state.selected.options[key2] = validateInterpolation(option2) ? components$3.find((component) => component.name === state.selected.name).options[key2] : "{{  }}";
      addCache();
    };
    const copyFormItem = (uuid2) => {
      const newItem = copy(state.formDesign.items, uuid2);
      state.selected = newItem;
      addCache();
    };
    const removeFormItem = (uuid2) => {
      remove(state.formDesign.items, uuid2);
      state.selected = state.formDesign;
      addCache();
    };
    const revoke = () => {
      if (state.cached.length && state.current > 0) {
        state.current--;
        state.formDesign = deepClone(state.cached[state.current]);
        setSelected(state.selected.uuid);
      }
    };
    const forward = () => {
      if (state.cached.length && state.current < state.cached.length - 1) {
        state.current++;
        state.formDesign = deepClone(state.cached[state.current]);
        setSelected(state.selected.uuid);
      }
    };
    const addCache = () => {
      if (state.cached.length >= 10) {
        state.cached.shift();
      }
      state.cached.splice(state.current + 1, Infinity, deepClone(state.formDesign));
      state.current = state.cached.length - 1;
    };
    const init = (config) => {
      state.formDesign = config || deepClone(form);
      state.selected = query([state.formDesign], state.selected.uuid) || state.formDesign;
      addCache();
    };
    init();
    watch(() => state.formDesign, debounce$3(() => {
      ElMessage.success("\u5DF2\u81EA\u52A8\u4FDD\u5B58");
    }, 3e3), { deep: true });
    provide("state", state);
    provide("clear", init);
    provide("init", init);
    provide("setSelected", setSelected);
    provide("updateFormItem", updateFormItem);
    provide("updateFormOption", updateFormOption);
    provide("updateSelectedFormOption", updateSelectedFormOption);
    provide("switchInterpolate", switchInterpolate);
    provide("copyFormItem", copyFormItem);
    provide("removeFormItem", removeFormItem);
    provide("revoke", revoke);
    provide("forward", forward);
    return {
      init
    };
  }
};
const _hoisted_1 = { class: "form-design" };
const _hoisted_2 = { class: "left-container" };
const _hoisted_3 = { class: "center-container" };
const _hoisted_4 = { class: "right-container" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_left = __unplugin_components_0$6;
  const _component_operator = __unplugin_components_1$2;
  const _component_form_builder = __unplugin_components_2;
  const _component_form_setting = __unplugin_components_3;
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", _hoisted_2, [
      createVNode(_component_left)
    ]),
    createElementVNode("div", _hoisted_3, [
      createVNode(_component_operator),
      createVNode(_component_form_builder)
    ]),
    createElementVNode("div", _hoisted_4, [
      createVNode(_component_form_setting)
    ])
  ]);
}
var FormDesign = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var index = "";
function install(app) {
  app.component("FormDesign", FormDesign);
  app.component("FormRender", FormRender);
}
export { FormDesign, FormRender, install as default };
